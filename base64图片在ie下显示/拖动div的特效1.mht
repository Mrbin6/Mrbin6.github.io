From: =?gb2312?B?08kgV2luZG93cyBJbnRlcm5ldCBFeHBsb3JlciA5ILGjtOY=?=
Subject: =?gb2312?B?zc+2r2RpdrXEzNjQpzE=?=
Date: Fri, 8 Jan 2016 12:46:30 +0800
MIME-Version: 1.0
Content-Type: multipart/related;
	type="text/html";
	boundary="----=_NextPart_000_0000_01D14A12.98FB2E40"
X-MimeOLE: Produced By Microsoft MimeOLE V6.1.7601.17609

这是 MIME 格式的多方邮件。

------=_NextPart_000_0000_01D14A12.98FB2E40
Content-Type: text/html;
	charset="utf-8"
Content-Transfer-Encoding: quoted-printable
Content-Location: =?utf-8?B?ZmlsZTovL0Y6XG15cHJvZ3JhbVzmiJHnmoTnu4PkuaDku6PnoIFc56Kw?=
	=?utf-8?B?5pKe5bm/5ZGKKOacquWujOaIkCkuaHRtbA==?=

=EF=BB=BF<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!DOCTYPE html><HTML lang=3D"en"><HEAD>
<META =
charset=3D"UTF-8"><TITLE>=E6=8B=96=E5=8A=A8div=E7=9A=84=E7=89=B9=E6=95=88=
1</TITLE>
<SCRIPT =
src=3D"file:///F:/myprogram/=E6=88=91=E7=9A=84=E7=BB=83=E4=B9=A0=E4=BB=A3=
=E7=A0=81/jquery-1.11.3.js"></SCRIPT>

<SCRIPT =
src=3D"file:///F:/myprogram/=E6=88=91=E7=9A=84=E7=BB=83=E4=B9=A0=E4=BB=A3=
=E7=A0=81/jquery-ui.js"></SCRIPT>

<STYLE>=0A=
	*{=0A=
		margin:0;=0A=
		padding:0;=0A=
		list-style:none;=0A=
	}=0A=
	.ads{=0A=
		width:100px;=0A=
		height:100px;=0A=
		line-height:100px;=0A=
		text-align:center;=0A=
		background=0A=
	}=0A=
</STYLE>

<META name=3D"GENERATOR" content=3D"MSHTML 9.00.8112.16563"></HEAD>
<BODY>
<DIV class=3D"ads">=E6=88=91=E5=B0=B1=E6=98=AF=E5=B9=BF=E5=91=8A</DIV>
<SCRIPT></SCRIPT>
</BODY></HTML>

------=_NextPart_000_0000_01D14A12.98FB2E40
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: =?gb2312?B?ZmlsZTovLy9GOi9teXByb2dyYW0vztK1xMG3z7C0+sLrL2pxdWVyeQ==?=
	=?gb2312?B?LTEuMTEuMy5qcw==?=

/*!=0A=
 * jQuery JavaScript Library v1.11.3=0A=
 * http://jquery.com/=0A=
 *=0A=
 * Includes Sizzle.js=0A=
 * http://sizzlejs.com/=0A=
 *=0A=
 * Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors=0A=
 * Released under the MIT license=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * Date: 2015-04-28T16:19Z=0A=
 */=0A=
=0A=
(function( global, factory ) {=0A=
=0A=
	if ( typeof module =3D=3D=3D "object" && typeof module.exports =
=3D=3D=3D "object" ) {=0A=
		// For CommonJS and CommonJS-like environments where a proper window =
is present,=0A=
		// execute the factory and get jQuery=0A=
		// For environments that do not inherently posses a window with a =
document=0A=
		// (such as Node.js), expose a jQuery-making factory as module.exports=0A=
		// This accentuates the need for the creation of a real window=0A=
		// e.g. var jQuery =3D require("jquery")(window);=0A=
		// See ticket #14549 for more info=0A=
		module.exports =3D global.document ?=0A=
			factory( global, true ) :=0A=
			function( w ) {=0A=
				if ( !w.document ) {=0A=
					throw new Error( "jQuery requires a window with a document" );=0A=
				}=0A=
				return factory( w );=0A=
			};=0A=
	} else {=0A=
		factory( global );=0A=
	}=0A=
=0A=
// Pass this if window is not defined yet=0A=
}(typeof window !=3D=3D "undefined" ? window : this, function( window, =
noGlobal ) {=0A=
=0A=
// Can't do this because several apps including ASP.NET trace=0A=
// the stack via arguments.caller.callee and Firefox dies if=0A=
// you try to trace through "use strict" call chains. (#13335)=0A=
// Support: Firefox 18+=0A=
//=0A=
=0A=
var deletedIds =3D [];=0A=
=0A=
var slice =3D deletedIds.slice;=0A=
=0A=
var concat =3D deletedIds.concat;=0A=
=0A=
var push =3D deletedIds.push;=0A=
=0A=
var indexOf =3D deletedIds.indexOf;=0A=
=0A=
var class2type =3D {};=0A=
=0A=
var toString =3D class2type.toString;=0A=
=0A=
var hasOwn =3D class2type.hasOwnProperty;=0A=
=0A=
var support =3D {};=0A=
=0A=
=0A=
=0A=
var=0A=
	version =3D "1.11.3",=0A=
=0A=
	// Define a local copy of jQuery=0A=
	jQuery =3D function( selector, context ) {=0A=
		// The jQuery object is actually just the init constructor 'enhanced'=0A=
		// Need init if jQuery is called (just allow error to be thrown if not =
included)=0A=
		return new jQuery.fn.init( selector, context );=0A=
	},=0A=
=0A=
	// Support: Android<4.1, IE<9=0A=
	// Make sure we trim BOM and NBSP=0A=
	rtrim =3D /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,=0A=
=0A=
	// Matches dashed string for camelizing=0A=
	rmsPrefix =3D /^-ms-/,=0A=
	rdashAlpha =3D /-([\da-z])/gi,=0A=
=0A=
	// Used by jQuery.camelCase as callback to replace()=0A=
	fcamelCase =3D function( all, letter ) {=0A=
		return letter.toUpperCase();=0A=
	};=0A=
=0A=
jQuery.fn =3D jQuery.prototype =3D {=0A=
	// The current version of jQuery being used=0A=
	jquery: version,=0A=
=0A=
	constructor: jQuery,=0A=
=0A=
	// Start with an empty selector=0A=
	selector: "",=0A=
=0A=
	// The default length of a jQuery object is 0=0A=
	length: 0,=0A=
=0A=
	toArray: function() {=0A=
		return slice.call( this );=0A=
	},=0A=
=0A=
	// Get the Nth element in the matched element set OR=0A=
	// Get the whole matched element set as a clean array=0A=
	get: function( num ) {=0A=
		return num !=3D null ?=0A=
=0A=
			// Return just the one element from the set=0A=
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :=0A=
=0A=
			// Return all the elements in a clean array=0A=
			slice.call( this );=0A=
	},=0A=
=0A=
	// Take an array of elements and push it onto the stack=0A=
	// (returning the new matched element set)=0A=
	pushStack: function( elems ) {=0A=
=0A=
		// Build a new jQuery matched element set=0A=
		var ret =3D jQuery.merge( this.constructor(), elems );=0A=
=0A=
		// Add the old object onto the stack (as a reference)=0A=
		ret.prevObject =3D this;=0A=
		ret.context =3D this.context;=0A=
=0A=
		// Return the newly-formed element set=0A=
		return ret;=0A=
	},=0A=
=0A=
	// Execute a callback for every element in the matched set.=0A=
	// (You can seed the arguments with an array of args, but this is=0A=
	// only used internally.)=0A=
	each: function( callback, args ) {=0A=
		return jQuery.each( this, callback, args );=0A=
	},=0A=
=0A=
	map: function( callback ) {=0A=
		return this.pushStack( jQuery.map(this, function( elem, i ) {=0A=
			return callback.call( elem, i, elem );=0A=
		}));=0A=
	},=0A=
=0A=
	slice: function() {=0A=
		return this.pushStack( slice.apply( this, arguments ) );=0A=
	},=0A=
=0A=
	first: function() {=0A=
		return this.eq( 0 );=0A=
	},=0A=
=0A=
	last: function() {=0A=
		return this.eq( -1 );=0A=
	},=0A=
=0A=
	eq: function( i ) {=0A=
		var len =3D this.length,=0A=
			j =3D +i + ( i < 0 ? len : 0 );=0A=
		return this.pushStack( j >=3D 0 && j < len ? [ this[j] ] : [] );=0A=
	},=0A=
=0A=
	end: function() {=0A=
		return this.prevObject || this.constructor(null);=0A=
	},=0A=
=0A=
	// For internal use only.=0A=
	// Behaves like an Array's method, not like a jQuery method.=0A=
	push: push,=0A=
	sort: deletedIds.sort,=0A=
	splice: deletedIds.splice=0A=
};=0A=
=0A=
jQuery.extend =3D jQuery.fn.extend =3D function() {=0A=
	var src, copyIsArray, copy, name, options, clone,=0A=
		target =3D arguments[0] || {},=0A=
		i =3D 1,=0A=
		length =3D arguments.length,=0A=
		deep =3D false;=0A=
=0A=
	// Handle a deep copy situation=0A=
	if ( typeof target =3D=3D=3D "boolean" ) {=0A=
		deep =3D target;=0A=
=0A=
		// skip the boolean and the target=0A=
		target =3D arguments[ i ] || {};=0A=
		i++;=0A=
	}=0A=
=0A=
	// Handle case when target is a string or something (possible in deep =
copy)=0A=
	if ( typeof target !=3D=3D "object" && !jQuery.isFunction(target) ) {=0A=
		target =3D {};=0A=
	}=0A=
=0A=
	// extend jQuery itself if only one argument is passed=0A=
	if ( i =3D=3D=3D length ) {=0A=
		target =3D this;=0A=
		i--;=0A=
	}=0A=
=0A=
	for ( ; i < length; i++ ) {=0A=
		// Only deal with non-null/undefined values=0A=
		if ( (options =3D arguments[ i ]) !=3D null ) {=0A=
			// Extend the base object=0A=
			for ( name in options ) {=0A=
				src =3D target[ name ];=0A=
				copy =3D options[ name ];=0A=
=0A=
				// Prevent never-ending loop=0A=
				if ( target =3D=3D=3D copy ) {=0A=
					continue;=0A=
				}=0A=
=0A=
				// Recurse if we're merging plain objects or arrays=0A=
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray =
=3D jQuery.isArray(copy)) ) ) {=0A=
					if ( copyIsArray ) {=0A=
						copyIsArray =3D false;=0A=
						clone =3D src && jQuery.isArray(src) ? src : [];=0A=
=0A=
					} else {=0A=
						clone =3D src && jQuery.isPlainObject(src) ? src : {};=0A=
					}=0A=
=0A=
					// Never move original objects, clone them=0A=
					target[ name ] =3D jQuery.extend( deep, clone, copy );=0A=
=0A=
				// Don't bring in undefined values=0A=
				} else if ( copy !=3D=3D undefined ) {=0A=
					target[ name ] =3D copy;=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	// Return the modified object=0A=
	return target;=0A=
};=0A=
=0A=
jQuery.extend({=0A=
	// Unique for each copy of jQuery on the page=0A=
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),=0A=
=0A=
	// Assume jQuery is ready without the ready module=0A=
	isReady: true,=0A=
=0A=
	error: function( msg ) {=0A=
		throw new Error( msg );=0A=
	},=0A=
=0A=
	noop: function() {},=0A=
=0A=
	// See test/unit/core.js for details concerning isFunction.=0A=
	// Since version 1.3, DOM methods and functions like alert=0A=
	// aren't supported. They return false on IE (#2968).=0A=
	isFunction: function( obj ) {=0A=
		return jQuery.type(obj) =3D=3D=3D "function";=0A=
	},=0A=
=0A=
	isArray: Array.isArray || function( obj ) {=0A=
		return jQuery.type(obj) =3D=3D=3D "array";=0A=
	},=0A=
=0A=
	isWindow: function( obj ) {=0A=
		/* jshint eqeqeq: false */=0A=
		return obj !=3D null && obj =3D=3D obj.window;=0A=
	},=0A=
=0A=
	isNumeric: function( obj ) {=0A=
		// parseFloat NaNs numeric-cast false positives (null|true|false|"")=0A=
		// ...but misinterprets leading-number strings, particularly hex =
literals ("0x...")=0A=
		// subtraction forces infinities to NaN=0A=
		// adding 1 corrects loss of precision from parseFloat (#15100)=0A=
		return !jQuery.isArray( obj ) && (obj - parseFloat( obj ) + 1) >=3D 0;=0A=
	},=0A=
=0A=
	isEmptyObject: function( obj ) {=0A=
		var name;=0A=
		for ( name in obj ) {=0A=
			return false;=0A=
		}=0A=
		return true;=0A=
	},=0A=
=0A=
	isPlainObject: function( obj ) {=0A=
		var key;=0A=
=0A=
		// Must be an Object.=0A=
		// Because of IE, we also have to check the presence of the =
constructor property.=0A=
		// Make sure that DOM nodes and window objects don't pass through, as =
well=0A=
		if ( !obj || jQuery.type(obj) !=3D=3D "object" || obj.nodeType || =
jQuery.isWindow( obj ) ) {=0A=
			return false;=0A=
		}=0A=
=0A=
		try {=0A=
			// Not own constructor property must be Object=0A=
			if ( obj.constructor &&=0A=
				!hasOwn.call(obj, "constructor") &&=0A=
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {=0A=
				return false;=0A=
			}=0A=
		} catch ( e ) {=0A=
			// IE8,9 Will throw exceptions on certain host objects #9897=0A=
			return false;=0A=
		}=0A=
=0A=
		// Support: IE<9=0A=
		// Handle iteration over inherited properties before own properties.=0A=
		if ( support.ownLast ) {=0A=
			for ( key in obj ) {=0A=
				return hasOwn.call( obj, key );=0A=
			}=0A=
		}=0A=
=0A=
		// Own properties are enumerated firstly, so to speed up,=0A=
		// if last one is own, then all properties are own.=0A=
		for ( key in obj ) {}=0A=
=0A=
		return key =3D=3D=3D undefined || hasOwn.call( obj, key );=0A=
	},=0A=
=0A=
	type: function( obj ) {=0A=
		if ( obj =3D=3D null ) {=0A=
			return obj + "";=0A=
		}=0A=
		return typeof obj =3D=3D=3D "object" || typeof obj =3D=3D=3D =
"function" ?=0A=
			class2type[ toString.call(obj) ] || "object" :=0A=
			typeof obj;=0A=
	},=0A=
=0A=
	// Evaluates a script in a global context=0A=
	// Workarounds based on findings by Jim Driscoll=0A=
	// =
http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-=
global-context=0A=
	globalEval: function( data ) {=0A=
		if ( data && jQuery.trim( data ) ) {=0A=
			// We use execScript on Internet Explorer=0A=
			// We use an anonymous function so that context is window=0A=
			// rather than jQuery in Firefox=0A=
			( window.execScript || function( data ) {=0A=
				window[ "eval" ].call( window, data );=0A=
			} )( data );=0A=
		}=0A=
	},=0A=
=0A=
	// Convert dashed to camelCase; used by the css and data modules=0A=
	// Microsoft forgot to hump their vendor prefix (#9572)=0A=
	camelCase: function( string ) {=0A=
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, =
fcamelCase );=0A=
	},=0A=
=0A=
	nodeName: function( elem, name ) {=0A=
		return elem.nodeName && elem.nodeName.toLowerCase() =3D=3D=3D =
name.toLowerCase();=0A=
	},=0A=
=0A=
	// args is for internal usage only=0A=
	each: function( obj, callback, args ) {=0A=
		var value,=0A=
			i =3D 0,=0A=
			length =3D obj.length,=0A=
			isArray =3D isArraylike( obj );=0A=
=0A=
		if ( args ) {=0A=
			if ( isArray ) {=0A=
				for ( ; i < length; i++ ) {=0A=
					value =3D callback.apply( obj[ i ], args );=0A=
=0A=
					if ( value =3D=3D=3D false ) {=0A=
						break;=0A=
					}=0A=
				}=0A=
			} else {=0A=
				for ( i in obj ) {=0A=
					value =3D callback.apply( obj[ i ], args );=0A=
=0A=
					if ( value =3D=3D=3D false ) {=0A=
						break;=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
		// A special, fast, case for the most common use of each=0A=
		} else {=0A=
			if ( isArray ) {=0A=
				for ( ; i < length; i++ ) {=0A=
					value =3D callback.call( obj[ i ], i, obj[ i ] );=0A=
=0A=
					if ( value =3D=3D=3D false ) {=0A=
						break;=0A=
					}=0A=
				}=0A=
			} else {=0A=
				for ( i in obj ) {=0A=
					value =3D callback.call( obj[ i ], i, obj[ i ] );=0A=
=0A=
					if ( value =3D=3D=3D false ) {=0A=
						break;=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return obj;=0A=
	},=0A=
=0A=
	// Support: Android<4.1, IE<9=0A=
	trim: function( text ) {=0A=
		return text =3D=3D null ?=0A=
			"" :=0A=
			( text + "" ).replace( rtrim, "" );=0A=
	},=0A=
=0A=
	// results is for internal usage only=0A=
	makeArray: function( arr, results ) {=0A=
		var ret =3D results || [];=0A=
=0A=
		if ( arr !=3D null ) {=0A=
			if ( isArraylike( Object(arr) ) ) {=0A=
				jQuery.merge( ret,=0A=
					typeof arr =3D=3D=3D "string" ?=0A=
					[ arr ] : arr=0A=
				);=0A=
			} else {=0A=
				push.call( ret, arr );=0A=
			}=0A=
		}=0A=
=0A=
		return ret;=0A=
	},=0A=
=0A=
	inArray: function( elem, arr, i ) {=0A=
		var len;=0A=
=0A=
		if ( arr ) {=0A=
			if ( indexOf ) {=0A=
				return indexOf.call( arr, elem, i );=0A=
			}=0A=
=0A=
			len =3D arr.length;=0A=
			i =3D i ? i < 0 ? Math.max( 0, len + i ) : i : 0;=0A=
=0A=
			for ( ; i < len; i++ ) {=0A=
				// Skip accessing in sparse arrays=0A=
				if ( i in arr && arr[ i ] =3D=3D=3D elem ) {=0A=
					return i;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return -1;=0A=
	},=0A=
=0A=
	merge: function( first, second ) {=0A=
		var len =3D +second.length,=0A=
			j =3D 0,=0A=
			i =3D first.length;=0A=
=0A=
		while ( j < len ) {=0A=
			first[ i++ ] =3D second[ j++ ];=0A=
		}=0A=
=0A=
		// Support: IE<9=0A=
		// Workaround casting of .length to NaN on otherwise arraylike objects =
(e.g., NodeLists)=0A=
		if ( len !=3D=3D len ) {=0A=
			while ( second[j] !=3D=3D undefined ) {=0A=
				first[ i++ ] =3D second[ j++ ];=0A=
			}=0A=
		}=0A=
=0A=
		first.length =3D i;=0A=
=0A=
		return first;=0A=
	},=0A=
=0A=
	grep: function( elems, callback, invert ) {=0A=
		var callbackInverse,=0A=
			matches =3D [],=0A=
			i =3D 0,=0A=
			length =3D elems.length,=0A=
			callbackExpect =3D !invert;=0A=
=0A=
		// Go through the array, only saving the items=0A=
		// that pass the validator function=0A=
		for ( ; i < length; i++ ) {=0A=
			callbackInverse =3D !callback( elems[ i ], i );=0A=
			if ( callbackInverse !=3D=3D callbackExpect ) {=0A=
				matches.push( elems[ i ] );=0A=
			}=0A=
		}=0A=
=0A=
		return matches;=0A=
	},=0A=
=0A=
	// arg is for internal usage only=0A=
	map: function( elems, callback, arg ) {=0A=
		var value,=0A=
			i =3D 0,=0A=
			length =3D elems.length,=0A=
			isArray =3D isArraylike( elems ),=0A=
			ret =3D [];=0A=
=0A=
		// Go through the array, translating each of the items to their new =
values=0A=
		if ( isArray ) {=0A=
			for ( ; i < length; i++ ) {=0A=
				value =3D callback( elems[ i ], i, arg );=0A=
=0A=
				if ( value !=3D null ) {=0A=
					ret.push( value );=0A=
				}=0A=
			}=0A=
=0A=
		// Go through every key on the object,=0A=
		} else {=0A=
			for ( i in elems ) {=0A=
				value =3D callback( elems[ i ], i, arg );=0A=
=0A=
				if ( value !=3D null ) {=0A=
					ret.push( value );=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// Flatten any nested arrays=0A=
		return concat.apply( [], ret );=0A=
	},=0A=
=0A=
	// A global GUID counter for objects=0A=
	guid: 1,=0A=
=0A=
	// Bind a function to a context, optionally partially applying any=0A=
	// arguments.=0A=
	proxy: function( fn, context ) {=0A=
		var args, proxy, tmp;=0A=
=0A=
		if ( typeof context =3D=3D=3D "string" ) {=0A=
			tmp =3D fn[ context ];=0A=
			context =3D fn;=0A=
			fn =3D tmp;=0A=
		}=0A=
=0A=
		// Quick check to determine if target is callable, in the spec=0A=
		// this throws a TypeError, but we will just return undefined.=0A=
		if ( !jQuery.isFunction( fn ) ) {=0A=
			return undefined;=0A=
		}=0A=
=0A=
		// Simulated bind=0A=
		args =3D slice.call( arguments, 2 );=0A=
		proxy =3D function() {=0A=
			return fn.apply( context || this, args.concat( slice.call( arguments =
) ) );=0A=
		};=0A=
=0A=
		// Set the guid of unique handler to the same of original handler, so =
it can be removed=0A=
		proxy.guid =3D fn.guid =3D fn.guid || jQuery.guid++;=0A=
=0A=
		return proxy;=0A=
	},=0A=
=0A=
	now: function() {=0A=
		return +( new Date() );=0A=
	},=0A=
=0A=
	// jQuery.support is not used in Core but other projects attach their=0A=
	// properties to it so it needs to exist.=0A=
	support: support=0A=
});=0A=
=0A=
// Populate the class2type map=0A=
jQuery.each("Boolean Number String Function Array Date RegExp Object =
Error".split(" "), function(i, name) {=0A=
	class2type[ "[object " + name + "]" ] =3D name.toLowerCase();=0A=
});=0A=
=0A=
function isArraylike( obj ) {=0A=
=0A=
	// Support: iOS 8.2 (not reproducible in simulator)=0A=
	// `in` check used to prevent JIT error (gh-2145)=0A=
	// hasOwn isn't used here due to false negatives=0A=
	// regarding Nodelist length in IE=0A=
	var length =3D "length" in obj && obj.length,=0A=
		type =3D jQuery.type( obj );=0A=
=0A=
	if ( type =3D=3D=3D "function" || jQuery.isWindow( obj ) ) {=0A=
		return false;=0A=
	}=0A=
=0A=
	if ( obj.nodeType =3D=3D=3D 1 && length ) {=0A=
		return true;=0A=
	}=0A=
=0A=
	return type =3D=3D=3D "array" || length =3D=3D=3D 0 ||=0A=
		typeof length =3D=3D=3D "number" && length > 0 && ( length - 1 ) in =
obj;=0A=
}=0A=
var Sizzle =3D=0A=
/*!=0A=
 * Sizzle CSS Selector Engine v2.2.0-pre=0A=
 * http://sizzlejs.com/=0A=
 *=0A=
 * Copyright 2008, 2014 jQuery Foundation, Inc. and other contributors=0A=
 * Released under the MIT license=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * Date: 2014-12-16=0A=
 */=0A=
(function( window ) {=0A=
=0A=
var i,=0A=
	support,=0A=
	Expr,=0A=
	getText,=0A=
	isXML,=0A=
	tokenize,=0A=
	compile,=0A=
	select,=0A=
	outermostContext,=0A=
	sortInput,=0A=
	hasDuplicate,=0A=
=0A=
	// Local document vars=0A=
	setDocument,=0A=
	document,=0A=
	docElem,=0A=
	documentIsHTML,=0A=
	rbuggyQSA,=0A=
	rbuggyMatches,=0A=
	matches,=0A=
	contains,=0A=
=0A=
	// Instance-specific data=0A=
	expando =3D "sizzle" + 1 * new Date(),=0A=
	preferredDoc =3D window.document,=0A=
	dirruns =3D 0,=0A=
	done =3D 0,=0A=
	classCache =3D createCache(),=0A=
	tokenCache =3D createCache(),=0A=
	compilerCache =3D createCache(),=0A=
	sortOrder =3D function( a, b ) {=0A=
		if ( a =3D=3D=3D b ) {=0A=
			hasDuplicate =3D true;=0A=
		}=0A=
		return 0;=0A=
	},=0A=
=0A=
	// General-purpose constants=0A=
	MAX_NEGATIVE =3D 1 << 31,=0A=
=0A=
	// Instance methods=0A=
	hasOwn =3D ({}).hasOwnProperty,=0A=
	arr =3D [],=0A=
	pop =3D arr.pop,=0A=
	push_native =3D arr.push,=0A=
	push =3D arr.push,=0A=
	slice =3D arr.slice,=0A=
	// Use a stripped-down indexOf as it's faster than native=0A=
	// http://jsperf.com/thor-indexof-vs-for/5=0A=
	indexOf =3D function( list, elem ) {=0A=
		var i =3D 0,=0A=
			len =3D list.length;=0A=
		for ( ; i < len; i++ ) {=0A=
			if ( list[i] =3D=3D=3D elem ) {=0A=
				return i;=0A=
			}=0A=
		}=0A=
		return -1;=0A=
	},=0A=
=0A=
	booleans =3D =
"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden=
|ismap|loop|multiple|open|readonly|required|scoped",=0A=
=0A=
	// Regular expressions=0A=
=0A=
	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace=0A=
	whitespace =3D "[\\x20\\t\\r\\n\\f]",=0A=
	// http://www.w3.org/TR/css3-syntax/#characters=0A=
	characterEncoding =3D "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",=0A=
=0A=
	// Loosely modeled on CSS identifier characters=0A=
	// An unquoted value should be a CSS identifier =
http://www.w3.org/TR/css3-selectors/#attribute-selectors=0A=
	// Proper syntax: =
http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier=0A=
	identifier =3D characterEncoding.replace( "w", "w#" ),=0A=
=0A=
	// Attribute selectors: =
http://www.w3.org/TR/selectors/#attribute-selectors=0A=
	attributes =3D "\\[" + whitespace + "*(" + characterEncoding + ")(?:" + =
whitespace +=0A=
		// Operator (capture 2)=0A=
		"*([*^$|!~]?=3D)" + whitespace +=0A=
		// "Attribute values must be CSS identifiers [capture 5] or strings =
[capture 3 or capture 4]"=0A=
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + =
identifier + "))|)" + whitespace +=0A=
		"*\\]",=0A=
=0A=
	pseudos =3D ":(" + characterEncoding + ")(?:\\((" +=0A=
		// To reduce the number of selectors needing tokenize in the =
preFilter, prefer arguments:=0A=
		// 1. quoted (capture 3; capture 4 or capture 5)=0A=
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +=0A=
		// 2. simple (capture 6)=0A=
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +=0A=
		// 3. anything else (capture 2)=0A=
		".*" +=0A=
		")\\)|)",=0A=
=0A=
	// Leading and non-escaped trailing whitespace, capturing some =
non-whitespace characters preceding the latter=0A=
	rwhitespace =3D new RegExp( whitespace + "+", "g" ),=0A=
	rtrim =3D new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" =
+ whitespace + "+$", "g" ),=0A=
=0A=
	rcomma =3D new RegExp( "^" + whitespace + "*," + whitespace + "*" ),=0A=
	rcombinators =3D new RegExp( "^" + whitespace + "*([>+~]|" + whitespace =
+ ")" + whitespace + "*" ),=0A=
=0A=
	rattributeQuotes =3D new RegExp( "=3D" + whitespace + "*([^\\]'\"]*?)" =
+ whitespace + "*\\]", "g" ),=0A=
=0A=
	rpseudo =3D new RegExp( pseudos ),=0A=
	ridentifier =3D new RegExp( "^" + identifier + "$" ),=0A=
=0A=
	matchExpr =3D {=0A=
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),=0A=
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),=0A=
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" =
),=0A=
		"ATTR": new RegExp( "^" + attributes ),=0A=
		"PSEUDO": new RegExp( "^" + pseudos ),=0A=
		"CHILD": new RegExp( =
"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +=0A=
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + =
whitespace +=0A=
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),=0A=
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),=0A=
		// For use in libraries implementing .is()=0A=
		// We use this for POS matching in `select`=0A=
		"needsContext": new RegExp( "^" + whitespace + =
"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +=0A=
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=3D[^-]|$)", =
"i" )=0A=
	},=0A=
=0A=
	rinputs =3D /^(?:input|select|textarea|button)$/i,=0A=
	rheader =3D /^h\d$/i,=0A=
=0A=
	rnative =3D /^[^{]+\{\s*\[native \w/,=0A=
=0A=
	// Easily-parseable/retrievable ID or TAG or CLASS selectors=0A=
	rquickExpr =3D /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,=0A=
=0A=
	rsibling =3D /[+~]/,=0A=
	rescape =3D /'|\\/g,=0A=
=0A=
	// CSS escapes =
http://www.w3.org/TR/CSS21/syndata.html#escaped-characters=0A=
	runescape =3D new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + =
whitespace + ")|.)", "ig" ),=0A=
	funescape =3D function( _, escaped, escapedWhitespace ) {=0A=
		var high =3D "0x" + escaped - 0x10000;=0A=
		// NaN means non-codepoint=0A=
		// Support: Firefox<24=0A=
		// Workaround erroneous numeric interpretation of +"0x"=0A=
		return high !=3D=3D high || escapedWhitespace ?=0A=
			escaped :=0A=
			high < 0 ?=0A=
				// BMP codepoint=0A=
				String.fromCharCode( high + 0x10000 ) :=0A=
				// Supplemental Plane codepoint (surrogate pair)=0A=
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );=0A=
	},=0A=
=0A=
	// Used for iframes=0A=
	// See setDocument()=0A=
	// Removing the function wrapper causes a "Permission Denied"=0A=
	// error in IE=0A=
	unloadHandler =3D function() {=0A=
		setDocument();=0A=
	};=0A=
=0A=
// Optimize for push.apply( _, NodeList )=0A=
try {=0A=
	push.apply(=0A=
		(arr =3D slice.call( preferredDoc.childNodes )),=0A=
		preferredDoc.childNodes=0A=
	);=0A=
	// Support: Android<4.0=0A=
	// Detect silently failing push.apply=0A=
	arr[ preferredDoc.childNodes.length ].nodeType;=0A=
} catch ( e ) {=0A=
	push =3D { apply: arr.length ?=0A=
=0A=
		// Leverage slice if possible=0A=
		function( target, els ) {=0A=
			push_native.apply( target, slice.call(els) );=0A=
		} :=0A=
=0A=
		// Support: IE<9=0A=
		// Otherwise append directly=0A=
		function( target, els ) {=0A=
			var j =3D target.length,=0A=
				i =3D 0;=0A=
			// Can't trust NodeList.length=0A=
			while ( (target[j++] =3D els[i++]) ) {}=0A=
			target.length =3D j - 1;=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
function Sizzle( selector, context, results, seed ) {=0A=
	var match, elem, m, nodeType,=0A=
		// QSA vars=0A=
		i, groups, old, nid, newContext, newSelector;=0A=
=0A=
	if ( ( context ? context.ownerDocument || context : preferredDoc ) =
!=3D=3D document ) {=0A=
		setDocument( context );=0A=
	}=0A=
=0A=
	context =3D context || document;=0A=
	results =3D results || [];=0A=
	nodeType =3D context.nodeType;=0A=
=0A=
	if ( typeof selector !=3D=3D "string" || !selector ||=0A=
		nodeType !=3D=3D 1 && nodeType !=3D=3D 9 && nodeType !=3D=3D 11 ) {=0A=
=0A=
		return results;=0A=
	}=0A=
=0A=
	if ( !seed && documentIsHTML ) {=0A=
=0A=
		// Try to shortcut find operations when possible (e.g., not under =
DocumentFragment)=0A=
		if ( nodeType !=3D=3D 11 && (match =3D rquickExpr.exec( selector )) ) {=0A=
			// Speed-up: Sizzle("#ID")=0A=
			if ( (m =3D match[1]) ) {=0A=
				if ( nodeType =3D=3D=3D 9 ) {=0A=
					elem =3D context.getElementById( m );=0A=
					// Check parentNode to catch when Blackberry 4.6 returns=0A=
					// nodes that are no longer in the document (jQuery #6963)=0A=
					if ( elem && elem.parentNode ) {=0A=
						// Handle the case where IE, Opera, and Webkit return items=0A=
						// by name instead of ID=0A=
						if ( elem.id =3D=3D=3D m ) {=0A=
							results.push( elem );=0A=
							return results;=0A=
						}=0A=
					} else {=0A=
						return results;=0A=
					}=0A=
				} else {=0A=
					// Context is not a document=0A=
					if ( context.ownerDocument && (elem =3D =
context.ownerDocument.getElementById( m )) &&=0A=
						contains( context, elem ) && elem.id =3D=3D=3D m ) {=0A=
						results.push( elem );=0A=
						return results;=0A=
					}=0A=
				}=0A=
=0A=
			// Speed-up: Sizzle("TAG")=0A=
			} else if ( match[2] ) {=0A=
				push.apply( results, context.getElementsByTagName( selector ) );=0A=
				return results;=0A=
=0A=
			// Speed-up: Sizzle(".CLASS")=0A=
			} else if ( (m =3D match[3]) && support.getElementsByClassName ) {=0A=
				push.apply( results, context.getElementsByClassName( m ) );=0A=
				return results;=0A=
			}=0A=
		}=0A=
=0A=
		// QSA path=0A=
		if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {=0A=
			nid =3D old =3D expando;=0A=
			newContext =3D context;=0A=
			newSelector =3D nodeType !=3D=3D 1 && selector;=0A=
=0A=
			// qSA works strangely on Element-rooted queries=0A=
			// We can work around this by specifying an extra ID on the root=0A=
			// and working up from there (Thanks to Andrew Dupont for the =
technique)=0A=
			// IE 8 doesn't work on object elements=0A=
			if ( nodeType =3D=3D=3D 1 && context.nodeName.toLowerCase() !=3D=3D =
"object" ) {=0A=
				groups =3D tokenize( selector );=0A=
=0A=
				if ( (old =3D context.getAttribute("id")) ) {=0A=
					nid =3D old.replace( rescape, "\\$&" );=0A=
				} else {=0A=
					context.setAttribute( "id", nid );=0A=
				}=0A=
				nid =3D "[id=3D'" + nid + "'] ";=0A=
=0A=
				i =3D groups.length;=0A=
				while ( i-- ) {=0A=
					groups[i] =3D nid + toSelector( groups[i] );=0A=
				}=0A=
				newContext =3D rsibling.test( selector ) && testContext( =
context.parentNode ) || context;=0A=
				newSelector =3D groups.join(",");=0A=
			}=0A=
=0A=
			if ( newSelector ) {=0A=
				try {=0A=
					push.apply( results,=0A=
						newContext.querySelectorAll( newSelector )=0A=
					);=0A=
					return results;=0A=
				} catch(qsaError) {=0A=
				} finally {=0A=
					if ( !old ) {=0A=
						context.removeAttribute("id");=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	// All others=0A=
	return select( selector.replace( rtrim, "$1" ), context, results, seed =
);=0A=
}=0A=
=0A=
/**=0A=
 * Create key-value caches of limited size=0A=
 * @returns {Function(string, Object)} Returns the Object data after =
storing it on itself with=0A=
 *	property name the (space-suffixed) string and (if the cache is larger =
than Expr.cacheLength)=0A=
 *	deleting the oldest entry=0A=
 */=0A=
function createCache() {=0A=
	var keys =3D [];=0A=
=0A=
	function cache( key, value ) {=0A=
		// Use (key + " ") to avoid collision with native prototype properties =
(see Issue #157)=0A=
		if ( keys.push( key + " " ) > Expr.cacheLength ) {=0A=
			// Only keep the most recent entries=0A=
			delete cache[ keys.shift() ];=0A=
		}=0A=
		return (cache[ key + " " ] =3D value);=0A=
	}=0A=
	return cache;=0A=
}=0A=
=0A=
/**=0A=
 * Mark a function for special use by Sizzle=0A=
 * @param {Function} fn The function to mark=0A=
 */=0A=
function markFunction( fn ) {=0A=
	fn[ expando ] =3D true;=0A=
	return fn;=0A=
}=0A=
=0A=
/**=0A=
 * Support testing using an element=0A=
 * @param {Function} fn Passed the created div and expects a boolean =
result=0A=
 */=0A=
function assert( fn ) {=0A=
	var div =3D document.createElement("div");=0A=
=0A=
	try {=0A=
		return !!fn( div );=0A=
	} catch (e) {=0A=
		return false;=0A=
	} finally {=0A=
		// Remove from its parent by default=0A=
		if ( div.parentNode ) {=0A=
			div.parentNode.removeChild( div );=0A=
		}=0A=
		// release memory in IE=0A=
		div =3D null;=0A=
	}=0A=
}=0A=
=0A=
/**=0A=
 * Adds the same handler for all of the specified attrs=0A=
 * @param {String} attrs Pipe-separated list of attributes=0A=
 * @param {Function} handler The method that will be applied=0A=
 */=0A=
function addHandle( attrs, handler ) {=0A=
	var arr =3D attrs.split("|"),=0A=
		i =3D attrs.length;=0A=
=0A=
	while ( i-- ) {=0A=
		Expr.attrHandle[ arr[i] ] =3D handler;=0A=
	}=0A=
}=0A=
=0A=
/**=0A=
 * Checks document order of two siblings=0A=
 * @param {Element} a=0A=
 * @param {Element} b=0A=
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 =
if a follows b=0A=
 */=0A=
function siblingCheck( a, b ) {=0A=
	var cur =3D b && a,=0A=
		diff =3D cur && a.nodeType =3D=3D=3D 1 && b.nodeType =3D=3D=3D 1 &&=0A=
			( ~b.sourceIndex || MAX_NEGATIVE ) -=0A=
			( ~a.sourceIndex || MAX_NEGATIVE );=0A=
=0A=
	// Use IE sourceIndex if available on both nodes=0A=
	if ( diff ) {=0A=
		return diff;=0A=
	}=0A=
=0A=
	// Check if b follows a=0A=
	if ( cur ) {=0A=
		while ( (cur =3D cur.nextSibling) ) {=0A=
			if ( cur =3D=3D=3D b ) {=0A=
				return -1;=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	return a ? 1 : -1;=0A=
}=0A=
=0A=
/**=0A=
 * Returns a function to use in pseudos for input types=0A=
 * @param {String} type=0A=
 */=0A=
function createInputPseudo( type ) {=0A=
	return function( elem ) {=0A=
		var name =3D elem.nodeName.toLowerCase();=0A=
		return name =3D=3D=3D "input" && elem.type =3D=3D=3D type;=0A=
	};=0A=
}=0A=
=0A=
/**=0A=
 * Returns a function to use in pseudos for buttons=0A=
 * @param {String} type=0A=
 */=0A=
function createButtonPseudo( type ) {=0A=
	return function( elem ) {=0A=
		var name =3D elem.nodeName.toLowerCase();=0A=
		return (name =3D=3D=3D "input" || name =3D=3D=3D "button") && =
elem.type =3D=3D=3D type;=0A=
	};=0A=
}=0A=
=0A=
/**=0A=
 * Returns a function to use in pseudos for positionals=0A=
 * @param {Function} fn=0A=
 */=0A=
function createPositionalPseudo( fn ) {=0A=
	return markFunction(function( argument ) {=0A=
		argument =3D +argument;=0A=
		return markFunction(function( seed, matches ) {=0A=
			var j,=0A=
				matchIndexes =3D fn( [], seed.length, argument ),=0A=
				i =3D matchIndexes.length;=0A=
=0A=
			// Match elements found at the specified indexes=0A=
			while ( i-- ) {=0A=
				if ( seed[ (j =3D matchIndexes[i]) ] ) {=0A=
					seed[j] =3D !(matches[j] =3D seed[j]);=0A=
				}=0A=
			}=0A=
		});=0A=
	});=0A=
}=0A=
=0A=
/**=0A=
 * Checks a node for validity as a Sizzle context=0A=
 * @param {Element|Object=3D} context=0A=
 * @returns {Element|Object|Boolean} The input node if acceptable, =
otherwise a falsy value=0A=
 */=0A=
function testContext( context ) {=0A=
	return context && typeof context.getElementsByTagName !=3D=3D =
"undefined" && context;=0A=
}=0A=
=0A=
// Expose support vars for convenience=0A=
support =3D Sizzle.support =3D {};=0A=
=0A=
/**=0A=
 * Detects XML nodes=0A=
 * @param {Element|Object} elem An element or a document=0A=
 * @returns {Boolean} True iff elem is a non-HTML XML node=0A=
 */=0A=
isXML =3D Sizzle.isXML =3D function( elem ) {=0A=
	// documentElement is verified for cases where it doesn't yet exist=0A=
	// (such as loading iframes in IE - #4833)=0A=
	var documentElement =3D elem && (elem.ownerDocument || =
elem).documentElement;=0A=
	return documentElement ? documentElement.nodeName !=3D=3D "HTML" : =
false;=0A=
};=0A=
=0A=
/**=0A=
 * Sets document-related variables once based on the current document=0A=
 * @param {Element|Object} [doc] An element or document object to use to =
set the document=0A=
 * @returns {Object} Returns the current document=0A=
 */=0A=
setDocument =3D Sizzle.setDocument =3D function( node ) {=0A=
	var hasCompare, parent,=0A=
		doc =3D node ? node.ownerDocument || node : preferredDoc;=0A=
=0A=
	// If no document and documentElement is available, return=0A=
	if ( doc =3D=3D=3D document || doc.nodeType !=3D=3D 9 || =
!doc.documentElement ) {=0A=
		return document;=0A=
	}=0A=
=0A=
	// Set our document=0A=
	document =3D doc;=0A=
	docElem =3D doc.documentElement;=0A=
	parent =3D doc.defaultView;=0A=
=0A=
	// Support: IE>8=0A=
	// If iframe document is assigned to "document" variable and if iframe =
has been reloaded,=0A=
	// IE will throw "permission denied" error when accessing "document" =
variable, see jQuery #13936=0A=
	// IE6-8 do not support the defaultView property so parent will be =
undefined=0A=
	if ( parent && parent !=3D=3D parent.top ) {=0A=
		// IE11 does not have attachEvent, so all must suffer=0A=
		if ( parent.addEventListener ) {=0A=
			parent.addEventListener( "unload", unloadHandler, false );=0A=
		} else if ( parent.attachEvent ) {=0A=
			parent.attachEvent( "onunload", unloadHandler );=0A=
		}=0A=
	}=0A=
=0A=
	/* Support tests=0A=
	---------------------------------------------------------------------- =
*/=0A=
	documentIsHTML =3D !isXML( doc );=0A=
=0A=
	/* Attributes=0A=
	---------------------------------------------------------------------- =
*/=0A=
=0A=
	// Support: IE<8=0A=
	// Verify that getAttribute really returns attributes and not properties=0A=
	// (excepting IE8 booleans)=0A=
	support.attributes =3D assert(function( div ) {=0A=
		div.className =3D "i";=0A=
		return !div.getAttribute("className");=0A=
	});=0A=
=0A=
	/* getElement(s)By*=0A=
	---------------------------------------------------------------------- =
*/=0A=
=0A=
	// Check if getElementsByTagName("*") returns only elements=0A=
	support.getElementsByTagName =3D assert(function( div ) {=0A=
		div.appendChild( doc.createComment("") );=0A=
		return !div.getElementsByTagName("*").length;=0A=
	});=0A=
=0A=
	// Support: IE<9=0A=
	support.getElementsByClassName =3D rnative.test( =
doc.getElementsByClassName );=0A=
=0A=
	// Support: IE<10=0A=
	// Check if getElementById returns elements by name=0A=
	// The broken getElementById methods don't pick up programatically-set =
names,=0A=
	// so use a roundabout getElementsByName test=0A=
	support.getById =3D assert(function( div ) {=0A=
		docElem.appendChild( div ).id =3D expando;=0A=
		return !doc.getElementsByName || !doc.getElementsByName( expando =
).length;=0A=
	});=0A=
=0A=
	// ID find and filter=0A=
	if ( support.getById ) {=0A=
		Expr.find["ID"] =3D function( id, context ) {=0A=
			if ( typeof context.getElementById !=3D=3D "undefined" && =
documentIsHTML ) {=0A=
				var m =3D context.getElementById( id );=0A=
				// Check parentNode to catch when Blackberry 4.6 returns=0A=
				// nodes that are no longer in the document #6963=0A=
				return m && m.parentNode ? [ m ] : [];=0A=
			}=0A=
		};=0A=
		Expr.filter["ID"] =3D function( id ) {=0A=
			var attrId =3D id.replace( runescape, funescape );=0A=
			return function( elem ) {=0A=
				return elem.getAttribute("id") =3D=3D=3D attrId;=0A=
			};=0A=
		};=0A=
	} else {=0A=
		// Support: IE6/7=0A=
		// getElementById is not reliable as a find shortcut=0A=
		delete Expr.find["ID"];=0A=
=0A=
		Expr.filter["ID"] =3D  function( id ) {=0A=
			var attrId =3D id.replace( runescape, funescape );=0A=
			return function( elem ) {=0A=
				var node =3D typeof elem.getAttributeNode !=3D=3D "undefined" && =
elem.getAttributeNode("id");=0A=
				return node && node.value =3D=3D=3D attrId;=0A=
			};=0A=
		};=0A=
	}=0A=
=0A=
	// Tag=0A=
	Expr.find["TAG"] =3D support.getElementsByTagName ?=0A=
		function( tag, context ) {=0A=
			if ( typeof context.getElementsByTagName !=3D=3D "undefined" ) {=0A=
				return context.getElementsByTagName( tag );=0A=
=0A=
			// DocumentFragment nodes don't have gEBTN=0A=
			} else if ( support.qsa ) {=0A=
				return context.querySelectorAll( tag );=0A=
			}=0A=
		} :=0A=
=0A=
		function( tag, context ) {=0A=
			var elem,=0A=
				tmp =3D [],=0A=
				i =3D 0,=0A=
				// By happy coincidence, a (broken) gEBTN appears on =
DocumentFragment nodes too=0A=
				results =3D context.getElementsByTagName( tag );=0A=
=0A=
			// Filter out possible comments=0A=
			if ( tag =3D=3D=3D "*" ) {=0A=
				while ( (elem =3D results[i++]) ) {=0A=
					if ( elem.nodeType =3D=3D=3D 1 ) {=0A=
						tmp.push( elem );=0A=
					}=0A=
				}=0A=
=0A=
				return tmp;=0A=
			}=0A=
			return results;=0A=
		};=0A=
=0A=
	// Class=0A=
	Expr.find["CLASS"] =3D support.getElementsByClassName && function( =
className, context ) {=0A=
		if ( documentIsHTML ) {=0A=
			return context.getElementsByClassName( className );=0A=
		}=0A=
	};=0A=
=0A=
	/* QSA/matchesSelector=0A=
	---------------------------------------------------------------------- =
*/=0A=
=0A=
	// QSA and matchesSelector support=0A=
=0A=
	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)=0A=
	rbuggyMatches =3D [];=0A=
=0A=
	// qSa(:focus) reports false when true (Chrome 21)=0A=
	// We allow this because of a bug in IE8/9 that throws an error=0A=
	// whenever `document.activeElement` is accessed on an iframe=0A=
	// So, we allow :focus to pass through QSA all the time to avoid the IE =
error=0A=
	// See http://bugs.jquery.com/ticket/13378=0A=
	rbuggyQSA =3D [];=0A=
=0A=
	if ( (support.qsa =3D rnative.test( doc.querySelectorAll )) ) {=0A=
		// Build QSA regex=0A=
		// Regex strategy adopted from Diego Perini=0A=
		assert(function( div ) {=0A=
			// Select is set to empty string on purpose=0A=
			// This is to test IE's treatment of not explicitly=0A=
			// setting a boolean content attribute,=0A=
			// since its presence should be enough=0A=
			// http://bugs.jquery.com/ticket/12359=0A=
			docElem.appendChild( div ).innerHTML =3D "<a id=3D'" + expando + =
"'></a>" +=0A=
				"<select id=3D'" + expando + "-\f]' msallowcapture=3D''>" +=0A=
				"<option selected=3D''></option></select>";=0A=
=0A=
			// Support: IE8, Opera 11-12.16=0A=
			// Nothing should be selected when empty strings follow ^=3D or $=3D =
or *=3D=0A=
			// The test attribute must be unknown in Opera but "safe" for WinRT=0A=
			// =
http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_sectio=
n=0A=
			if ( div.querySelectorAll("[msallowcapture^=3D'']").length ) {=0A=
				rbuggyQSA.push( "[*^$]=3D" + whitespace + "*(?:''|\"\")" );=0A=
			}=0A=
=0A=
			// Support: IE8=0A=
			// Boolean attributes and "value" are not treated correctly=0A=
			if ( !div.querySelectorAll("[selected]").length ) {=0A=
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );=0A=
			}=0A=
=0A=
			// Support: Chrome<29, Android<4.2+, Safari<7.0+, iOS<7.0+, =
PhantomJS<1.9.7+=0A=
			if ( !div.querySelectorAll( "[id~=3D" + expando + "-]" ).length ) {=0A=
				rbuggyQSA.push("~=3D");=0A=
			}=0A=
=0A=
			// Webkit/Opera - :checked should return selected option elements=0A=
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked=0A=
			// IE8 throws error here and will not see later tests=0A=
			if ( !div.querySelectorAll(":checked").length ) {=0A=
				rbuggyQSA.push(":checked");=0A=
			}=0A=
=0A=
			// Support: Safari 8+, iOS 8+=0A=
			// https://bugs.webkit.org/show_bug.cgi?id=3D136851=0A=
			// In-page `selector#id sibing-combinator selector` fails=0A=
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {=0A=
				rbuggyQSA.push(".#.+[+~]");=0A=
			}=0A=
		});=0A=
=0A=
		assert(function( div ) {=0A=
			// Support: Windows 8 Native Apps=0A=
			// The type and name attributes are restricted during .innerHTML =
assignment=0A=
			var input =3D doc.createElement("input");=0A=
			input.setAttribute( "type", "hidden" );=0A=
			div.appendChild( input ).setAttribute( "name", "D" );=0A=
=0A=
			// Support: IE8=0A=
			// Enforce case-sensitivity of name attribute=0A=
			if ( div.querySelectorAll("[name=3Dd]").length ) {=0A=
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=3D" );=0A=
			}=0A=
=0A=
			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements =
are still enabled)=0A=
			// IE8 throws error here and will not see later tests=0A=
			if ( !div.querySelectorAll(":enabled").length ) {=0A=
				rbuggyQSA.push( ":enabled", ":disabled" );=0A=
			}=0A=
=0A=
			// Opera 10-11 does not throw on post-comma invalid pseudos=0A=
			div.querySelectorAll("*,:x");=0A=
			rbuggyQSA.push(",.*:");=0A=
		});=0A=
	}=0A=
=0A=
	if ( (support.matchesSelector =3D rnative.test( (matches =3D =
docElem.matches ||=0A=
		docElem.webkitMatchesSelector ||=0A=
		docElem.mozMatchesSelector ||=0A=
		docElem.oMatchesSelector ||=0A=
		docElem.msMatchesSelector) )) ) {=0A=
=0A=
		assert(function( div ) {=0A=
			// Check to see if it's possible to do matchesSelector=0A=
			// on a disconnected node (IE 9)=0A=
			support.disconnectedMatch =3D matches.call( div, "div" );=0A=
=0A=
			// This should fail with an exception=0A=
			// Gecko does not error, returns false instead=0A=
			matches.call( div, "[s!=3D'']:x" );=0A=
			rbuggyMatches.push( "!=3D", pseudos );=0A=
		});=0A=
	}=0A=
=0A=
	rbuggyQSA =3D rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );=0A=
	rbuggyMatches =3D rbuggyMatches.length && new RegExp( =
rbuggyMatches.join("|") );=0A=
=0A=
	/* Contains=0A=
	---------------------------------------------------------------------- =
*/=0A=
	hasCompare =3D rnative.test( docElem.compareDocumentPosition );=0A=
=0A=
	// Element contains another=0A=
	// Purposefully does not implement inclusive descendent=0A=
	// As in, an element does not contain itself=0A=
	contains =3D hasCompare || rnative.test( docElem.contains ) ?=0A=
		function( a, b ) {=0A=
			var adown =3D a.nodeType =3D=3D=3D 9 ? a.documentElement : a,=0A=
				bup =3D b && b.parentNode;=0A=
			return a =3D=3D=3D bup || !!( bup && bup.nodeType =3D=3D=3D 1 && (=0A=
				adown.contains ?=0A=
					adown.contains( bup ) :=0A=
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16=0A=
			));=0A=
		} :=0A=
		function( a, b ) {=0A=
			if ( b ) {=0A=
				while ( (b =3D b.parentNode) ) {=0A=
					if ( b =3D=3D=3D a ) {=0A=
						return true;=0A=
					}=0A=
				}=0A=
			}=0A=
			return false;=0A=
		};=0A=
=0A=
	/* Sorting=0A=
	---------------------------------------------------------------------- =
*/=0A=
=0A=
	// Document order sorting=0A=
	sortOrder =3D hasCompare ?=0A=
	function( a, b ) {=0A=
=0A=
		// Flag for duplicate removal=0A=
		if ( a =3D=3D=3D b ) {=0A=
			hasDuplicate =3D true;=0A=
			return 0;=0A=
		}=0A=
=0A=
		// Sort on method existence if only one input has =
compareDocumentPosition=0A=
		var compare =3D !a.compareDocumentPosition - =
!b.compareDocumentPosition;=0A=
		if ( compare ) {=0A=
			return compare;=0A=
		}=0A=
=0A=
		// Calculate position if both inputs belong to the same document=0A=
		compare =3D ( a.ownerDocument || a ) =3D=3D=3D ( b.ownerDocument || b =
) ?=0A=
			a.compareDocumentPosition( b ) :=0A=
=0A=
			// Otherwise we know they are disconnected=0A=
			1;=0A=
=0A=
		// Disconnected nodes=0A=
		if ( compare & 1 ||=0A=
			(!support.sortDetached && b.compareDocumentPosition( a ) =3D=3D=3D =
compare) ) {=0A=
=0A=
			// Choose the first element that is related to our preferred document=0A=
			if ( a =3D=3D=3D doc || a.ownerDocument =3D=3D=3D preferredDoc && =
contains(preferredDoc, a) ) {=0A=
				return -1;=0A=
			}=0A=
			if ( b =3D=3D=3D doc || b.ownerDocument =3D=3D=3D preferredDoc && =
contains(preferredDoc, b) ) {=0A=
				return 1;=0A=
			}=0A=
=0A=
			// Maintain original order=0A=
			return sortInput ?=0A=
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :=0A=
				0;=0A=
		}=0A=
=0A=
		return compare & 4 ? -1 : 1;=0A=
	} :=0A=
	function( a, b ) {=0A=
		// Exit early if the nodes are identical=0A=
		if ( a =3D=3D=3D b ) {=0A=
			hasDuplicate =3D true;=0A=
			return 0;=0A=
		}=0A=
=0A=
		var cur,=0A=
			i =3D 0,=0A=
			aup =3D a.parentNode,=0A=
			bup =3D b.parentNode,=0A=
			ap =3D [ a ],=0A=
			bp =3D [ b ];=0A=
=0A=
		// Parentless nodes are either documents or disconnected=0A=
		if ( !aup || !bup ) {=0A=
			return a =3D=3D=3D doc ? -1 :=0A=
				b =3D=3D=3D doc ? 1 :=0A=
				aup ? -1 :=0A=
				bup ? 1 :=0A=
				sortInput ?=0A=
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :=0A=
				0;=0A=
=0A=
		// If the nodes are siblings, we can do a quick check=0A=
		} else if ( aup =3D=3D=3D bup ) {=0A=
			return siblingCheck( a, b );=0A=
		}=0A=
=0A=
		// Otherwise we need full lists of their ancestors for comparison=0A=
		cur =3D a;=0A=
		while ( (cur =3D cur.parentNode) ) {=0A=
			ap.unshift( cur );=0A=
		}=0A=
		cur =3D b;=0A=
		while ( (cur =3D cur.parentNode) ) {=0A=
			bp.unshift( cur );=0A=
		}=0A=
=0A=
		// Walk down the tree looking for a discrepancy=0A=
		while ( ap[i] =3D=3D=3D bp[i] ) {=0A=
			i++;=0A=
		}=0A=
=0A=
		return i ?=0A=
			// Do a sibling check if the nodes have a common ancestor=0A=
			siblingCheck( ap[i], bp[i] ) :=0A=
=0A=
			// Otherwise nodes in our document sort first=0A=
			ap[i] =3D=3D=3D preferredDoc ? -1 :=0A=
			bp[i] =3D=3D=3D preferredDoc ? 1 :=0A=
			0;=0A=
	};=0A=
=0A=
	return doc;=0A=
};=0A=
=0A=
Sizzle.matches =3D function( expr, elements ) {=0A=
	return Sizzle( expr, null, null, elements );=0A=
};=0A=
=0A=
Sizzle.matchesSelector =3D function( elem, expr ) {=0A=
	// Set document vars if needed=0A=
	if ( ( elem.ownerDocument || elem ) !=3D=3D document ) {=0A=
		setDocument( elem );=0A=
	}=0A=
=0A=
	// Make sure that attribute selectors are quoted=0A=
	expr =3D expr.replace( rattributeQuotes, "=3D'$1']" );=0A=
=0A=
	if ( support.matchesSelector && documentIsHTML &&=0A=
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&=0A=
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {=0A=
=0A=
		try {=0A=
			var ret =3D matches.call( elem, expr );=0A=
=0A=
			// IE 9's matchesSelector returns false on disconnected nodes=0A=
			if ( ret || support.disconnectedMatch ||=0A=
					// As well, disconnected nodes are said to be in a document=0A=
					// fragment in IE 9=0A=
					elem.document && elem.document.nodeType !=3D=3D 11 ) {=0A=
				return ret;=0A=
			}=0A=
		} catch (e) {}=0A=
	}=0A=
=0A=
	return Sizzle( expr, document, null, [ elem ] ).length > 0;=0A=
};=0A=
=0A=
Sizzle.contains =3D function( context, elem ) {=0A=
	// Set document vars if needed=0A=
	if ( ( context.ownerDocument || context ) !=3D=3D document ) {=0A=
		setDocument( context );=0A=
	}=0A=
	return contains( context, elem );=0A=
};=0A=
=0A=
Sizzle.attr =3D function( elem, name ) {=0A=
	// Set document vars if needed=0A=
	if ( ( elem.ownerDocument || elem ) !=3D=3D document ) {=0A=
		setDocument( elem );=0A=
	}=0A=
=0A=
	var fn =3D Expr.attrHandle[ name.toLowerCase() ],=0A=
		// Don't get fooled by Object.prototype properties (jQuery #13807)=0A=
		val =3D fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?=0A=
			fn( elem, name, !documentIsHTML ) :=0A=
			undefined;=0A=
=0A=
	return val !=3D=3D undefined ?=0A=
		val :=0A=
		support.attributes || !documentIsHTML ?=0A=
			elem.getAttribute( name ) :=0A=
			(val =3D elem.getAttributeNode(name)) && val.specified ?=0A=
				val.value :=0A=
				null;=0A=
};=0A=
=0A=
Sizzle.error =3D function( msg ) {=0A=
	throw new Error( "Syntax error, unrecognized expression: " + msg );=0A=
};=0A=
=0A=
/**=0A=
 * Document sorting and removing duplicates=0A=
 * @param {ArrayLike} results=0A=
 */=0A=
Sizzle.uniqueSort =3D function( results ) {=0A=
	var elem,=0A=
		duplicates =3D [],=0A=
		j =3D 0,=0A=
		i =3D 0;=0A=
=0A=
	// Unless we *know* we can detect duplicates, assume their presence=0A=
	hasDuplicate =3D !support.detectDuplicates;=0A=
	sortInput =3D !support.sortStable && results.slice( 0 );=0A=
	results.sort( sortOrder );=0A=
=0A=
	if ( hasDuplicate ) {=0A=
		while ( (elem =3D results[i++]) ) {=0A=
			if ( elem =3D=3D=3D results[ i ] ) {=0A=
				j =3D duplicates.push( i );=0A=
			}=0A=
		}=0A=
		while ( j-- ) {=0A=
			results.splice( duplicates[ j ], 1 );=0A=
		}=0A=
	}=0A=
=0A=
	// Clear input after sorting to release objects=0A=
	// See https://github.com/jquery/sizzle/pull/225=0A=
	sortInput =3D null;=0A=
=0A=
	return results;=0A=
};=0A=
=0A=
/**=0A=
 * Utility function for retrieving the text value of an array of DOM =
nodes=0A=
 * @param {Array|Element} elem=0A=
 */=0A=
getText =3D Sizzle.getText =3D function( elem ) {=0A=
	var node,=0A=
		ret =3D "",=0A=
		i =3D 0,=0A=
		nodeType =3D elem.nodeType;=0A=
=0A=
	if ( !nodeType ) {=0A=
		// If no nodeType, this is expected to be an array=0A=
		while ( (node =3D elem[i++]) ) {=0A=
			// Do not traverse comment nodes=0A=
			ret +=3D getText( node );=0A=
		}=0A=
	} else if ( nodeType =3D=3D=3D 1 || nodeType =3D=3D=3D 9 || nodeType =
=3D=3D=3D 11 ) {=0A=
		// Use textContent for elements=0A=
		// innerText usage removed for consistency of new lines (jQuery #11153)=0A=
		if ( typeof elem.textContent =3D=3D=3D "string" ) {=0A=
			return elem.textContent;=0A=
		} else {=0A=
			// Traverse its children=0A=
			for ( elem =3D elem.firstChild; elem; elem =3D elem.nextSibling ) {=0A=
				ret +=3D getText( elem );=0A=
			}=0A=
		}=0A=
	} else if ( nodeType =3D=3D=3D 3 || nodeType =3D=3D=3D 4 ) {=0A=
		return elem.nodeValue;=0A=
	}=0A=
	// Do not include comment or processing instruction nodes=0A=
=0A=
	return ret;=0A=
};=0A=
=0A=
Expr =3D Sizzle.selectors =3D {=0A=
=0A=
	// Can be adjusted by the user=0A=
	cacheLength: 50,=0A=
=0A=
	createPseudo: markFunction,=0A=
=0A=
	match: matchExpr,=0A=
=0A=
	attrHandle: {},=0A=
=0A=
	find: {},=0A=
=0A=
	relative: {=0A=
		">": { dir: "parentNode", first: true },=0A=
		" ": { dir: "parentNode" },=0A=
		"+": { dir: "previousSibling", first: true },=0A=
		"~": { dir: "previousSibling" }=0A=
	},=0A=
=0A=
	preFilter: {=0A=
		"ATTR": function( match ) {=0A=
			match[1] =3D match[1].replace( runescape, funescape );=0A=
=0A=
			// Move the given value to match[3] whether quoted or unquoted=0A=
			match[3] =3D ( match[3] || match[4] || match[5] || "" ).replace( =
runescape, funescape );=0A=
=0A=
			if ( match[2] =3D=3D=3D "~=3D" ) {=0A=
				match[3] =3D " " + match[3] + " ";=0A=
			}=0A=
=0A=
			return match.slice( 0, 4 );=0A=
		},=0A=
=0A=
		"CHILD": function( match ) {=0A=
			/* matches from matchExpr["CHILD"]=0A=
				1 type (only|nth|...)=0A=
				2 what (child|of-type)=0A=
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)=0A=
				4 xn-component of xn+y argument ([+-]?\d*n|)=0A=
				5 sign of xn-component=0A=
				6 x of xn-component=0A=
				7 sign of y-component=0A=
				8 y of y-component=0A=
			*/=0A=
			match[1] =3D match[1].toLowerCase();=0A=
=0A=
			if ( match[1].slice( 0, 3 ) =3D=3D=3D "nth" ) {=0A=
				// nth-* requires argument=0A=
				if ( !match[3] ) {=0A=
					Sizzle.error( match[0] );=0A=
				}=0A=
=0A=
				// numeric x and y parameters for Expr.filter.CHILD=0A=
				// remember that false/true cast respectively to 0/1=0A=
				match[4] =3D +( match[4] ? match[5] + (match[6] || 1) : 2 * ( =
match[3] =3D=3D=3D "even" || match[3] =3D=3D=3D "odd" ) );=0A=
				match[5] =3D +( ( match[7] + match[8] ) || match[3] =3D=3D=3D "odd" =
);=0A=
=0A=
			// other types prohibit arguments=0A=
			} else if ( match[3] ) {=0A=
				Sizzle.error( match[0] );=0A=
			}=0A=
=0A=
			return match;=0A=
		},=0A=
=0A=
		"PSEUDO": function( match ) {=0A=
			var excess,=0A=
				unquoted =3D !match[6] && match[2];=0A=
=0A=
			if ( matchExpr["CHILD"].test( match[0] ) ) {=0A=
				return null;=0A=
			}=0A=
=0A=
			// Accept quoted arguments as-is=0A=
			if ( match[3] ) {=0A=
				match[2] =3D match[4] || match[5] || "";=0A=
=0A=
			// Strip excess characters from unquoted arguments=0A=
			} else if ( unquoted && rpseudo.test( unquoted ) &&=0A=
				// Get excess from tokenize (recursively)=0A=
				(excess =3D tokenize( unquoted, true )) &&=0A=
				// advance to the next closing parenthesis=0A=
				(excess =3D unquoted.indexOf( ")", unquoted.length - excess ) - =
unquoted.length) ) {=0A=
=0A=
				// excess is a negative index=0A=
				match[0] =3D match[0].slice( 0, excess );=0A=
				match[2] =3D unquoted.slice( 0, excess );=0A=
			}=0A=
=0A=
			// Return only captures needed by the pseudo filter method (type and =
argument)=0A=
			return match.slice( 0, 3 );=0A=
		}=0A=
	},=0A=
=0A=
	filter: {=0A=
=0A=
		"TAG": function( nodeNameSelector ) {=0A=
			var nodeName =3D nodeNameSelector.replace( runescape, funescape =
).toLowerCase();=0A=
			return nodeNameSelector =3D=3D=3D "*" ?=0A=
				function() { return true; } :=0A=
				function( elem ) {=0A=
					return elem.nodeName && elem.nodeName.toLowerCase() =3D=3D=3D =
nodeName;=0A=
				};=0A=
		},=0A=
=0A=
		"CLASS": function( className ) {=0A=
			var pattern =3D classCache[ className + " " ];=0A=
=0A=
			return pattern ||=0A=
				(pattern =3D new RegExp( "(^|" + whitespace + ")" + className + "(" =
+ whitespace + "|$)" )) &&=0A=
				classCache( className, function( elem ) {=0A=
					return pattern.test( typeof elem.className =3D=3D=3D "string" && =
elem.className || typeof elem.getAttribute !=3D=3D "undefined" && =
elem.getAttribute("class") || "" );=0A=
				});=0A=
		},=0A=
=0A=
		"ATTR": function( name, operator, check ) {=0A=
			return function( elem ) {=0A=
				var result =3D Sizzle.attr( elem, name );=0A=
=0A=
				if ( result =3D=3D null ) {=0A=
					return operator =3D=3D=3D "!=3D";=0A=
				}=0A=
				if ( !operator ) {=0A=
					return true;=0A=
				}=0A=
=0A=
				result +=3D "";=0A=
=0A=
				return operator =3D=3D=3D "=3D" ? result =3D=3D=3D check :=0A=
					operator =3D=3D=3D "!=3D" ? result !=3D=3D check :=0A=
					operator =3D=3D=3D "^=3D" ? check && result.indexOf( check ) =
=3D=3D=3D 0 :=0A=
					operator =3D=3D=3D "*=3D" ? check && result.indexOf( check ) > -1 :=0A=
					operator =3D=3D=3D "$=3D" ? check && result.slice( -check.length ) =
=3D=3D=3D check :=0A=
					operator =3D=3D=3D "~=3D" ? ( " " + result.replace( rwhitespace, " =
" ) + " " ).indexOf( check ) > -1 :=0A=
					operator =3D=3D=3D "|=3D" ? result =3D=3D=3D check || result.slice( =
0, check.length + 1 ) =3D=3D=3D check + "-" :=0A=
					false;=0A=
			};=0A=
		},=0A=
=0A=
		"CHILD": function( type, what, argument, first, last ) {=0A=
			var simple =3D type.slice( 0, 3 ) !=3D=3D "nth",=0A=
				forward =3D type.slice( -4 ) !=3D=3D "last",=0A=
				ofType =3D what =3D=3D=3D "of-type";=0A=
=0A=
			return first =3D=3D=3D 1 && last =3D=3D=3D 0 ?=0A=
=0A=
				// Shortcut for :nth-*(n)=0A=
				function( elem ) {=0A=
					return !!elem.parentNode;=0A=
				} :=0A=
=0A=
				function( elem, context, xml ) {=0A=
					var cache, outerCache, node, diff, nodeIndex, start,=0A=
						dir =3D simple !=3D=3D forward ? "nextSibling" : "previousSibling",=0A=
						parent =3D elem.parentNode,=0A=
						name =3D ofType && elem.nodeName.toLowerCase(),=0A=
						useCache =3D !xml && !ofType;=0A=
=0A=
					if ( parent ) {=0A=
=0A=
						// :(first|last|only)-(child|of-type)=0A=
						if ( simple ) {=0A=
							while ( dir ) {=0A=
								node =3D elem;=0A=
								while ( (node =3D node[ dir ]) ) {=0A=
									if ( ofType ? node.nodeName.toLowerCase() =3D=3D=3D name : =
node.nodeType =3D=3D=3D 1 ) {=0A=
										return false;=0A=
									}=0A=
								}=0A=
								// Reverse direction for :only-* (if we haven't yet done so)=0A=
								start =3D dir =3D type =3D=3D=3D "only" && !start && =
"nextSibling";=0A=
							}=0A=
							return true;=0A=
						}=0A=
=0A=
						start =3D [ forward ? parent.firstChild : parent.lastChild ];=0A=
=0A=
						// non-xml :nth-child(...) stores cache data on `parent`=0A=
						if ( forward && useCache ) {=0A=
							// Seek `elem` from a previously-cached index=0A=
							outerCache =3D parent[ expando ] || (parent[ expando ] =3D {});=0A=
							cache =3D outerCache[ type ] || [];=0A=
							nodeIndex =3D cache[0] =3D=3D=3D dirruns && cache[1];=0A=
							diff =3D cache[0] =3D=3D=3D dirruns && cache[2];=0A=
							node =3D nodeIndex && parent.childNodes[ nodeIndex ];=0A=
=0A=
							while ( (node =3D ++nodeIndex && node && node[ dir ] ||=0A=
=0A=
								// Fallback to seeking `elem` from the start=0A=
								(diff =3D nodeIndex =3D 0) || start.pop()) ) {=0A=
=0A=
								// When found, cache indexes on `parent` and break=0A=
								if ( node.nodeType =3D=3D=3D 1 && ++diff && node =3D=3D=3D elem =
) {=0A=
									outerCache[ type ] =3D [ dirruns, nodeIndex, diff ];=0A=
									break;=0A=
								}=0A=
							}=0A=
=0A=
						// Use previously-cached element index if available=0A=
						} else if ( useCache && (cache =3D (elem[ expando ] || (elem[ =
expando ] =3D {}))[ type ]) && cache[0] =3D=3D=3D dirruns ) {=0A=
							diff =3D cache[1];=0A=
=0A=
						// xml :nth-child(...) or :nth-last-child(...) or =
:nth(-last)?-of-type(...)=0A=
						} else {=0A=
							// Use the same loop as above to seek `elem` from the start=0A=
							while ( (node =3D ++nodeIndex && node && node[ dir ] ||=0A=
								(diff =3D nodeIndex =3D 0) || start.pop()) ) {=0A=
=0A=
								if ( ( ofType ? node.nodeName.toLowerCase() =3D=3D=3D name : =
node.nodeType =3D=3D=3D 1 ) && ++diff ) {=0A=
									// Cache the index of each encountered element=0A=
									if ( useCache ) {=0A=
										(node[ expando ] || (node[ expando ] =3D {}))[ type ] =3D [ =
dirruns, diff ];=0A=
									}=0A=
=0A=
									if ( node =3D=3D=3D elem ) {=0A=
										break;=0A=
									}=0A=
								}=0A=
							}=0A=
						}=0A=
=0A=
						// Incorporate the offset, then check against cycle size=0A=
						diff -=3D last;=0A=
						return diff =3D=3D=3D first || ( diff % first =3D=3D=3D 0 && diff =
/ first >=3D 0 );=0A=
					}=0A=
				};=0A=
		},=0A=
=0A=
		"PSEUDO": function( pseudo, argument ) {=0A=
			// pseudo-class names are case-insensitive=0A=
			// http://www.w3.org/TR/selectors/#pseudo-classes=0A=
			// Prioritize by case sensitivity in case custom pseudos are added =
with uppercase letters=0A=
			// Remember that setFilters inherits from pseudos=0A=
			var args,=0A=
				fn =3D Expr.pseudos[ pseudo ] || Expr.setFilters[ =
pseudo.toLowerCase() ] ||=0A=
					Sizzle.error( "unsupported pseudo: " + pseudo );=0A=
=0A=
			// The user may use createPseudo to indicate that=0A=
			// arguments are needed to create the filter function=0A=
			// just as Sizzle does=0A=
			if ( fn[ expando ] ) {=0A=
				return fn( argument );=0A=
			}=0A=
=0A=
			// But maintain support for old signatures=0A=
			if ( fn.length > 1 ) {=0A=
				args =3D [ pseudo, pseudo, "", argument ];=0A=
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?=0A=
					markFunction(function( seed, matches ) {=0A=
						var idx,=0A=
							matched =3D fn( seed, argument ),=0A=
							i =3D matched.length;=0A=
						while ( i-- ) {=0A=
							idx =3D indexOf( seed, matched[i] );=0A=
							seed[ idx ] =3D !( matches[ idx ] =3D matched[i] );=0A=
						}=0A=
					}) :=0A=
					function( elem ) {=0A=
						return fn( elem, 0, args );=0A=
					};=0A=
			}=0A=
=0A=
			return fn;=0A=
		}=0A=
	},=0A=
=0A=
	pseudos: {=0A=
		// Potentially complex pseudos=0A=
		"not": markFunction(function( selector ) {=0A=
			// Trim the selector passed to compile=0A=
			// to avoid treating leading and trailing=0A=
			// spaces as combinators=0A=
			var input =3D [],=0A=
				results =3D [],=0A=
				matcher =3D compile( selector.replace( rtrim, "$1" ) );=0A=
=0A=
			return matcher[ expando ] ?=0A=
				markFunction(function( seed, matches, context, xml ) {=0A=
					var elem,=0A=
						unmatched =3D matcher( seed, null, xml, [] ),=0A=
						i =3D seed.length;=0A=
=0A=
					// Match elements unmatched by `matcher`=0A=
					while ( i-- ) {=0A=
						if ( (elem =3D unmatched[i]) ) {=0A=
							seed[i] =3D !(matches[i] =3D elem);=0A=
						}=0A=
					}=0A=
				}) :=0A=
				function( elem, context, xml ) {=0A=
					input[0] =3D elem;=0A=
					matcher( input, null, xml, results );=0A=
					// Don't keep the element (issue #299)=0A=
					input[0] =3D null;=0A=
					return !results.pop();=0A=
				};=0A=
		}),=0A=
=0A=
		"has": markFunction(function( selector ) {=0A=
			return function( elem ) {=0A=
				return Sizzle( selector, elem ).length > 0;=0A=
			};=0A=
		}),=0A=
=0A=
		"contains": markFunction(function( text ) {=0A=
			text =3D text.replace( runescape, funescape );=0A=
			return function( elem ) {=0A=
				return ( elem.textContent || elem.innerText || getText( elem ) =
).indexOf( text ) > -1;=0A=
			};=0A=
		}),=0A=
=0A=
		// "Whether an element is represented by a :lang() selector=0A=
		// is based solely on the element's language value=0A=
		// being equal to the identifier C,=0A=
		// or beginning with the identifier C immediately followed by "-".=0A=
		// The matching of C against the element's language value is performed =
case-insensitively.=0A=
		// The identifier C does not have to be a valid language name."=0A=
		// http://www.w3.org/TR/selectors/#lang-pseudo=0A=
		"lang": markFunction( function( lang ) {=0A=
			// lang value must be a valid identifier=0A=
			if ( !ridentifier.test(lang || "") ) {=0A=
				Sizzle.error( "unsupported lang: " + lang );=0A=
			}=0A=
			lang =3D lang.replace( runescape, funescape ).toLowerCase();=0A=
			return function( elem ) {=0A=
				var elemLang;=0A=
				do {=0A=
					if ( (elemLang =3D documentIsHTML ?=0A=
						elem.lang :=0A=
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {=0A=
=0A=
						elemLang =3D elemLang.toLowerCase();=0A=
						return elemLang =3D=3D=3D lang || elemLang.indexOf( lang + "-" ) =
=3D=3D=3D 0;=0A=
					}=0A=
				} while ( (elem =3D elem.parentNode) && elem.nodeType =3D=3D=3D 1 );=0A=
				return false;=0A=
			};=0A=
		}),=0A=
=0A=
		// Miscellaneous=0A=
		"target": function( elem ) {=0A=
			var hash =3D window.location && window.location.hash;=0A=
			return hash && hash.slice( 1 ) =3D=3D=3D elem.id;=0A=
		},=0A=
=0A=
		"root": function( elem ) {=0A=
			return elem =3D=3D=3D docElem;=0A=
		},=0A=
=0A=
		"focus": function( elem ) {=0A=
			return elem =3D=3D=3D document.activeElement && (!document.hasFocus =
|| document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);=0A=
		},=0A=
=0A=
		// Boolean properties=0A=
		"enabled": function( elem ) {=0A=
			return elem.disabled =3D=3D=3D false;=0A=
		},=0A=
=0A=
		"disabled": function( elem ) {=0A=
			return elem.disabled =3D=3D=3D true;=0A=
		},=0A=
=0A=
		"checked": function( elem ) {=0A=
			// In CSS3, :checked should return both checked and selected elements=0A=
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked=0A=
			var nodeName =3D elem.nodeName.toLowerCase();=0A=
			return (nodeName =3D=3D=3D "input" && !!elem.checked) || (nodeName =
=3D=3D=3D "option" && !!elem.selected);=0A=
		},=0A=
=0A=
		"selected": function( elem ) {=0A=
			// Accessing this property makes selected-by-default=0A=
			// options in Safari work properly=0A=
			if ( elem.parentNode ) {=0A=
				elem.parentNode.selectedIndex;=0A=
			}=0A=
=0A=
			return elem.selected =3D=3D=3D true;=0A=
		},=0A=
=0A=
		// Contents=0A=
		"empty": function( elem ) {=0A=
			// http://www.w3.org/TR/selectors/#empty-pseudo=0A=
			// :empty is negated by element (1) or content nodes (text: 3; cdata: =
4; entity ref: 5),=0A=
			//   but not by others (comment: 8; processing instruction: 7; etc.)=0A=
			// nodeType < 6 works because attributes (2) do not appear as children=0A=
			for ( elem =3D elem.firstChild; elem; elem =3D elem.nextSibling ) {=0A=
				if ( elem.nodeType < 6 ) {=0A=
					return false;=0A=
				}=0A=
			}=0A=
			return true;=0A=
		},=0A=
=0A=
		"parent": function( elem ) {=0A=
			return !Expr.pseudos["empty"]( elem );=0A=
		},=0A=
=0A=
		// Element/input types=0A=
		"header": function( elem ) {=0A=
			return rheader.test( elem.nodeName );=0A=
		},=0A=
=0A=
		"input": function( elem ) {=0A=
			return rinputs.test( elem.nodeName );=0A=
		},=0A=
=0A=
		"button": function( elem ) {=0A=
			var name =3D elem.nodeName.toLowerCase();=0A=
			return name =3D=3D=3D "input" && elem.type =3D=3D=3D "button" || name =
=3D=3D=3D "button";=0A=
		},=0A=
=0A=
		"text": function( elem ) {=0A=
			var attr;=0A=
			return elem.nodeName.toLowerCase() =3D=3D=3D "input" &&=0A=
				elem.type =3D=3D=3D "text" &&=0A=
=0A=
				// Support: IE<8=0A=
				// New HTML5 attribute values (e.g., "search") appear with elem.type =
=3D=3D=3D "text"=0A=
				( (attr =3D elem.getAttribute("type")) =3D=3D null || =
attr.toLowerCase() =3D=3D=3D "text" );=0A=
		},=0A=
=0A=
		// Position-in-collection=0A=
		"first": createPositionalPseudo(function() {=0A=
			return [ 0 ];=0A=
		}),=0A=
=0A=
		"last": createPositionalPseudo(function( matchIndexes, length ) {=0A=
			return [ length - 1 ];=0A=
		}),=0A=
=0A=
		"eq": createPositionalPseudo(function( matchIndexes, length, argument =
) {=0A=
			return [ argument < 0 ? argument + length : argument ];=0A=
		}),=0A=
=0A=
		"even": createPositionalPseudo(function( matchIndexes, length ) {=0A=
			var i =3D 0;=0A=
			for ( ; i < length; i +=3D 2 ) {=0A=
				matchIndexes.push( i );=0A=
			}=0A=
			return matchIndexes;=0A=
		}),=0A=
=0A=
		"odd": createPositionalPseudo(function( matchIndexes, length ) {=0A=
			var i =3D 1;=0A=
			for ( ; i < length; i +=3D 2 ) {=0A=
				matchIndexes.push( i );=0A=
			}=0A=
			return matchIndexes;=0A=
		}),=0A=
=0A=
		"lt": createPositionalPseudo(function( matchIndexes, length, argument =
) {=0A=
			var i =3D argument < 0 ? argument + length : argument;=0A=
			for ( ; --i >=3D 0; ) {=0A=
				matchIndexes.push( i );=0A=
			}=0A=
			return matchIndexes;=0A=
		}),=0A=
=0A=
		"gt": createPositionalPseudo(function( matchIndexes, length, argument =
) {=0A=
			var i =3D argument < 0 ? argument + length : argument;=0A=
			for ( ; ++i < length; ) {=0A=
				matchIndexes.push( i );=0A=
			}=0A=
			return matchIndexes;=0A=
		})=0A=
	}=0A=
};=0A=
=0A=
Expr.pseudos["nth"] =3D Expr.pseudos["eq"];=0A=
=0A=
// Add button/input type pseudos=0A=
for ( i in { radio: true, checkbox: true, file: true, password: true, =
image: true } ) {=0A=
	Expr.pseudos[ i ] =3D createInputPseudo( i );=0A=
}=0A=
for ( i in { submit: true, reset: true } ) {=0A=
	Expr.pseudos[ i ] =3D createButtonPseudo( i );=0A=
}=0A=
=0A=
// Easy API for creating new setFilters=0A=
function setFilters() {}=0A=
setFilters.prototype =3D Expr.filters =3D Expr.pseudos;=0A=
Expr.setFilters =3D new setFilters();=0A=
=0A=
tokenize =3D Sizzle.tokenize =3D function( selector, parseOnly ) {=0A=
	var matched, match, tokens, type,=0A=
		soFar, groups, preFilters,=0A=
		cached =3D tokenCache[ selector + " " ];=0A=
=0A=
	if ( cached ) {=0A=
		return parseOnly ? 0 : cached.slice( 0 );=0A=
	}=0A=
=0A=
	soFar =3D selector;=0A=
	groups =3D [];=0A=
	preFilters =3D Expr.preFilter;=0A=
=0A=
	while ( soFar ) {=0A=
=0A=
		// Comma and first run=0A=
		if ( !matched || (match =3D rcomma.exec( soFar )) ) {=0A=
			if ( match ) {=0A=
				// Don't consume trailing commas as valid=0A=
				soFar =3D soFar.slice( match[0].length ) || soFar;=0A=
			}=0A=
			groups.push( (tokens =3D []) );=0A=
		}=0A=
=0A=
		matched =3D false;=0A=
=0A=
		// Combinators=0A=
		if ( (match =3D rcombinators.exec( soFar )) ) {=0A=
			matched =3D match.shift();=0A=
			tokens.push({=0A=
				value: matched,=0A=
				// Cast descendant combinators to space=0A=
				type: match[0].replace( rtrim, " " )=0A=
			});=0A=
			soFar =3D soFar.slice( matched.length );=0A=
		}=0A=
=0A=
		// Filters=0A=
		for ( type in Expr.filter ) {=0A=
			if ( (match =3D matchExpr[ type ].exec( soFar )) && (!preFilters[ =
type ] ||=0A=
				(match =3D preFilters[ type ]( match ))) ) {=0A=
				matched =3D match.shift();=0A=
				tokens.push({=0A=
					value: matched,=0A=
					type: type,=0A=
					matches: match=0A=
				});=0A=
				soFar =3D soFar.slice( matched.length );=0A=
			}=0A=
		}=0A=
=0A=
		if ( !matched ) {=0A=
			break;=0A=
		}=0A=
	}=0A=
=0A=
	// Return the length of the invalid excess=0A=
	// if we're just parsing=0A=
	// Otherwise, throw an error or return tokens=0A=
	return parseOnly ?=0A=
		soFar.length :=0A=
		soFar ?=0A=
			Sizzle.error( selector ) :=0A=
			// Cache the tokens=0A=
			tokenCache( selector, groups ).slice( 0 );=0A=
};=0A=
=0A=
function toSelector( tokens ) {=0A=
	var i =3D 0,=0A=
		len =3D tokens.length,=0A=
		selector =3D "";=0A=
	for ( ; i < len; i++ ) {=0A=
		selector +=3D tokens[i].value;=0A=
	}=0A=
	return selector;=0A=
}=0A=
=0A=
function addCombinator( matcher, combinator, base ) {=0A=
	var dir =3D combinator.dir,=0A=
		checkNonElements =3D base && dir =3D=3D=3D "parentNode",=0A=
		doneName =3D done++;=0A=
=0A=
	return combinator.first ?=0A=
		// Check against closest ancestor/preceding element=0A=
		function( elem, context, xml ) {=0A=
			while ( (elem =3D elem[ dir ]) ) {=0A=
				if ( elem.nodeType =3D=3D=3D 1 || checkNonElements ) {=0A=
					return matcher( elem, context, xml );=0A=
				}=0A=
			}=0A=
		} :=0A=
=0A=
		// Check against all ancestor/preceding elements=0A=
		function( elem, context, xml ) {=0A=
			var oldCache, outerCache,=0A=
				newCache =3D [ dirruns, doneName ];=0A=
=0A=
			// We can't set arbitrary data on XML nodes, so they don't benefit =
from dir caching=0A=
			if ( xml ) {=0A=
				while ( (elem =3D elem[ dir ]) ) {=0A=
					if ( elem.nodeType =3D=3D=3D 1 || checkNonElements ) {=0A=
						if ( matcher( elem, context, xml ) ) {=0A=
							return true;=0A=
						}=0A=
					}=0A=
				}=0A=
			} else {=0A=
				while ( (elem =3D elem[ dir ]) ) {=0A=
					if ( elem.nodeType =3D=3D=3D 1 || checkNonElements ) {=0A=
						outerCache =3D elem[ expando ] || (elem[ expando ] =3D {});=0A=
						if ( (oldCache =3D outerCache[ dir ]) &&=0A=
							oldCache[ 0 ] =3D=3D=3D dirruns && oldCache[ 1 ] =3D=3D=3D =
doneName ) {=0A=
=0A=
							// Assign to newCache so results back-propagate to previous =
elements=0A=
							return (newCache[ 2 ] =3D oldCache[ 2 ]);=0A=
						} else {=0A=
							// Reuse newcache so results back-propagate to previous elements=0A=
							outerCache[ dir ] =3D newCache;=0A=
=0A=
							// A match means we're done; a fail means we have to keep checking=0A=
							if ( (newCache[ 2 ] =3D matcher( elem, context, xml )) ) {=0A=
								return true;=0A=
							}=0A=
						}=0A=
					}=0A=
				}=0A=
			}=0A=
		};=0A=
}=0A=
=0A=
function elementMatcher( matchers ) {=0A=
	return matchers.length > 1 ?=0A=
		function( elem, context, xml ) {=0A=
			var i =3D matchers.length;=0A=
			while ( i-- ) {=0A=
				if ( !matchers[i]( elem, context, xml ) ) {=0A=
					return false;=0A=
				}=0A=
			}=0A=
			return true;=0A=
		} :=0A=
		matchers[0];=0A=
}=0A=
=0A=
function multipleContexts( selector, contexts, results ) {=0A=
	var i =3D 0,=0A=
		len =3D contexts.length;=0A=
	for ( ; i < len; i++ ) {=0A=
		Sizzle( selector, contexts[i], results );=0A=
	}=0A=
	return results;=0A=
}=0A=
=0A=
function condense( unmatched, map, filter, context, xml ) {=0A=
	var elem,=0A=
		newUnmatched =3D [],=0A=
		i =3D 0,=0A=
		len =3D unmatched.length,=0A=
		mapped =3D map !=3D null;=0A=
=0A=
	for ( ; i < len; i++ ) {=0A=
		if ( (elem =3D unmatched[i]) ) {=0A=
			if ( !filter || filter( elem, context, xml ) ) {=0A=
				newUnmatched.push( elem );=0A=
				if ( mapped ) {=0A=
					map.push( i );=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	return newUnmatched;=0A=
}=0A=
=0A=
function setMatcher( preFilter, selector, matcher, postFilter, =
postFinder, postSelector ) {=0A=
	if ( postFilter && !postFilter[ expando ] ) {=0A=
		postFilter =3D setMatcher( postFilter );=0A=
	}=0A=
	if ( postFinder && !postFinder[ expando ] ) {=0A=
		postFinder =3D setMatcher( postFinder, postSelector );=0A=
	}=0A=
	return markFunction(function( seed, results, context, xml ) {=0A=
		var temp, i, elem,=0A=
			preMap =3D [],=0A=
			postMap =3D [],=0A=
			preexisting =3D results.length,=0A=
=0A=
			// Get initial elements from seed or context=0A=
			elems =3D seed || multipleContexts( selector || "*", context.nodeType =
? [ context ] : context, [] ),=0A=
=0A=
			// Prefilter to get matcher input, preserving a map for seed-results =
synchronization=0A=
			matcherIn =3D preFilter && ( seed || !selector ) ?=0A=
				condense( elems, preMap, preFilter, context, xml ) :=0A=
				elems,=0A=
=0A=
			matcherOut =3D matcher ?=0A=
				// If we have a postFinder, or filtered seed, or non-seed postFilter =
or preexisting results,=0A=
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?=0A=
=0A=
					// ...intermediate processing is necessary=0A=
					[] :=0A=
=0A=
					// ...otherwise use results directly=0A=
					results :=0A=
				matcherIn;=0A=
=0A=
		// Find primary matches=0A=
		if ( matcher ) {=0A=
			matcher( matcherIn, matcherOut, context, xml );=0A=
		}=0A=
=0A=
		// Apply postFilter=0A=
		if ( postFilter ) {=0A=
			temp =3D condense( matcherOut, postMap );=0A=
			postFilter( temp, [], context, xml );=0A=
=0A=
			// Un-match failing elements by moving them back to matcherIn=0A=
			i =3D temp.length;=0A=
			while ( i-- ) {=0A=
				if ( (elem =3D temp[i]) ) {=0A=
					matcherOut[ postMap[i] ] =3D !(matcherIn[ postMap[i] ] =3D elem);=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		if ( seed ) {=0A=
			if ( postFinder || preFilter ) {=0A=
				if ( postFinder ) {=0A=
					// Get the final matcherOut by condensing this intermediate into =
postFinder contexts=0A=
					temp =3D [];=0A=
					i =3D matcherOut.length;=0A=
					while ( i-- ) {=0A=
						if ( (elem =3D matcherOut[i]) ) {=0A=
							// Restore matcherIn since elem is not yet a final match=0A=
							temp.push( (matcherIn[i] =3D elem) );=0A=
						}=0A=
					}=0A=
					postFinder( null, (matcherOut =3D []), temp, xml );=0A=
				}=0A=
=0A=
				// Move matched elements from seed to results to keep them =
synchronized=0A=
				i =3D matcherOut.length;=0A=
				while ( i-- ) {=0A=
					if ( (elem =3D matcherOut[i]) &&=0A=
						(temp =3D postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {=0A=
=0A=
						seed[temp] =3D !(results[temp] =3D elem);=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
		// Add elements to results, through postFinder if defined=0A=
		} else {=0A=
			matcherOut =3D condense(=0A=
				matcherOut =3D=3D=3D results ?=0A=
					matcherOut.splice( preexisting, matcherOut.length ) :=0A=
					matcherOut=0A=
			);=0A=
			if ( postFinder ) {=0A=
				postFinder( null, results, matcherOut, xml );=0A=
			} else {=0A=
				push.apply( results, matcherOut );=0A=
			}=0A=
		}=0A=
	});=0A=
}=0A=
=0A=
function matcherFromTokens( tokens ) {=0A=
	var checkContext, matcher, j,=0A=
		len =3D tokens.length,=0A=
		leadingRelative =3D Expr.relative[ tokens[0].type ],=0A=
		implicitRelative =3D leadingRelative || Expr.relative[" "],=0A=
		i =3D leadingRelative ? 1 : 0,=0A=
=0A=
		// The foundational matcher ensures that elements are reachable from =
top-level context(s)=0A=
		matchContext =3D addCombinator( function( elem ) {=0A=
			return elem =3D=3D=3D checkContext;=0A=
		}, implicitRelative, true ),=0A=
		matchAnyContext =3D addCombinator( function( elem ) {=0A=
			return indexOf( checkContext, elem ) > -1;=0A=
		}, implicitRelative, true ),=0A=
		matchers =3D [ function( elem, context, xml ) {=0A=
			var ret =3D ( !leadingRelative && ( xml || context !=3D=3D =
outermostContext ) ) || (=0A=
				(checkContext =3D context).nodeType ?=0A=
					matchContext( elem, context, xml ) :=0A=
					matchAnyContext( elem, context, xml ) );=0A=
			// Avoid hanging onto element (issue #299)=0A=
			checkContext =3D null;=0A=
			return ret;=0A=
		} ];=0A=
=0A=
	for ( ; i < len; i++ ) {=0A=
		if ( (matcher =3D Expr.relative[ tokens[i].type ]) ) {=0A=
			matchers =3D [ addCombinator(elementMatcher( matchers ), matcher) ];=0A=
		} else {=0A=
			matcher =3D Expr.filter[ tokens[i].type ].apply( null, =
tokens[i].matches );=0A=
=0A=
			// Return special upon seeing a positional matcher=0A=
			if ( matcher[ expando ] ) {=0A=
				// Find the next relative operator (if any) for proper handling=0A=
				j =3D ++i;=0A=
				for ( ; j < len; j++ ) {=0A=
					if ( Expr.relative[ tokens[j].type ] ) {=0A=
						break;=0A=
					}=0A=
				}=0A=
				return setMatcher(=0A=
					i > 1 && elementMatcher( matchers ),=0A=
					i > 1 && toSelector(=0A=
						// If the preceding token was a descendant combinator, insert an =
implicit any-element `*`=0A=
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type =
=3D=3D=3D " " ? "*" : "" })=0A=
					).replace( rtrim, "$1" ),=0A=
					matcher,=0A=
					i < j && matcherFromTokens( tokens.slice( i, j ) ),=0A=
					j < len && matcherFromTokens( (tokens =3D tokens.slice( j )) ),=0A=
					j < len && toSelector( tokens )=0A=
				);=0A=
			}=0A=
			matchers.push( matcher );=0A=
		}=0A=
	}=0A=
=0A=
	return elementMatcher( matchers );=0A=
}=0A=
=0A=
function matcherFromGroupMatchers( elementMatchers, setMatchers ) {=0A=
	var bySet =3D setMatchers.length > 0,=0A=
		byElement =3D elementMatchers.length > 0,=0A=
		superMatcher =3D function( seed, context, xml, results, outermost ) {=0A=
			var elem, j, matcher,=0A=
				matchedCount =3D 0,=0A=
				i =3D "0",=0A=
				unmatched =3D seed && [],=0A=
				setMatched =3D [],=0A=
				contextBackup =3D outermostContext,=0A=
				// We must always have either seed elements or outermost context=0A=
				elems =3D seed || byElement && Expr.find["TAG"]( "*", outermost ),=0A=
				// Use integer dirruns iff this is the outermost matcher=0A=
				dirrunsUnique =3D (dirruns +=3D contextBackup =3D=3D null ? 1 : =
Math.random() || 0.1),=0A=
				len =3D elems.length;=0A=
=0A=
			if ( outermost ) {=0A=
				outermostContext =3D context !=3D=3D document && context;=0A=
			}=0A=
=0A=
			// Add elements passing elementMatchers directly to results=0A=
			// Keep `i` a string if there are no elements so `matchedCount` will =
be "00" below=0A=
			// Support: IE<9, Safari=0A=
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) =
matching elements by id=0A=
			for ( ; i !=3D=3D len && (elem =3D elems[i]) !=3D null; i++ ) {=0A=
				if ( byElement && elem ) {=0A=
					j =3D 0;=0A=
					while ( (matcher =3D elementMatchers[j++]) ) {=0A=
						if ( matcher( elem, context, xml ) ) {=0A=
							results.push( elem );=0A=
							break;=0A=
						}=0A=
					}=0A=
					if ( outermost ) {=0A=
						dirruns =3D dirrunsUnique;=0A=
					}=0A=
				}=0A=
=0A=
				// Track unmatched elements for set filters=0A=
				if ( bySet ) {=0A=
					// They will have gone through all possible matchers=0A=
					if ( (elem =3D !matcher && elem) ) {=0A=
						matchedCount--;=0A=
					}=0A=
=0A=
					// Lengthen the array for every element, matched or not=0A=
					if ( seed ) {=0A=
						unmatched.push( elem );=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			// Apply set filters to unmatched elements=0A=
			matchedCount +=3D i;=0A=
			if ( bySet && i !=3D=3D matchedCount ) {=0A=
				j =3D 0;=0A=
				while ( (matcher =3D setMatchers[j++]) ) {=0A=
					matcher( unmatched, setMatched, context, xml );=0A=
				}=0A=
=0A=
				if ( seed ) {=0A=
					// Reintegrate element matches to eliminate the need for sorting=0A=
					if ( matchedCount > 0 ) {=0A=
						while ( i-- ) {=0A=
							if ( !(unmatched[i] || setMatched[i]) ) {=0A=
								setMatched[i] =3D pop.call( results );=0A=
							}=0A=
						}=0A=
					}=0A=
=0A=
					// Discard index placeholder values to get only actual matches=0A=
					setMatched =3D condense( setMatched );=0A=
				}=0A=
=0A=
				// Add matches to results=0A=
				push.apply( results, setMatched );=0A=
=0A=
				// Seedless set matches succeeding multiple successful matchers =
stipulate sorting=0A=
				if ( outermost && !seed && setMatched.length > 0 &&=0A=
					( matchedCount + setMatchers.length ) > 1 ) {=0A=
=0A=
					Sizzle.uniqueSort( results );=0A=
				}=0A=
			}=0A=
=0A=
			// Override manipulation of globals by nested matchers=0A=
			if ( outermost ) {=0A=
				dirruns =3D dirrunsUnique;=0A=
				outermostContext =3D contextBackup;=0A=
			}=0A=
=0A=
			return unmatched;=0A=
		};=0A=
=0A=
	return bySet ?=0A=
		markFunction( superMatcher ) :=0A=
		superMatcher;=0A=
}=0A=
=0A=
compile =3D Sizzle.compile =3D function( selector, match /* Internal Use =
Only */ ) {=0A=
	var i,=0A=
		setMatchers =3D [],=0A=
		elementMatchers =3D [],=0A=
		cached =3D compilerCache[ selector + " " ];=0A=
=0A=
	if ( !cached ) {=0A=
		// Generate a function of recursive functions that can be used to =
check each element=0A=
		if ( !match ) {=0A=
			match =3D tokenize( selector );=0A=
		}=0A=
		i =3D match.length;=0A=
		while ( i-- ) {=0A=
			cached =3D matcherFromTokens( match[i] );=0A=
			if ( cached[ expando ] ) {=0A=
				setMatchers.push( cached );=0A=
			} else {=0A=
				elementMatchers.push( cached );=0A=
			}=0A=
		}=0A=
=0A=
		// Cache the compiled function=0A=
		cached =3D compilerCache( selector, matcherFromGroupMatchers( =
elementMatchers, setMatchers ) );=0A=
=0A=
		// Save selector and tokenization=0A=
		cached.selector =3D selector;=0A=
	}=0A=
	return cached;=0A=
};=0A=
=0A=
/**=0A=
 * A low-level selection function that works with Sizzle's compiled=0A=
 *  selector functions=0A=
 * @param {String|Function} selector A selector or a pre-compiled=0A=
 *  selector function built with Sizzle.compile=0A=
 * @param {Element} context=0A=
 * @param {Array} [results]=0A=
 * @param {Array} [seed] A set of elements to match against=0A=
 */=0A=
select =3D Sizzle.select =3D function( selector, context, results, seed =
) {=0A=
	var i, tokens, token, type, find,=0A=
		compiled =3D typeof selector =3D=3D=3D "function" && selector,=0A=
		match =3D !seed && tokenize( (selector =3D compiled.selector || =
selector) );=0A=
=0A=
	results =3D results || [];=0A=
=0A=
	// Try to minimize operations if there is no seed and only one group=0A=
	if ( match.length =3D=3D=3D 1 ) {=0A=
=0A=
		// Take a shortcut and set the context if the root selector is an ID=0A=
		tokens =3D match[0] =3D match[0].slice( 0 );=0A=
		if ( tokens.length > 2 && (token =3D tokens[0]).type =3D=3D=3D "ID" &&=0A=
				support.getById && context.nodeType =3D=3D=3D 9 && documentIsHTML &&=0A=
				Expr.relative[ tokens[1].type ] ) {=0A=
=0A=
			context =3D ( Expr.find["ID"]( token.matches[0].replace(runescape, =
funescape), context ) || [] )[0];=0A=
			if ( !context ) {=0A=
				return results;=0A=
=0A=
			// Precompiled matchers will still verify ancestry, so step up a level=0A=
			} else if ( compiled ) {=0A=
				context =3D context.parentNode;=0A=
			}=0A=
=0A=
			selector =3D selector.slice( tokens.shift().value.length );=0A=
		}=0A=
=0A=
		// Fetch a seed set for right-to-left matching=0A=
		i =3D matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;=0A=
		while ( i-- ) {=0A=
			token =3D tokens[i];=0A=
=0A=
			// Abort if we hit a combinator=0A=
			if ( Expr.relative[ (type =3D token.type) ] ) {=0A=
				break;=0A=
			}=0A=
			if ( (find =3D Expr.find[ type ]) ) {=0A=
				// Search, expanding context for leading sibling combinators=0A=
				if ( (seed =3D find(=0A=
					token.matches[0].replace( runescape, funescape ),=0A=
					rsibling.test( tokens[0].type ) && testContext( context.parentNode =
) || context=0A=
				)) ) {=0A=
=0A=
					// If seed is empty or no tokens remain, we can return early=0A=
					tokens.splice( i, 1 );=0A=
					selector =3D seed.length && toSelector( tokens );=0A=
					if ( !selector ) {=0A=
						push.apply( results, seed );=0A=
						return results;=0A=
					}=0A=
=0A=
					break;=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	// Compile and execute a filtering function if one is not provided=0A=
	// Provide `match` to avoid retokenization if we modified the selector =
above=0A=
	( compiled || compile( selector, match ) )(=0A=
		seed,=0A=
		context,=0A=
		!documentIsHTML,=0A=
		results,=0A=
		rsibling.test( selector ) && testContext( context.parentNode ) || =
context=0A=
	);=0A=
	return results;=0A=
};=0A=
=0A=
// One-time assignments=0A=
=0A=
// Sort stability=0A=
support.sortStable =3D expando.split("").sort( sortOrder ).join("") =
=3D=3D=3D expando;=0A=
=0A=
// Support: Chrome 14-35+=0A=
// Always assume duplicates if they aren't passed to the comparison =
function=0A=
support.detectDuplicates =3D !!hasDuplicate;=0A=
=0A=
// Initialize against the default document=0A=
setDocument();=0A=
=0A=
// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)=0A=
// Detached nodes confoundingly follow *each other*=0A=
support.sortDetached =3D assert(function( div1 ) {=0A=
	// Should return 1, but returns 4 (following)=0A=
	return div1.compareDocumentPosition( document.createElement("div") ) & =
1;=0A=
});=0A=
=0A=
// Support: IE<8=0A=
// Prevent attribute/property "interpolation"=0A=
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx=0A=
if ( !assert(function( div ) {=0A=
	div.innerHTML =3D "<a href=3D'#'></a>";=0A=
	return div.firstChild.getAttribute("href") =3D=3D=3D "#" ;=0A=
}) ) {=0A=
	addHandle( "type|href|height|width", function( elem, name, isXML ) {=0A=
		if ( !isXML ) {=0A=
			return elem.getAttribute( name, name.toLowerCase() =3D=3D=3D "type" ? =
1 : 2 );=0A=
		}=0A=
	});=0A=
}=0A=
=0A=
// Support: IE<9=0A=
// Use defaultValue in place of getAttribute("value")=0A=
if ( !support.attributes || !assert(function( div ) {=0A=
	div.innerHTML =3D "<input/>";=0A=
	div.firstChild.setAttribute( "value", "" );=0A=
	return div.firstChild.getAttribute( "value" ) =3D=3D=3D "";=0A=
}) ) {=0A=
	addHandle( "value", function( elem, name, isXML ) {=0A=
		if ( !isXML && elem.nodeName.toLowerCase() =3D=3D=3D "input" ) {=0A=
			return elem.defaultValue;=0A=
		}=0A=
	});=0A=
}=0A=
=0A=
// Support: IE<9=0A=
// Use getAttributeNode to fetch booleans when getAttribute lies=0A=
if ( !assert(function( div ) {=0A=
	return div.getAttribute("disabled") =3D=3D null;=0A=
}) ) {=0A=
	addHandle( booleans, function( elem, name, isXML ) {=0A=
		var val;=0A=
		if ( !isXML ) {=0A=
			return elem[ name ] =3D=3D=3D true ? name.toLowerCase() :=0A=
					(val =3D elem.getAttributeNode( name )) && val.specified ?=0A=
					val.value :=0A=
				null;=0A=
		}=0A=
	});=0A=
}=0A=
=0A=
return Sizzle;=0A=
=0A=
})( window );=0A=
=0A=
=0A=
=0A=
jQuery.find =3D Sizzle;=0A=
jQuery.expr =3D Sizzle.selectors;=0A=
jQuery.expr[":"] =3D jQuery.expr.pseudos;=0A=
jQuery.unique =3D Sizzle.uniqueSort;=0A=
jQuery.text =3D Sizzle.getText;=0A=
jQuery.isXMLDoc =3D Sizzle.isXML;=0A=
jQuery.contains =3D Sizzle.contains;=0A=
=0A=
=0A=
=0A=
var rneedsContext =3D jQuery.expr.match.needsContext;=0A=
=0A=
var rsingleTag =3D (/^<(\w+)\s*\/?>(?:<\/\1>|)$/);=0A=
=0A=
=0A=
=0A=
var risSimple =3D /^.[^:#\[\.,]*$/;=0A=
=0A=
// Implement the identical functionality for filter and not=0A=
function winnow( elements, qualifier, not ) {=0A=
	if ( jQuery.isFunction( qualifier ) ) {=0A=
		return jQuery.grep( elements, function( elem, i ) {=0A=
			/* jshint -W018 */=0A=
			return !!qualifier.call( elem, i, elem ) !=3D=3D not;=0A=
		});=0A=
=0A=
	}=0A=
=0A=
	if ( qualifier.nodeType ) {=0A=
		return jQuery.grep( elements, function( elem ) {=0A=
			return ( elem =3D=3D=3D qualifier ) !=3D=3D not;=0A=
		});=0A=
=0A=
	}=0A=
=0A=
	if ( typeof qualifier =3D=3D=3D "string" ) {=0A=
		if ( risSimple.test( qualifier ) ) {=0A=
			return jQuery.filter( qualifier, elements, not );=0A=
		}=0A=
=0A=
		qualifier =3D jQuery.filter( qualifier, elements );=0A=
	}=0A=
=0A=
	return jQuery.grep( elements, function( elem ) {=0A=
		return ( jQuery.inArray( elem, qualifier ) >=3D 0 ) !=3D=3D not;=0A=
	});=0A=
}=0A=
=0A=
jQuery.filter =3D function( expr, elems, not ) {=0A=
	var elem =3D elems[ 0 ];=0A=
=0A=
	if ( not ) {=0A=
		expr =3D ":not(" + expr + ")";=0A=
	}=0A=
=0A=
	return elems.length =3D=3D=3D 1 && elem.nodeType =3D=3D=3D 1 ?=0A=
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :=0A=
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {=0A=
			return elem.nodeType =3D=3D=3D 1;=0A=
		}));=0A=
};=0A=
=0A=
jQuery.fn.extend({=0A=
	find: function( selector ) {=0A=
		var i,=0A=
			ret =3D [],=0A=
			self =3D this,=0A=
			len =3D self.length;=0A=
=0A=
		if ( typeof selector !=3D=3D "string" ) {=0A=
			return this.pushStack( jQuery( selector ).filter(function() {=0A=
				for ( i =3D 0; i < len; i++ ) {=0A=
					if ( jQuery.contains( self[ i ], this ) ) {=0A=
						return true;=0A=
					}=0A=
				}=0A=
			}) );=0A=
		}=0A=
=0A=
		for ( i =3D 0; i < len; i++ ) {=0A=
			jQuery.find( selector, self[ i ], ret );=0A=
		}=0A=
=0A=
		// Needed because $( selector, context ) becomes $( context ).find( =
selector )=0A=
		ret =3D this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );=0A=
		ret.selector =3D this.selector ? this.selector + " " + selector : =
selector;=0A=
		return ret;=0A=
	},=0A=
	filter: function( selector ) {=0A=
		return this.pushStack( winnow(this, selector || [], false) );=0A=
	},=0A=
	not: function( selector ) {=0A=
		return this.pushStack( winnow(this, selector || [], true) );=0A=
	},=0A=
	is: function( selector ) {=0A=
		return !!winnow(=0A=
			this,=0A=
=0A=
			// If this is a positional/relative selector, check membership in the =
returned set=0A=
			// so $("p:first").is("p:last") won't return true for a doc with two =
"p".=0A=
			typeof selector =3D=3D=3D "string" && rneedsContext.test( selector ) ?=0A=
				jQuery( selector ) :=0A=
				selector || [],=0A=
			false=0A=
		).length;=0A=
	}=0A=
});=0A=
=0A=
=0A=
// Initialize a jQuery object=0A=
=0A=
=0A=
// A central reference to the root jQuery(document)=0A=
var rootjQuery,=0A=
=0A=
	// Use the correct document accordingly with window argument (sandbox)=0A=
	document =3D window.document,=0A=
=0A=
	// A simple way to check for HTML strings=0A=
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)=0A=
	// Strict HTML recognition (#11290: must start with <)=0A=
	rquickExpr =3D /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,=0A=
=0A=
	init =3D jQuery.fn.init =3D function( selector, context ) {=0A=
		var match, elem;=0A=
=0A=
		// HANDLE: $(""), $(null), $(undefined), $(false)=0A=
		if ( !selector ) {=0A=
			return this;=0A=
		}=0A=
=0A=
		// Handle HTML strings=0A=
		if ( typeof selector =3D=3D=3D "string" ) {=0A=
			if ( selector.charAt(0) =3D=3D=3D "<" && selector.charAt( =
selector.length - 1 ) =3D=3D=3D ">" && selector.length >=3D 3 ) {=0A=
				// Assume that strings that start and end with <> are HTML and skip =
the regex check=0A=
				match =3D [ null, selector, null ];=0A=
=0A=
			} else {=0A=
				match =3D rquickExpr.exec( selector );=0A=
			}=0A=
=0A=
			// Match html or make sure no context is specified for #id=0A=
			if ( match && (match[1] || !context) ) {=0A=
=0A=
				// HANDLE: $(html) -> $(array)=0A=
				if ( match[1] ) {=0A=
					context =3D context instanceof jQuery ? context[0] : context;=0A=
=0A=
					// scripts is true for back-compat=0A=
					// Intentionally let the error be thrown if parseHTML is not present=0A=
					jQuery.merge( this, jQuery.parseHTML(=0A=
						match[1],=0A=
						context && context.nodeType ? context.ownerDocument || context : =
document,=0A=
						true=0A=
					) );=0A=
=0A=
					// HANDLE: $(html, props)=0A=
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) =
) {=0A=
						for ( match in context ) {=0A=
							// Properties of context are called as methods if possible=0A=
							if ( jQuery.isFunction( this[ match ] ) ) {=0A=
								this[ match ]( context[ match ] );=0A=
=0A=
							// ...and otherwise set as attributes=0A=
							} else {=0A=
								this.attr( match, context[ match ] );=0A=
							}=0A=
						}=0A=
					}=0A=
=0A=
					return this;=0A=
=0A=
				// HANDLE: $(#id)=0A=
				} else {=0A=
					elem =3D document.getElementById( match[2] );=0A=
=0A=
					// Check parentNode to catch when Blackberry 4.6 returns=0A=
					// nodes that are no longer in the document #6963=0A=
					if ( elem && elem.parentNode ) {=0A=
						// Handle the case where IE and Opera return items=0A=
						// by name instead of ID=0A=
						if ( elem.id !=3D=3D match[2] ) {=0A=
							return rootjQuery.find( selector );=0A=
						}=0A=
=0A=
						// Otherwise, we inject the element directly into the jQuery object=0A=
						this.length =3D 1;=0A=
						this[0] =3D elem;=0A=
					}=0A=
=0A=
					this.context =3D document;=0A=
					this.selector =3D selector;=0A=
					return this;=0A=
				}=0A=
=0A=
			// HANDLE: $(expr, $(...))=0A=
			} else if ( !context || context.jquery ) {=0A=
				return ( context || rootjQuery ).find( selector );=0A=
=0A=
			// HANDLE: $(expr, context)=0A=
			// (which is just equivalent to: $(context).find(expr)=0A=
			} else {=0A=
				return this.constructor( context ).find( selector );=0A=
			}=0A=
=0A=
		// HANDLE: $(DOMElement)=0A=
		} else if ( selector.nodeType ) {=0A=
			this.context =3D this[0] =3D selector;=0A=
			this.length =3D 1;=0A=
			return this;=0A=
=0A=
		// HANDLE: $(function)=0A=
		// Shortcut for document ready=0A=
		} else if ( jQuery.isFunction( selector ) ) {=0A=
			return typeof rootjQuery.ready !=3D=3D "undefined" ?=0A=
				rootjQuery.ready( selector ) :=0A=
				// Execute immediately if ready is not present=0A=
				selector( jQuery );=0A=
		}=0A=
=0A=
		if ( selector.selector !=3D=3D undefined ) {=0A=
			this.selector =3D selector.selector;=0A=
			this.context =3D selector.context;=0A=
		}=0A=
=0A=
		return jQuery.makeArray( selector, this );=0A=
	};=0A=
=0A=
// Give the init function the jQuery prototype for later instantiation=0A=
init.prototype =3D jQuery.fn;=0A=
=0A=
// Initialize central reference=0A=
rootjQuery =3D jQuery( document );=0A=
=0A=
=0A=
var rparentsprev =3D /^(?:parents|prev(?:Until|All))/,=0A=
	// methods guaranteed to produce a unique set when starting from a =
unique set=0A=
	guaranteedUnique =3D {=0A=
		children: true,=0A=
		contents: true,=0A=
		next: true,=0A=
		prev: true=0A=
	};=0A=
=0A=
jQuery.extend({=0A=
	dir: function( elem, dir, until ) {=0A=
		var matched =3D [],=0A=
			cur =3D elem[ dir ];=0A=
=0A=
		while ( cur && cur.nodeType !=3D=3D 9 && (until =3D=3D=3D undefined || =
cur.nodeType !=3D=3D 1 || !jQuery( cur ).is( until )) ) {=0A=
			if ( cur.nodeType =3D=3D=3D 1 ) {=0A=
				matched.push( cur );=0A=
			}=0A=
			cur =3D cur[dir];=0A=
		}=0A=
		return matched;=0A=
	},=0A=
=0A=
	sibling: function( n, elem ) {=0A=
		var r =3D [];=0A=
=0A=
		for ( ; n; n =3D n.nextSibling ) {=0A=
			if ( n.nodeType =3D=3D=3D 1 && n !=3D=3D elem ) {=0A=
				r.push( n );=0A=
			}=0A=
		}=0A=
=0A=
		return r;=0A=
	}=0A=
});=0A=
=0A=
jQuery.fn.extend({=0A=
	has: function( target ) {=0A=
		var i,=0A=
			targets =3D jQuery( target, this ),=0A=
			len =3D targets.length;=0A=
=0A=
		return this.filter(function() {=0A=
			for ( i =3D 0; i < len; i++ ) {=0A=
				if ( jQuery.contains( this, targets[i] ) ) {=0A=
					return true;=0A=
				}=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	closest: function( selectors, context ) {=0A=
		var cur,=0A=
			i =3D 0,=0A=
			l =3D this.length,=0A=
			matched =3D [],=0A=
			pos =3D rneedsContext.test( selectors ) || typeof selectors !=3D=3D =
"string" ?=0A=
				jQuery( selectors, context || this.context ) :=0A=
				0;=0A=
=0A=
		for ( ; i < l; i++ ) {=0A=
			for ( cur =3D this[i]; cur && cur !=3D=3D context; cur =3D =
cur.parentNode ) {=0A=
				// Always skip document fragments=0A=
				if ( cur.nodeType < 11 && (pos ?=0A=
					pos.index(cur) > -1 :=0A=
=0A=
					// Don't pass non-elements to Sizzle=0A=
					cur.nodeType =3D=3D=3D 1 &&=0A=
						jQuery.find.matchesSelector(cur, selectors)) ) {=0A=
=0A=
					matched.push( cur );=0A=
					break;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return this.pushStack( matched.length > 1 ? jQuery.unique( matched ) : =
matched );=0A=
	},=0A=
=0A=
	// Determine the position of an element within=0A=
	// the matched set of elements=0A=
	index: function( elem ) {=0A=
=0A=
		// No argument, return index in parent=0A=
		if ( !elem ) {=0A=
			return ( this[0] && this[0].parentNode ) ? =
this.first().prevAll().length : -1;=0A=
		}=0A=
=0A=
		// index in selector=0A=
		if ( typeof elem =3D=3D=3D "string" ) {=0A=
			return jQuery.inArray( this[0], jQuery( elem ) );=0A=
		}=0A=
=0A=
		// Locate the position of the desired element=0A=
		return jQuery.inArray(=0A=
			// If it receives a jQuery object, the first element is used=0A=
			elem.jquery ? elem[0] : elem, this );=0A=
	},=0A=
=0A=
	add: function( selector, context ) {=0A=
		return this.pushStack(=0A=
			jQuery.unique(=0A=
				jQuery.merge( this.get(), jQuery( selector, context ) )=0A=
			)=0A=
		);=0A=
	},=0A=
=0A=
	addBack: function( selector ) {=0A=
		return this.add( selector =3D=3D null ?=0A=
			this.prevObject : this.prevObject.filter(selector)=0A=
		);=0A=
	}=0A=
});=0A=
=0A=
function sibling( cur, dir ) {=0A=
	do {=0A=
		cur =3D cur[ dir ];=0A=
	} while ( cur && cur.nodeType !=3D=3D 1 );=0A=
=0A=
	return cur;=0A=
}=0A=
=0A=
jQuery.each({=0A=
	parent: function( elem ) {=0A=
		var parent =3D elem.parentNode;=0A=
		return parent && parent.nodeType !=3D=3D 11 ? parent : null;=0A=
	},=0A=
	parents: function( elem ) {=0A=
		return jQuery.dir( elem, "parentNode" );=0A=
	},=0A=
	parentsUntil: function( elem, i, until ) {=0A=
		return jQuery.dir( elem, "parentNode", until );=0A=
	},=0A=
	next: function( elem ) {=0A=
		return sibling( elem, "nextSibling" );=0A=
	},=0A=
	prev: function( elem ) {=0A=
		return sibling( elem, "previousSibling" );=0A=
	},=0A=
	nextAll: function( elem ) {=0A=
		return jQuery.dir( elem, "nextSibling" );=0A=
	},=0A=
	prevAll: function( elem ) {=0A=
		return jQuery.dir( elem, "previousSibling" );=0A=
	},=0A=
	nextUntil: function( elem, i, until ) {=0A=
		return jQuery.dir( elem, "nextSibling", until );=0A=
	},=0A=
	prevUntil: function( elem, i, until ) {=0A=
		return jQuery.dir( elem, "previousSibling", until );=0A=
	},=0A=
	siblings: function( elem ) {=0A=
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );=0A=
	},=0A=
	children: function( elem ) {=0A=
		return jQuery.sibling( elem.firstChild );=0A=
	},=0A=
	contents: function( elem ) {=0A=
		return jQuery.nodeName( elem, "iframe" ) ?=0A=
			elem.contentDocument || elem.contentWindow.document :=0A=
			jQuery.merge( [], elem.childNodes );=0A=
	}=0A=
}, function( name, fn ) {=0A=
	jQuery.fn[ name ] =3D function( until, selector ) {=0A=
		var ret =3D jQuery.map( this, fn, until );=0A=
=0A=
		if ( name.slice( -5 ) !=3D=3D "Until" ) {=0A=
			selector =3D until;=0A=
		}=0A=
=0A=
		if ( selector && typeof selector =3D=3D=3D "string" ) {=0A=
			ret =3D jQuery.filter( selector, ret );=0A=
		}=0A=
=0A=
		if ( this.length > 1 ) {=0A=
			// Remove duplicates=0A=
			if ( !guaranteedUnique[ name ] ) {=0A=
				ret =3D jQuery.unique( ret );=0A=
			}=0A=
=0A=
			// Reverse order for parents* and prev-derivatives=0A=
			if ( rparentsprev.test( name ) ) {=0A=
				ret =3D ret.reverse();=0A=
			}=0A=
		}=0A=
=0A=
		return this.pushStack( ret );=0A=
	};=0A=
});=0A=
var rnotwhite =3D (/\S+/g);=0A=
=0A=
=0A=
=0A=
// String to Object options format cache=0A=
var optionsCache =3D {};=0A=
=0A=
// Convert String-formatted options into Object-formatted ones and store =
in cache=0A=
function createOptions( options ) {=0A=
	var object =3D optionsCache[ options ] =3D {};=0A=
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {=0A=
		object[ flag ] =3D true;=0A=
	});=0A=
	return object;=0A=
}=0A=
=0A=
/*=0A=
 * Create a callback list using the following parameters:=0A=
 *=0A=
 *	options: an optional list of space-separated options that will change =
how=0A=
 *			the callback list behaves or a more traditional option object=0A=
 *=0A=
 * By default a callback list will act like an event callback list and =
can be=0A=
 * "fired" multiple times.=0A=
 *=0A=
 * Possible options:=0A=
 *=0A=
 *	once:			will ensure the callback list can only be fired once (like a =
Deferred)=0A=
 *=0A=
 *	memory:			will keep track of previous values and will call any =
callback added=0A=
 *					after the list has been fired right away with the latest =
"memorized"=0A=
 *					values (like a Deferred)=0A=
 *=0A=
 *	unique:			will ensure a callback can only be added once (no duplicate =
in the list)=0A=
 *=0A=
 *	stopOnFalse:	interrupt callings when a callback returns false=0A=
 *=0A=
 */=0A=
jQuery.Callbacks =3D function( options ) {=0A=
=0A=
	// Convert options from String-formatted to Object-formatted if needed=0A=
	// (we check in cache first)=0A=
	options =3D typeof options =3D=3D=3D "string" ?=0A=
		( optionsCache[ options ] || createOptions( options ) ) :=0A=
		jQuery.extend( {}, options );=0A=
=0A=
	var // Flag to know if list is currently firing=0A=
		firing,=0A=
		// Last fire value (for non-forgettable lists)=0A=
		memory,=0A=
		// Flag to know if list was already fired=0A=
		fired,=0A=
		// End of the loop when firing=0A=
		firingLength,=0A=
		// Index of currently firing callback (modified by remove if needed)=0A=
		firingIndex,=0A=
		// First callback to fire (used internally by add and fireWith)=0A=
		firingStart,=0A=
		// Actual callback list=0A=
		list =3D [],=0A=
		// Stack of fire calls for repeatable lists=0A=
		stack =3D !options.once && [],=0A=
		// Fire callbacks=0A=
		fire =3D function( data ) {=0A=
			memory =3D options.memory && data;=0A=
			fired =3D true;=0A=
			firingIndex =3D firingStart || 0;=0A=
			firingStart =3D 0;=0A=
			firingLength =3D list.length;=0A=
			firing =3D true;=0A=
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {=0A=
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) =3D=3D=3D =
false && options.stopOnFalse ) {=0A=
					memory =3D false; // To prevent further calls using add=0A=
					break;=0A=
				}=0A=
			}=0A=
			firing =3D false;=0A=
			if ( list ) {=0A=
				if ( stack ) {=0A=
					if ( stack.length ) {=0A=
						fire( stack.shift() );=0A=
					}=0A=
				} else if ( memory ) {=0A=
					list =3D [];=0A=
				} else {=0A=
					self.disable();=0A=
				}=0A=
			}=0A=
		},=0A=
		// Actual Callbacks object=0A=
		self =3D {=0A=
			// Add a callback or a collection of callbacks to the list=0A=
			add: function() {=0A=
				if ( list ) {=0A=
					// First, we save the current length=0A=
					var start =3D list.length;=0A=
					(function add( args ) {=0A=
						jQuery.each( args, function( _, arg ) {=0A=
							var type =3D jQuery.type( arg );=0A=
							if ( type =3D=3D=3D "function" ) {=0A=
								if ( !options.unique || !self.has( arg ) ) {=0A=
									list.push( arg );=0A=
								}=0A=
							} else if ( arg && arg.length && type !=3D=3D "string" ) {=0A=
								// Inspect recursively=0A=
								add( arg );=0A=
							}=0A=
						});=0A=
					})( arguments );=0A=
					// Do we need to add the callbacks to the=0A=
					// current firing batch?=0A=
					if ( firing ) {=0A=
						firingLength =3D list.length;=0A=
					// With memory, if we're not firing then=0A=
					// we should call right away=0A=
					} else if ( memory ) {=0A=
						firingStart =3D start;=0A=
						fire( memory );=0A=
					}=0A=
				}=0A=
				return this;=0A=
			},=0A=
			// Remove a callback from the list=0A=
			remove: function() {=0A=
				if ( list ) {=0A=
					jQuery.each( arguments, function( _, arg ) {=0A=
						var index;=0A=
						while ( ( index =3D jQuery.inArray( arg, list, index ) ) > -1 ) {=0A=
							list.splice( index, 1 );=0A=
							// Handle firing indexes=0A=
							if ( firing ) {=0A=
								if ( index <=3D firingLength ) {=0A=
									firingLength--;=0A=
								}=0A=
								if ( index <=3D firingIndex ) {=0A=
									firingIndex--;=0A=
								}=0A=
							}=0A=
						}=0A=
					});=0A=
				}=0A=
				return this;=0A=
			},=0A=
			// Check if a given callback is in the list.=0A=
			// If no argument is given, return whether or not list has callbacks =
attached.=0A=
			has: function( fn ) {=0A=
				return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && =
list.length );=0A=
			},=0A=
			// Remove all callbacks from the list=0A=
			empty: function() {=0A=
				list =3D [];=0A=
				firingLength =3D 0;=0A=
				return this;=0A=
			},=0A=
			// Have the list do nothing anymore=0A=
			disable: function() {=0A=
				list =3D stack =3D memory =3D undefined;=0A=
				return this;=0A=
			},=0A=
			// Is it disabled?=0A=
			disabled: function() {=0A=
				return !list;=0A=
			},=0A=
			// Lock the list in its current state=0A=
			lock: function() {=0A=
				stack =3D undefined;=0A=
				if ( !memory ) {=0A=
					self.disable();=0A=
				}=0A=
				return this;=0A=
			},=0A=
			// Is it locked?=0A=
			locked: function() {=0A=
				return !stack;=0A=
			},=0A=
			// Call all callbacks with the given context and arguments=0A=
			fireWith: function( context, args ) {=0A=
				if ( list && ( !fired || stack ) ) {=0A=
					args =3D args || [];=0A=
					args =3D [ context, args.slice ? args.slice() : args ];=0A=
					if ( firing ) {=0A=
						stack.push( args );=0A=
					} else {=0A=
						fire( args );=0A=
					}=0A=
				}=0A=
				return this;=0A=
			},=0A=
			// Call all the callbacks with the given arguments=0A=
			fire: function() {=0A=
				self.fireWith( this, arguments );=0A=
				return this;=0A=
			},=0A=
			// To know if the callbacks have already been called at least once=0A=
			fired: function() {=0A=
				return !!fired;=0A=
			}=0A=
		};=0A=
=0A=
	return self;=0A=
};=0A=
=0A=
=0A=
jQuery.extend({=0A=
=0A=
	Deferred: function( func ) {=0A=
		var tuples =3D [=0A=
				// action, add listener, listener list, final state=0A=
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],=0A=
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],=0A=
				[ "notify", "progress", jQuery.Callbacks("memory") ]=0A=
			],=0A=
			state =3D "pending",=0A=
			promise =3D {=0A=
				state: function() {=0A=
					return state;=0A=
				},=0A=
				always: function() {=0A=
					deferred.done( arguments ).fail( arguments );=0A=
					return this;=0A=
				},=0A=
				then: function( /* fnDone, fnFail, fnProgress */ ) {=0A=
					var fns =3D arguments;=0A=
					return jQuery.Deferred(function( newDefer ) {=0A=
						jQuery.each( tuples, function( i, tuple ) {=0A=
							var fn =3D jQuery.isFunction( fns[ i ] ) && fns[ i ];=0A=
							// deferred[ done | fail | progress ] for forwarding actions to =
newDefer=0A=
							deferred[ tuple[1] ](function() {=0A=
								var returned =3D fn && fn.apply( this, arguments );=0A=
								if ( returned && jQuery.isFunction( returned.promise ) ) {=0A=
									returned.promise()=0A=
										.done( newDefer.resolve )=0A=
										.fail( newDefer.reject )=0A=
										.progress( newDefer.notify );=0A=
								} else {=0A=
									newDefer[ tuple[ 0 ] + "With" ]( this =3D=3D=3D promise ? =
newDefer.promise() : this, fn ? [ returned ] : arguments );=0A=
								}=0A=
							});=0A=
						});=0A=
						fns =3D null;=0A=
					}).promise();=0A=
				},=0A=
				// Get a promise for this deferred=0A=
				// If obj is provided, the promise aspect is added to the object=0A=
				promise: function( obj ) {=0A=
					return obj !=3D null ? jQuery.extend( obj, promise ) : promise;=0A=
				}=0A=
			},=0A=
			deferred =3D {};=0A=
=0A=
		// Keep pipe for back-compat=0A=
		promise.pipe =3D promise.then;=0A=
=0A=
		// Add list-specific methods=0A=
		jQuery.each( tuples, function( i, tuple ) {=0A=
			var list =3D tuple[ 2 ],=0A=
				stateString =3D tuple[ 3 ];=0A=
=0A=
			// promise[ done | fail | progress ] =3D list.add=0A=
			promise[ tuple[1] ] =3D list.add;=0A=
=0A=
			// Handle state=0A=
			if ( stateString ) {=0A=
				list.add(function() {=0A=
					// state =3D [ resolved | rejected ]=0A=
					state =3D stateString;=0A=
=0A=
				// [ reject_list | resolve_list ].disable; progress_list.lock=0A=
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );=0A=
			}=0A=
=0A=
			// deferred[ resolve | reject | notify ]=0A=
			deferred[ tuple[0] ] =3D function() {=0A=
				deferred[ tuple[0] + "With" ]( this =3D=3D=3D deferred ? promise : =
this, arguments );=0A=
				return this;=0A=
			};=0A=
			deferred[ tuple[0] + "With" ] =3D list.fireWith;=0A=
		});=0A=
=0A=
		// Make the deferred a promise=0A=
		promise.promise( deferred );=0A=
=0A=
		// Call given func if any=0A=
		if ( func ) {=0A=
			func.call( deferred, deferred );=0A=
		}=0A=
=0A=
		// All done!=0A=
		return deferred;=0A=
	},=0A=
=0A=
	// Deferred helper=0A=
	when: function( subordinate /* , ..., subordinateN */ ) {=0A=
		var i =3D 0,=0A=
			resolveValues =3D slice.call( arguments ),=0A=
			length =3D resolveValues.length,=0A=
=0A=
			// the count of uncompleted subordinates=0A=
			remaining =3D length !=3D=3D 1 || ( subordinate && jQuery.isFunction( =
subordinate.promise ) ) ? length : 0,=0A=
=0A=
			// the master Deferred. If resolveValues consist of only a single =
Deferred, just use that.=0A=
			deferred =3D remaining =3D=3D=3D 1 ? subordinate : jQuery.Deferred(),=0A=
=0A=
			// Update function for both resolve and progress values=0A=
			updateFunc =3D function( i, contexts, values ) {=0A=
				return function( value ) {=0A=
					contexts[ i ] =3D this;=0A=
					values[ i ] =3D arguments.length > 1 ? slice.call( arguments ) : =
value;=0A=
					if ( values =3D=3D=3D progressValues ) {=0A=
						deferred.notifyWith( contexts, values );=0A=
=0A=
					} else if ( !(--remaining) ) {=0A=
						deferred.resolveWith( contexts, values );=0A=
					}=0A=
				};=0A=
			},=0A=
=0A=
			progressValues, progressContexts, resolveContexts;=0A=
=0A=
		// add listeners to Deferred subordinates; treat others as resolved=0A=
		if ( length > 1 ) {=0A=
			progressValues =3D new Array( length );=0A=
			progressContexts =3D new Array( length );=0A=
			resolveContexts =3D new Array( length );=0A=
			for ( ; i < length; i++ ) {=0A=
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i =
].promise ) ) {=0A=
					resolveValues[ i ].promise()=0A=
						.done( updateFunc( i, resolveContexts, resolveValues ) )=0A=
						.fail( deferred.reject )=0A=
						.progress( updateFunc( i, progressContexts, progressValues ) );=0A=
				} else {=0A=
					--remaining;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// if we're not waiting on anything, resolve the master=0A=
		if ( !remaining ) {=0A=
			deferred.resolveWith( resolveContexts, resolveValues );=0A=
		}=0A=
=0A=
		return deferred.promise();=0A=
	}=0A=
});=0A=
=0A=
=0A=
// The deferred used on DOM ready=0A=
var readyList;=0A=
=0A=
jQuery.fn.ready =3D function( fn ) {=0A=
	// Add the callback=0A=
	jQuery.ready.promise().done( fn );=0A=
=0A=
	return this;=0A=
};=0A=
=0A=
jQuery.extend({=0A=
	// Is the DOM ready to be used? Set to true once it occurs.=0A=
	isReady: false,=0A=
=0A=
	// A counter to track how many items to wait for before=0A=
	// the ready event fires. See #6781=0A=
	readyWait: 1,=0A=
=0A=
	// Hold (or release) the ready event=0A=
	holdReady: function( hold ) {=0A=
		if ( hold ) {=0A=
			jQuery.readyWait++;=0A=
		} else {=0A=
			jQuery.ready( true );=0A=
		}=0A=
	},=0A=
=0A=
	// Handle when the DOM is ready=0A=
	ready: function( wait ) {=0A=
=0A=
		// Abort if there are pending holds or we're already ready=0A=
		if ( wait =3D=3D=3D true ? --jQuery.readyWait : jQuery.isReady ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Make sure body exists, at least, in case IE gets a little =
overzealous (ticket #5443).=0A=
		if ( !document.body ) {=0A=
			return setTimeout( jQuery.ready );=0A=
		}=0A=
=0A=
		// Remember that the DOM is ready=0A=
		jQuery.isReady =3D true;=0A=
=0A=
		// If a normal DOM Ready event fired, decrement, and wait if need be=0A=
		if ( wait !=3D=3D true && --jQuery.readyWait > 0 ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// If there are functions bound, to execute=0A=
		readyList.resolveWith( document, [ jQuery ] );=0A=
=0A=
		// Trigger any bound ready events=0A=
		if ( jQuery.fn.triggerHandler ) {=0A=
			jQuery( document ).triggerHandler( "ready" );=0A=
			jQuery( document ).off( "ready" );=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
/**=0A=
 * Clean-up method for dom ready events=0A=
 */=0A=
function detach() {=0A=
	if ( document.addEventListener ) {=0A=
		document.removeEventListener( "DOMContentLoaded", completed, false );=0A=
		window.removeEventListener( "load", completed, false );=0A=
=0A=
	} else {=0A=
		document.detachEvent( "onreadystatechange", completed );=0A=
		window.detachEvent( "onload", completed );=0A=
	}=0A=
}=0A=
=0A=
/**=0A=
 * The ready event handler and self cleanup method=0A=
 */=0A=
function completed() {=0A=
	// readyState =3D=3D=3D "complete" is good enough for us to call the =
dom ready in oldIE=0A=
	if ( document.addEventListener || event.type =3D=3D=3D "load" || =
document.readyState =3D=3D=3D "complete" ) {=0A=
		detach();=0A=
		jQuery.ready();=0A=
	}=0A=
}=0A=
=0A=
jQuery.ready.promise =3D function( obj ) {=0A=
	if ( !readyList ) {=0A=
=0A=
		readyList =3D jQuery.Deferred();=0A=
=0A=
		// Catch cases where $(document).ready() is called after the browser =
event has already occurred.=0A=
		// we once tried to use readyState "interactive" here, but it caused =
issues like the one=0A=
		// discovered by ChrisS here: =
http://bugs.jquery.com/ticket/12282#comment:15=0A=
		if ( document.readyState =3D=3D=3D "complete" ) {=0A=
			// Handle it asynchronously to allow scripts the opportunity to delay =
ready=0A=
			setTimeout( jQuery.ready );=0A=
=0A=
		// Standards-based browsers support DOMContentLoaded=0A=
		} else if ( document.addEventListener ) {=0A=
			// Use the handy event callback=0A=
			document.addEventListener( "DOMContentLoaded", completed, false );=0A=
=0A=
			// A fallback to window.onload, that will always work=0A=
			window.addEventListener( "load", completed, false );=0A=
=0A=
		// If IE event model is used=0A=
		} else {=0A=
			// Ensure firing before onload, maybe late but safe also for iframes=0A=
			document.attachEvent( "onreadystatechange", completed );=0A=
=0A=
			// A fallback to window.onload, that will always work=0A=
			window.attachEvent( "onload", completed );=0A=
=0A=
			// If IE and not a frame=0A=
			// continually check to see if the document is ready=0A=
			var top =3D false;=0A=
=0A=
			try {=0A=
				top =3D window.frameElement =3D=3D null && document.documentElement;=0A=
			} catch(e) {}=0A=
=0A=
			if ( top && top.doScroll ) {=0A=
				(function doScrollCheck() {=0A=
					if ( !jQuery.isReady ) {=0A=
=0A=
						try {=0A=
							// Use the trick by Diego Perini=0A=
							// http://javascript.nwbox.com/IEContentLoaded/=0A=
							top.doScroll("left");=0A=
						} catch(e) {=0A=
							return setTimeout( doScrollCheck, 50 );=0A=
						}=0A=
=0A=
						// detach all dom ready events=0A=
						detach();=0A=
=0A=
						// and execute any waiting functions=0A=
						jQuery.ready();=0A=
					}=0A=
				})();=0A=
			}=0A=
		}=0A=
	}=0A=
	return readyList.promise( obj );=0A=
};=0A=
=0A=
=0A=
var strundefined =3D typeof undefined;=0A=
=0A=
=0A=
=0A=
// Support: IE<9=0A=
// Iteration over object's inherited properties before its own=0A=
var i;=0A=
for ( i in jQuery( support ) ) {=0A=
	break;=0A=
}=0A=
support.ownLast =3D i !=3D=3D "0";=0A=
=0A=
// Note: most support tests are defined in their respective modules.=0A=
// false until the test is run=0A=
support.inlineBlockNeedsLayout =3D false;=0A=
=0A=
// Execute ASAP in case we need to set body.style.zoom=0A=
jQuery(function() {=0A=
	// Minified: var a,b,c,d=0A=
	var val, div, body, container;=0A=
=0A=
	body =3D document.getElementsByTagName( "body" )[ 0 ];=0A=
	if ( !body || !body.style ) {=0A=
		// Return for frameset docs that don't have a body=0A=
		return;=0A=
	}=0A=
=0A=
	// Setup=0A=
	div =3D document.createElement( "div" );=0A=
	container =3D document.createElement( "div" );=0A=
	container.style.cssText =3D =
"position:absolute;border:0;width:0;height:0;top:0;left:-9999px";=0A=
	body.appendChild( container ).appendChild( div );=0A=
=0A=
	if ( typeof div.style.zoom !=3D=3D strundefined ) {=0A=
		// Support: IE<8=0A=
		// Check if natively block-level elements act like inline-block=0A=
		// elements when setting their display to 'inline' and giving=0A=
		// them layout=0A=
		div.style.cssText =3D =
"display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1";=0A=
=0A=
		support.inlineBlockNeedsLayout =3D val =3D div.offsetWidth =3D=3D=3D 3;=0A=
		if ( val ) {=0A=
			// Prevent IE 6 from affecting layout for positioned elements #11048=0A=
			// Prevent IE from shrinking the body in IE 7 mode #12869=0A=
			// Support: IE<8=0A=
			body.style.zoom =3D 1;=0A=
		}=0A=
	}=0A=
=0A=
	body.removeChild( container );=0A=
});=0A=
=0A=
=0A=
=0A=
=0A=
(function() {=0A=
	var div =3D document.createElement( "div" );=0A=
=0A=
	// Execute the test only if not already executed in another module.=0A=
	if (support.deleteExpando =3D=3D null) {=0A=
		// Support: IE<9=0A=
		support.deleteExpando =3D true;=0A=
		try {=0A=
			delete div.test;=0A=
		} catch( e ) {=0A=
			support.deleteExpando =3D false;=0A=
		}=0A=
	}=0A=
=0A=
	// Null elements to avoid leaks in IE.=0A=
	div =3D null;=0A=
})();=0A=
=0A=
=0A=
/**=0A=
 * Determines whether an object can have data=0A=
 */=0A=
jQuery.acceptData =3D function( elem ) {=0A=
	var noData =3D jQuery.noData[ (elem.nodeName + " ").toLowerCase() ],=0A=
		nodeType =3D +elem.nodeType || 1;=0A=
=0A=
	// Do not set data on non-element DOM nodes because it will not be =
cleared (#8335).=0A=
	return nodeType !=3D=3D 1 && nodeType !=3D=3D 9 ?=0A=
		false :=0A=
=0A=
		// Nodes accept data unless otherwise specified; rejection can be =
conditional=0A=
		!noData || noData !=3D=3D true && elem.getAttribute("classid") =
=3D=3D=3D noData;=0A=
};=0A=
=0A=
=0A=
var rbrace =3D /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,=0A=
	rmultiDash =3D /([A-Z])/g;=0A=
=0A=
function dataAttr( elem, key, data ) {=0A=
	// If nothing was found internally, try to fetch any=0A=
	// data from the HTML5 data-* attribute=0A=
	if ( data =3D=3D=3D undefined && elem.nodeType =3D=3D=3D 1 ) {=0A=
=0A=
		var name =3D "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();=0A=
=0A=
		data =3D elem.getAttribute( name );=0A=
=0A=
		if ( typeof data =3D=3D=3D "string" ) {=0A=
			try {=0A=
				data =3D data =3D=3D=3D "true" ? true :=0A=
					data =3D=3D=3D "false" ? false :=0A=
					data =3D=3D=3D "null" ? null :=0A=
					// Only convert to a number if it doesn't change the string=0A=
					+data + "" =3D=3D=3D data ? +data :=0A=
					rbrace.test( data ) ? jQuery.parseJSON( data ) :=0A=
					data;=0A=
			} catch( e ) {}=0A=
=0A=
			// Make sure we set the data so it isn't changed later=0A=
			jQuery.data( elem, key, data );=0A=
=0A=
		} else {=0A=
			data =3D undefined;=0A=
		}=0A=
	}=0A=
=0A=
	return data;=0A=
}=0A=
=0A=
// checks a cache object for emptiness=0A=
function isEmptyDataObject( obj ) {=0A=
	var name;=0A=
	for ( name in obj ) {=0A=
=0A=
		// if the public data object is empty, the private is still empty=0A=
		if ( name =3D=3D=3D "data" && jQuery.isEmptyObject( obj[name] ) ) {=0A=
			continue;=0A=
		}=0A=
		if ( name !=3D=3D "toJSON" ) {=0A=
			return false;=0A=
		}=0A=
	}=0A=
=0A=
	return true;=0A=
}=0A=
=0A=
function internalData( elem, name, data, pvt /* Internal Use Only */ ) {=0A=
	if ( !jQuery.acceptData( elem ) ) {=0A=
		return;=0A=
	}=0A=
=0A=
	var ret, thisCache,=0A=
		internalKey =3D jQuery.expando,=0A=
=0A=
		// We have to handle DOM nodes and JS objects differently because IE6-7=0A=
		// can't GC object references properly across the DOM-JS boundary=0A=
		isNode =3D elem.nodeType,=0A=
=0A=
		// Only DOM nodes need the global jQuery cache; JS object data is=0A=
		// attached directly to the object so GC can occur automatically=0A=
		cache =3D isNode ? jQuery.cache : elem,=0A=
=0A=
		// Only defining an ID for JS objects if its cache already exists =
allows=0A=
		// the code to shortcut on the same path as a DOM node with no cache=0A=
		id =3D isNode ? elem[ internalKey ] : elem[ internalKey ] && =
internalKey;=0A=
=0A=
	// Avoid doing any more work than we need to when trying to get data on =
an=0A=
	// object that has no data at all=0A=
	if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data =3D=3D=3D =
undefined && typeof name =3D=3D=3D "string" ) {=0A=
		return;=0A=
	}=0A=
=0A=
	if ( !id ) {=0A=
		// Only DOM nodes need a new unique ID for each element since their =
data=0A=
		// ends up in the global cache=0A=
		if ( isNode ) {=0A=
			id =3D elem[ internalKey ] =3D deletedIds.pop() || jQuery.guid++;=0A=
		} else {=0A=
			id =3D internalKey;=0A=
		}=0A=
	}=0A=
=0A=
	if ( !cache[ id ] ) {=0A=
		// Avoid exposing jQuery metadata on plain JS objects when the object=0A=
		// is serialized using JSON.stringify=0A=
		cache[ id ] =3D isNode ? {} : { toJSON: jQuery.noop };=0A=
	}=0A=
=0A=
	// An object can be passed to jQuery.data instead of a key/value pair; =
this gets=0A=
	// shallow copied over onto the existing cache=0A=
	if ( typeof name =3D=3D=3D "object" || typeof name =3D=3D=3D "function" =
) {=0A=
		if ( pvt ) {=0A=
			cache[ id ] =3D jQuery.extend( cache[ id ], name );=0A=
		} else {=0A=
			cache[ id ].data =3D jQuery.extend( cache[ id ].data, name );=0A=
		}=0A=
	}=0A=
=0A=
	thisCache =3D cache[ id ];=0A=
=0A=
	// jQuery data() is stored in a separate object inside the object's =
internal data=0A=
	// cache in order to avoid key collisions between internal data and =
user-defined=0A=
	// data.=0A=
	if ( !pvt ) {=0A=
		if ( !thisCache.data ) {=0A=
			thisCache.data =3D {};=0A=
		}=0A=
=0A=
		thisCache =3D thisCache.data;=0A=
	}=0A=
=0A=
	if ( data !=3D=3D undefined ) {=0A=
		thisCache[ jQuery.camelCase( name ) ] =3D data;=0A=
	}=0A=
=0A=
	// Check for both converted-to-camel and non-converted data property =
names=0A=
	// If a data property was specified=0A=
	if ( typeof name =3D=3D=3D "string" ) {=0A=
=0A=
		// First Try to find as-is property data=0A=
		ret =3D thisCache[ name ];=0A=
=0A=
		// Test for null|undefined property data=0A=
		if ( ret =3D=3D null ) {=0A=
=0A=
			// Try to find the camelCased property=0A=
			ret =3D thisCache[ jQuery.camelCase( name ) ];=0A=
		}=0A=
	} else {=0A=
		ret =3D thisCache;=0A=
	}=0A=
=0A=
	return ret;=0A=
}=0A=
=0A=
function internalRemoveData( elem, name, pvt ) {=0A=
	if ( !jQuery.acceptData( elem ) ) {=0A=
		return;=0A=
	}=0A=
=0A=
	var thisCache, i,=0A=
		isNode =3D elem.nodeType,=0A=
=0A=
		// See jQuery.data for more information=0A=
		cache =3D isNode ? jQuery.cache : elem,=0A=
		id =3D isNode ? elem[ jQuery.expando ] : jQuery.expando;=0A=
=0A=
	// If there is already no cache entry for this object, there is no=0A=
	// purpose in continuing=0A=
	if ( !cache[ id ] ) {=0A=
		return;=0A=
	}=0A=
=0A=
	if ( name ) {=0A=
=0A=
		thisCache =3D pvt ? cache[ id ] : cache[ id ].data;=0A=
=0A=
		if ( thisCache ) {=0A=
=0A=
			// Support array or space separated string names for data keys=0A=
			if ( !jQuery.isArray( name ) ) {=0A=
=0A=
				// try the string as a key before any manipulation=0A=
				if ( name in thisCache ) {=0A=
					name =3D [ name ];=0A=
				} else {=0A=
=0A=
					// split the camel cased version by spaces unless a key with the =
spaces exists=0A=
					name =3D jQuery.camelCase( name );=0A=
					if ( name in thisCache ) {=0A=
						name =3D [ name ];=0A=
					} else {=0A=
						name =3D name.split(" ");=0A=
					}=0A=
				}=0A=
			} else {=0A=
				// If "name" is an array of keys...=0A=
				// When data is initially created, via ("key", "val") signature,=0A=
				// keys will be converted to camelCase.=0A=
				// Since there is no way to tell _how_ a key was added, remove=0A=
				// both plain key and camelCase key. #12786=0A=
				// This will only penalize the array argument path.=0A=
				name =3D name.concat( jQuery.map( name, jQuery.camelCase ) );=0A=
			}=0A=
=0A=
			i =3D name.length;=0A=
			while ( i-- ) {=0A=
				delete thisCache[ name[i] ];=0A=
			}=0A=
=0A=
			// If there is no data left in the cache, we want to continue=0A=
			// and let the cache object itself get destroyed=0A=
			if ( pvt ? !isEmptyDataObject(thisCache) : =
!jQuery.isEmptyObject(thisCache) ) {=0A=
				return;=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	// See jQuery.data for more information=0A=
	if ( !pvt ) {=0A=
		delete cache[ id ].data;=0A=
=0A=
		// Don't destroy the parent cache unless the internal data object=0A=
		// had been the only thing left in it=0A=
		if ( !isEmptyDataObject( cache[ id ] ) ) {=0A=
			return;=0A=
		}=0A=
	}=0A=
=0A=
	// Destroy the cache=0A=
	if ( isNode ) {=0A=
		jQuery.cleanData( [ elem ], true );=0A=
=0A=
	// Use delete when supported for expandos or `cache` is not a window =
per isWindow (#10080)=0A=
	/* jshint eqeqeq: false */=0A=
	} else if ( support.deleteExpando || cache !=3D cache.window ) {=0A=
		/* jshint eqeqeq: true */=0A=
		delete cache[ id ];=0A=
=0A=
	// When all else fails, null=0A=
	} else {=0A=
		cache[ id ] =3D null;=0A=
	}=0A=
}=0A=
=0A=
jQuery.extend({=0A=
	cache: {},=0A=
=0A=
	// The following elements (space-suffixed to avoid Object.prototype =
collisions)=0A=
	// throw uncatchable exceptions if you attempt to set expando properties=0A=
	noData: {=0A=
		"applet ": true,=0A=
		"embed ": true,=0A=
		// ...but Flash objects (which have this classid) *can* handle expandos=0A=
		"object ": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"=0A=
	},=0A=
=0A=
	hasData: function( elem ) {=0A=
		elem =3D elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ =
jQuery.expando ];=0A=
		return !!elem && !isEmptyDataObject( elem );=0A=
	},=0A=
=0A=
	data: function( elem, name, data ) {=0A=
		return internalData( elem, name, data );=0A=
	},=0A=
=0A=
	removeData: function( elem, name ) {=0A=
		return internalRemoveData( elem, name );=0A=
	},=0A=
=0A=
	// For internal use only.=0A=
	_data: function( elem, name, data ) {=0A=
		return internalData( elem, name, data, true );=0A=
	},=0A=
=0A=
	_removeData: function( elem, name ) {=0A=
		return internalRemoveData( elem, name, true );=0A=
	}=0A=
});=0A=
=0A=
jQuery.fn.extend({=0A=
	data: function( key, value ) {=0A=
		var i, name, data,=0A=
			elem =3D this[0],=0A=
			attrs =3D elem && elem.attributes;=0A=
=0A=
		// Special expections of .data basically thwart jQuery.access,=0A=
		// so implement the relevant behavior ourselves=0A=
=0A=
		// Gets all values=0A=
		if ( key =3D=3D=3D undefined ) {=0A=
			if ( this.length ) {=0A=
				data =3D jQuery.data( elem );=0A=
=0A=
				if ( elem.nodeType =3D=3D=3D 1 && !jQuery._data( elem, "parsedAttrs" =
) ) {=0A=
					i =3D attrs.length;=0A=
					while ( i-- ) {=0A=
=0A=
						// Support: IE11+=0A=
						// The attrs elements can be null (#14894)=0A=
						if ( attrs[ i ] ) {=0A=
							name =3D attrs[ i ].name;=0A=
							if ( name.indexOf( "data-" ) =3D=3D=3D 0 ) {=0A=
								name =3D jQuery.camelCase( name.slice(5) );=0A=
								dataAttr( elem, name, data[ name ] );=0A=
							}=0A=
						}=0A=
					}=0A=
					jQuery._data( elem, "parsedAttrs", true );=0A=
				}=0A=
			}=0A=
=0A=
			return data;=0A=
		}=0A=
=0A=
		// Sets multiple values=0A=
		if ( typeof key =3D=3D=3D "object" ) {=0A=
			return this.each(function() {=0A=
				jQuery.data( this, key );=0A=
			});=0A=
		}=0A=
=0A=
		return arguments.length > 1 ?=0A=
=0A=
			// Sets one value=0A=
			this.each(function() {=0A=
				jQuery.data( this, key, value );=0A=
			}) :=0A=
=0A=
			// Gets one value=0A=
			// Try to fetch any internally stored data first=0A=
			elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : undefined;=0A=
	},=0A=
=0A=
	removeData: function( key ) {=0A=
		return this.each(function() {=0A=
			jQuery.removeData( this, key );=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
=0A=
jQuery.extend({=0A=
	queue: function( elem, type, data ) {=0A=
		var queue;=0A=
=0A=
		if ( elem ) {=0A=
			type =3D ( type || "fx" ) + "queue";=0A=
			queue =3D jQuery._data( elem, type );=0A=
=0A=
			// Speed up dequeue by getting out quickly if this is just a lookup=0A=
			if ( data ) {=0A=
				if ( !queue || jQuery.isArray(data) ) {=0A=
					queue =3D jQuery._data( elem, type, jQuery.makeArray(data) );=0A=
				} else {=0A=
					queue.push( data );=0A=
				}=0A=
			}=0A=
			return queue || [];=0A=
		}=0A=
	},=0A=
=0A=
	dequeue: function( elem, type ) {=0A=
		type =3D type || "fx";=0A=
=0A=
		var queue =3D jQuery.queue( elem, type ),=0A=
			startLength =3D queue.length,=0A=
			fn =3D queue.shift(),=0A=
			hooks =3D jQuery._queueHooks( elem, type ),=0A=
			next =3D function() {=0A=
				jQuery.dequeue( elem, type );=0A=
			};=0A=
=0A=
		// If the fx queue is dequeued, always remove the progress sentinel=0A=
		if ( fn =3D=3D=3D "inprogress" ) {=0A=
			fn =3D queue.shift();=0A=
			startLength--;=0A=
		}=0A=
=0A=
		if ( fn ) {=0A=
=0A=
			// Add a progress sentinel to prevent the fx queue from being=0A=
			// automatically dequeued=0A=
			if ( type =3D=3D=3D "fx" ) {=0A=
				queue.unshift( "inprogress" );=0A=
			}=0A=
=0A=
			// clear up the last queue stop function=0A=
			delete hooks.stop;=0A=
			fn.call( elem, next, hooks );=0A=
		}=0A=
=0A=
		if ( !startLength && hooks ) {=0A=
			hooks.empty.fire();=0A=
		}=0A=
	},=0A=
=0A=
	// not intended for public consumption - generates a queueHooks object, =
or returns the current one=0A=
	_queueHooks: function( elem, type ) {=0A=
		var key =3D type + "queueHooks";=0A=
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {=0A=
			empty: jQuery.Callbacks("once memory").add(function() {=0A=
				jQuery._removeData( elem, type + "queue" );=0A=
				jQuery._removeData( elem, key );=0A=
			})=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
jQuery.fn.extend({=0A=
	queue: function( type, data ) {=0A=
		var setter =3D 2;=0A=
=0A=
		if ( typeof type !=3D=3D "string" ) {=0A=
			data =3D type;=0A=
			type =3D "fx";=0A=
			setter--;=0A=
		}=0A=
=0A=
		if ( arguments.length < setter ) {=0A=
			return jQuery.queue( this[0], type );=0A=
		}=0A=
=0A=
		return data =3D=3D=3D undefined ?=0A=
			this :=0A=
			this.each(function() {=0A=
				var queue =3D jQuery.queue( this, type, data );=0A=
=0A=
				// ensure a hooks for this queue=0A=
				jQuery._queueHooks( this, type );=0A=
=0A=
				if ( type =3D=3D=3D "fx" && queue[0] !=3D=3D "inprogress" ) {=0A=
					jQuery.dequeue( this, type );=0A=
				}=0A=
			});=0A=
	},=0A=
	dequeue: function( type ) {=0A=
		return this.each(function() {=0A=
			jQuery.dequeue( this, type );=0A=
		});=0A=
	},=0A=
	clearQueue: function( type ) {=0A=
		return this.queue( type || "fx", [] );=0A=
	},=0A=
	// Get a promise resolved when queues of a certain type=0A=
	// are emptied (fx is the type by default)=0A=
	promise: function( type, obj ) {=0A=
		var tmp,=0A=
			count =3D 1,=0A=
			defer =3D jQuery.Deferred(),=0A=
			elements =3D this,=0A=
			i =3D this.length,=0A=
			resolve =3D function() {=0A=
				if ( !( --count ) ) {=0A=
					defer.resolveWith( elements, [ elements ] );=0A=
				}=0A=
			};=0A=
=0A=
		if ( typeof type !=3D=3D "string" ) {=0A=
			obj =3D type;=0A=
			type =3D undefined;=0A=
		}=0A=
		type =3D type || "fx";=0A=
=0A=
		while ( i-- ) {=0A=
			tmp =3D jQuery._data( elements[ i ], type + "queueHooks" );=0A=
			if ( tmp && tmp.empty ) {=0A=
				count++;=0A=
				tmp.empty.add( resolve );=0A=
			}=0A=
		}=0A=
		resolve();=0A=
		return defer.promise( obj );=0A=
	}=0A=
});=0A=
var pnum =3D (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;=0A=
=0A=
var cssExpand =3D [ "Top", "Right", "Bottom", "Left" ];=0A=
=0A=
var isHidden =3D function( elem, el ) {=0A=
		// isHidden might be called from jQuery#filter function;=0A=
		// in that case, element will be second argument=0A=
		elem =3D el || elem;=0A=
		return jQuery.css( elem, "display" ) =3D=3D=3D "none" || =
!jQuery.contains( elem.ownerDocument, elem );=0A=
	};=0A=
=0A=
=0A=
=0A=
// Multifunctional method to get and set values of a collection=0A=
// The value/s can optionally be executed if it's a function=0A=
var access =3D jQuery.access =3D function( elems, fn, key, value, =
chainable, emptyGet, raw ) {=0A=
	var i =3D 0,=0A=
		length =3D elems.length,=0A=
		bulk =3D key =3D=3D null;=0A=
=0A=
	// Sets many values=0A=
	if ( jQuery.type( key ) =3D=3D=3D "object" ) {=0A=
		chainable =3D true;=0A=
		for ( i in key ) {=0A=
			jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );=0A=
		}=0A=
=0A=
	// Sets one value=0A=
	} else if ( value !=3D=3D undefined ) {=0A=
		chainable =3D true;=0A=
=0A=
		if ( !jQuery.isFunction( value ) ) {=0A=
			raw =3D true;=0A=
		}=0A=
=0A=
		if ( bulk ) {=0A=
			// Bulk operations run against the entire set=0A=
			if ( raw ) {=0A=
				fn.call( elems, value );=0A=
				fn =3D null;=0A=
=0A=
			// ...except when executing function values=0A=
			} else {=0A=
				bulk =3D fn;=0A=
				fn =3D function( elem, key, value ) {=0A=
					return bulk.call( jQuery( elem ), value );=0A=
				};=0A=
			}=0A=
		}=0A=
=0A=
		if ( fn ) {=0A=
			for ( ; i < length; i++ ) {=0A=
				fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( =
elems[i], key ) ) );=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	return chainable ?=0A=
		elems :=0A=
=0A=
		// Gets=0A=
		bulk ?=0A=
			fn.call( elems ) :=0A=
			length ? fn( elems[0], key ) : emptyGet;=0A=
};=0A=
var rcheckableType =3D (/^(?:checkbox|radio)$/i);=0A=
=0A=
=0A=
=0A=
(function() {=0A=
	// Minified: var a,b,c=0A=
	var input =3D document.createElement( "input" ),=0A=
		div =3D document.createElement( "div" ),=0A=
		fragment =3D document.createDocumentFragment();=0A=
=0A=
	// Setup=0A=
	div.innerHTML =3D "  <link/><table></table><a href=3D'/a'>a</a><input =
type=3D'checkbox'/>";=0A=
=0A=
	// IE strips leading whitespace when .innerHTML is used=0A=
	support.leadingWhitespace =3D div.firstChild.nodeType =3D=3D=3D 3;=0A=
=0A=
	// Make sure that tbody elements aren't automatically inserted=0A=
	// IE will insert them into empty tables=0A=
	support.tbody =3D !div.getElementsByTagName( "tbody" ).length;=0A=
=0A=
	// Make sure that link elements get serialized correctly by innerHTML=0A=
	// This requires a wrapper element in IE=0A=
	support.htmlSerialize =3D !!div.getElementsByTagName( "link" ).length;=0A=
=0A=
	// Makes sure cloning an html5 element does not cause problems=0A=
	// Where outerHTML is undefined, this still works=0A=
	support.html5Clone =3D=0A=
		document.createElement( "nav" ).cloneNode( true ).outerHTML !=3D=3D =
"<:nav></:nav>";=0A=
=0A=
	// Check if a disconnected checkbox will retain its checked=0A=
	// value of true after appended to the DOM (IE6/7)=0A=
	input.type =3D "checkbox";=0A=
	input.checked =3D true;=0A=
	fragment.appendChild( input );=0A=
	support.appendChecked =3D input.checked;=0A=
=0A=
	// Make sure textarea (and checkbox) defaultValue is properly cloned=0A=
	// Support: IE6-IE11+=0A=
	div.innerHTML =3D "<textarea>x</textarea>";=0A=
	support.noCloneChecked =3D !!div.cloneNode( true =
).lastChild.defaultValue;=0A=
=0A=
	// #11217 - WebKit loses check when the name is after the checked =
attribute=0A=
	fragment.appendChild( div );=0A=
	div.innerHTML =3D "<input type=3D'radio' checked=3D'checked' =
name=3D't'/>";=0A=
=0A=
	// Support: Safari 5.1, iOS 5.1, Android 4.x, Android 2.3=0A=
	// old WebKit doesn't clone checked state correctly in fragments=0A=
	support.checkClone =3D div.cloneNode( true ).cloneNode( true =
).lastChild.checked;=0A=
=0A=
	// Support: IE<9=0A=
	// Opera does not clone events (and typeof div.attachEvent =3D=3D=3D =
undefined).=0A=
	// IE9-10 clones events bound via attachEvent, but they don't trigger =
with .click()=0A=
	support.noCloneEvent =3D true;=0A=
	if ( div.attachEvent ) {=0A=
		div.attachEvent( "onclick", function() {=0A=
			support.noCloneEvent =3D false;=0A=
		});=0A=
=0A=
		div.cloneNode( true ).click();=0A=
	}=0A=
=0A=
	// Execute the test only if not already executed in another module.=0A=
	if (support.deleteExpando =3D=3D null) {=0A=
		// Support: IE<9=0A=
		support.deleteExpando =3D true;=0A=
		try {=0A=
			delete div.test;=0A=
		} catch( e ) {=0A=
			support.deleteExpando =3D false;=0A=
		}=0A=
	}=0A=
})();=0A=
=0A=
=0A=
(function() {=0A=
	var i, eventName,=0A=
		div =3D document.createElement( "div" );=0A=
=0A=
	// Support: IE<9 (lack submit/change bubble), Firefox 23+ (lack focusin =
event)=0A=
	for ( i in { submit: true, change: true, focusin: true }) {=0A=
		eventName =3D "on" + i;=0A=
=0A=
		if ( !(support[ i + "Bubbles" ] =3D eventName in window) ) {=0A=
			// Beware of CSP restrictions =
(https://developer.mozilla.org/en/Security/CSP)=0A=
			div.setAttribute( eventName, "t" );=0A=
			support[ i + "Bubbles" ] =3D div.attributes[ eventName ].expando =
=3D=3D=3D false;=0A=
		}=0A=
	}=0A=
=0A=
	// Null elements to avoid leaks in IE.=0A=
	div =3D null;=0A=
})();=0A=
=0A=
=0A=
var rformElems =3D /^(?:input|select|textarea)$/i,=0A=
	rkeyEvent =3D /^key/,=0A=
	rmouseEvent =3D /^(?:mouse|pointer|contextmenu)|click/,=0A=
	rfocusMorph =3D /^(?:focusinfocus|focusoutblur)$/,=0A=
	rtypenamespace =3D /^([^.]*)(?:\.(.+)|)$/;=0A=
=0A=
function returnTrue() {=0A=
	return true;=0A=
}=0A=
=0A=
function returnFalse() {=0A=
	return false;=0A=
}=0A=
=0A=
function safeActiveElement() {=0A=
	try {=0A=
		return document.activeElement;=0A=
	} catch ( err ) { }=0A=
}=0A=
=0A=
/*=0A=
 * Helper functions for managing events -- not part of the public =
interface.=0A=
 * Props to Dean Edwards' addEvent library for many of the ideas.=0A=
 */=0A=
jQuery.event =3D {=0A=
=0A=
	global: {},=0A=
=0A=
	add: function( elem, types, handler, data, selector ) {=0A=
		var tmp, events, t, handleObjIn,=0A=
			special, eventHandle, handleObj,=0A=
			handlers, type, namespaces, origType,=0A=
			elemData =3D jQuery._data( elem );=0A=
=0A=
		// Don't attach events to noData or text/comment nodes (but allow =
plain objects)=0A=
		if ( !elemData ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Caller can pass in an object of custom data in lieu of the handler=0A=
		if ( handler.handler ) {=0A=
			handleObjIn =3D handler;=0A=
			handler =3D handleObjIn.handler;=0A=
			selector =3D handleObjIn.selector;=0A=
		}=0A=
=0A=
		// Make sure that the handler has a unique ID, used to find/remove it =
later=0A=
		if ( !handler.guid ) {=0A=
			handler.guid =3D jQuery.guid++;=0A=
		}=0A=
=0A=
		// Init the element's event structure and main handler, if this is the =
first=0A=
		if ( !(events =3D elemData.events) ) {=0A=
			events =3D elemData.events =3D {};=0A=
		}=0A=
		if ( !(eventHandle =3D elemData.handle) ) {=0A=
			eventHandle =3D elemData.handle =3D function( e ) {=0A=
				// Discard the second event of a jQuery.event.trigger() and=0A=
				// when an event is called after a page has unloaded=0A=
				return typeof jQuery !=3D=3D strundefined && (!e || =
jQuery.event.triggered !=3D=3D e.type) ?=0A=
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :=0A=
					undefined;=0A=
			};=0A=
			// Add elem as a property of the handle fn to prevent a memory leak =
with IE non-native events=0A=
			eventHandle.elem =3D elem;=0A=
		}=0A=
=0A=
		// Handle multiple events separated by a space=0A=
		types =3D ( types || "" ).match( rnotwhite ) || [ "" ];=0A=
		t =3D types.length;=0A=
		while ( t-- ) {=0A=
			tmp =3D rtypenamespace.exec( types[t] ) || [];=0A=
			type =3D origType =3D tmp[1];=0A=
			namespaces =3D ( tmp[2] || "" ).split( "." ).sort();=0A=
=0A=
			// There *must* be a type, no attaching namespace-only handlers=0A=
			if ( !type ) {=0A=
				continue;=0A=
			}=0A=
=0A=
			// If event changes its type, use the special event handlers for the =
changed type=0A=
			special =3D jQuery.event.special[ type ] || {};=0A=
=0A=
			// If selector defined, determine special event api type, otherwise =
given type=0A=
			type =3D ( selector ? special.delegateType : special.bindType ) || =
type;=0A=
=0A=
			// Update special based on newly reset type=0A=
			special =3D jQuery.event.special[ type ] || {};=0A=
=0A=
			// handleObj is passed to all event handlers=0A=
			handleObj =3D jQuery.extend({=0A=
				type: type,=0A=
				origType: origType,=0A=
				data: data,=0A=
				handler: handler,=0A=
				guid: handler.guid,=0A=
				selector: selector,=0A=
				needsContext: selector && jQuery.expr.match.needsContext.test( =
selector ),=0A=
				namespace: namespaces.join(".")=0A=
			}, handleObjIn );=0A=
=0A=
			// Init the event handler queue if we're the first=0A=
			if ( !(handlers =3D events[ type ]) ) {=0A=
				handlers =3D events[ type ] =3D [];=0A=
				handlers.delegateCount =3D 0;=0A=
=0A=
				// Only use addEventListener/attachEvent if the special events =
handler returns false=0A=
				if ( !special.setup || special.setup.call( elem, data, namespaces, =
eventHandle ) =3D=3D=3D false ) {=0A=
					// Bind the global event handler to the element=0A=
					if ( elem.addEventListener ) {=0A=
						elem.addEventListener( type, eventHandle, false );=0A=
=0A=
					} else if ( elem.attachEvent ) {=0A=
						elem.attachEvent( "on" + type, eventHandle );=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			if ( special.add ) {=0A=
				special.add.call( elem, handleObj );=0A=
=0A=
				if ( !handleObj.handler.guid ) {=0A=
					handleObj.handler.guid =3D handler.guid;=0A=
				}=0A=
			}=0A=
=0A=
			// Add to the element's handler list, delegates in front=0A=
			if ( selector ) {=0A=
				handlers.splice( handlers.delegateCount++, 0, handleObj );=0A=
			} else {=0A=
				handlers.push( handleObj );=0A=
			}=0A=
=0A=
			// Keep track of which events have ever been used, for event =
optimization=0A=
			jQuery.event.global[ type ] =3D true;=0A=
		}=0A=
=0A=
		// Nullify elem to prevent memory leaks in IE=0A=
		elem =3D null;=0A=
	},=0A=
=0A=
	// Detach an event or set of events from an element=0A=
	remove: function( elem, types, handler, selector, mappedTypes ) {=0A=
		var j, handleObj, tmp,=0A=
			origCount, t, events,=0A=
			special, handlers, type,=0A=
			namespaces, origType,=0A=
			elemData =3D jQuery.hasData( elem ) && jQuery._data( elem );=0A=
=0A=
		if ( !elemData || !(events =3D elemData.events) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Once for each type.namespace in types; type may be omitted=0A=
		types =3D ( types || "" ).match( rnotwhite ) || [ "" ];=0A=
		t =3D types.length;=0A=
		while ( t-- ) {=0A=
			tmp =3D rtypenamespace.exec( types[t] ) || [];=0A=
			type =3D origType =3D tmp[1];=0A=
			namespaces =3D ( tmp[2] || "" ).split( "." ).sort();=0A=
=0A=
			// Unbind all events (on this namespace, if provided) for the element=0A=
			if ( !type ) {=0A=
				for ( type in events ) {=0A=
					jQuery.event.remove( elem, type + types[ t ], handler, selector, =
true );=0A=
				}=0A=
				continue;=0A=
			}=0A=
=0A=
			special =3D jQuery.event.special[ type ] || {};=0A=
			type =3D ( selector ? special.delegateType : special.bindType ) || =
type;=0A=
			handlers =3D events[ type ] || [];=0A=
			tmp =3D tmp[2] && new RegExp( "(^|\\.)" + =
namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" );=0A=
=0A=
			// Remove matching events=0A=
			origCount =3D j =3D handlers.length;=0A=
			while ( j-- ) {=0A=
				handleObj =3D handlers[ j ];=0A=
=0A=
				if ( ( mappedTypes || origType =3D=3D=3D handleObj.origType ) &&=0A=
					( !handler || handler.guid =3D=3D=3D handleObj.guid ) &&=0A=
					( !tmp || tmp.test( handleObj.namespace ) ) &&=0A=
					( !selector || selector =3D=3D=3D handleObj.selector || selector =
=3D=3D=3D "**" && handleObj.selector ) ) {=0A=
					handlers.splice( j, 1 );=0A=
=0A=
					if ( handleObj.selector ) {=0A=
						handlers.delegateCount--;=0A=
					}=0A=
					if ( special.remove ) {=0A=
						special.remove.call( elem, handleObj );=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			// Remove generic event handler if we removed something and no more =
handlers exist=0A=
			// (avoids potential for endless recursion during removal of special =
event handlers)=0A=
			if ( origCount && !handlers.length ) {=0A=
				if ( !special.teardown || special.teardown.call( elem, namespaces, =
elemData.handle ) =3D=3D=3D false ) {=0A=
					jQuery.removeEvent( elem, type, elemData.handle );=0A=
				}=0A=
=0A=
				delete events[ type ];=0A=
			}=0A=
		}=0A=
=0A=
		// Remove the expando if it's no longer used=0A=
		if ( jQuery.isEmptyObject( events ) ) {=0A=
			delete elemData.handle;=0A=
=0A=
			// removeData also checks for emptiness and clears the expando if =
empty=0A=
			// so use it instead of delete=0A=
			jQuery._removeData( elem, "events" );=0A=
		}=0A=
	},=0A=
=0A=
	trigger: function( event, data, elem, onlyHandlers ) {=0A=
		var handle, ontype, cur,=0A=
			bubbleType, special, tmp, i,=0A=
			eventPath =3D [ elem || document ],=0A=
			type =3D hasOwn.call( event, "type" ) ? event.type : event,=0A=
			namespaces =3D hasOwn.call( event, "namespace" ) ? =
event.namespace.split(".") : [];=0A=
=0A=
		cur =3D tmp =3D elem =3D elem || document;=0A=
=0A=
		// Don't do events on text and comment nodes=0A=
		if ( elem.nodeType =3D=3D=3D 3 || elem.nodeType =3D=3D=3D 8 ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// focus/blur morphs to focusin/out; ensure we're not firing them =
right now=0A=
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( type.indexOf(".") >=3D 0 ) {=0A=
			// Namespaced trigger; create a regexp to match event type in handle()=0A=
			namespaces =3D type.split(".");=0A=
			type =3D namespaces.shift();=0A=
			namespaces.sort();=0A=
		}=0A=
		ontype =3D type.indexOf(":") < 0 && "on" + type;=0A=
=0A=
		// Caller can pass in a jQuery.Event object, Object, or just an event =
type string=0A=
		event =3D event[ jQuery.expando ] ?=0A=
			event :=0A=
			new jQuery.Event( type, typeof event =3D=3D=3D "object" && event );=0A=
=0A=
		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always =
true)=0A=
		event.isTrigger =3D onlyHandlers ? 2 : 3;=0A=
		event.namespace =3D namespaces.join(".");=0A=
		event.namespace_re =3D event.namespace ?=0A=
			new RegExp( "(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)" =
) :=0A=
			null;=0A=
=0A=
		// Clean up the event in case it is being reused=0A=
		event.result =3D undefined;=0A=
		if ( !event.target ) {=0A=
			event.target =3D elem;=0A=
		}=0A=
=0A=
		// Clone any incoming data and prepend the event, creating the handler =
arg list=0A=
		data =3D data =3D=3D null ?=0A=
			[ event ] :=0A=
			jQuery.makeArray( data, [ event ] );=0A=
=0A=
		// Allow special events to draw outside the lines=0A=
		special =3D jQuery.event.special[ type ] || {};=0A=
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, =
data ) =3D=3D=3D false ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Determine event propagation path in advance, per W3C events spec =
(#9951)=0A=
		// Bubble up to document, then to window; watch for a global =
ownerDocument var (#9724)=0A=
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {=0A=
=0A=
			bubbleType =3D special.delegateType || type;=0A=
			if ( !rfocusMorph.test( bubbleType + type ) ) {=0A=
				cur =3D cur.parentNode;=0A=
			}=0A=
			for ( ; cur; cur =3D cur.parentNode ) {=0A=
				eventPath.push( cur );=0A=
				tmp =3D cur;=0A=
			}=0A=
=0A=
			// Only add window if we got to document (e.g., not plain obj or =
detached DOM)=0A=
			if ( tmp =3D=3D=3D (elem.ownerDocument || document) ) {=0A=
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );=0A=
			}=0A=
		}=0A=
=0A=
		// Fire handlers on the event path=0A=
		i =3D 0;=0A=
		while ( (cur =3D eventPath[i++]) && !event.isPropagationStopped() ) {=0A=
=0A=
			event.type =3D i > 1 ?=0A=
				bubbleType :=0A=
				special.bindType || type;=0A=
=0A=
			// jQuery handler=0A=
			handle =3D ( jQuery._data( cur, "events" ) || {} )[ event.type ] && =
jQuery._data( cur, "handle" );=0A=
			if ( handle ) {=0A=
				handle.apply( cur, data );=0A=
			}=0A=
=0A=
			// Native handler=0A=
			handle =3D ontype && cur[ ontype ];=0A=
			if ( handle && handle.apply && jQuery.acceptData( cur ) ) {=0A=
				event.result =3D handle.apply( cur, data );=0A=
				if ( event.result =3D=3D=3D false ) {=0A=
					event.preventDefault();=0A=
				}=0A=
			}=0A=
		}=0A=
		event.type =3D type;=0A=
=0A=
		// If nobody prevented the default action, do it now=0A=
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {=0A=
=0A=
			if ( (!special._default || special._default.apply( eventPath.pop(), =
data ) =3D=3D=3D false) &&=0A=
				jQuery.acceptData( elem ) ) {=0A=
=0A=
				// Call a native DOM method on the target with the same name name as =
the event.=0A=
				// Can't use an .isFunction() check here because IE6/7 fails that =
test.=0A=
				// Don't do default actions on window, that's where global variables =
be (#6170)=0A=
				if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {=0A=
=0A=
					// Don't re-trigger an onFOO event when we call its FOO() method=0A=
					tmp =3D elem[ ontype ];=0A=
=0A=
					if ( tmp ) {=0A=
						elem[ ontype ] =3D null;=0A=
					}=0A=
=0A=
					// Prevent re-triggering of the same event, since we already =
bubbled it above=0A=
					jQuery.event.triggered =3D type;=0A=
					try {=0A=
						elem[ type ]();=0A=
					} catch ( e ) {=0A=
						// IE<9 dies on focus/blur to hidden element (#1486,#12518)=0A=
						// only reproducible on winXP IE8 native, not IE9 in IE8 mode=0A=
					}=0A=
					jQuery.event.triggered =3D undefined;=0A=
=0A=
					if ( tmp ) {=0A=
						elem[ ontype ] =3D tmp;=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return event.result;=0A=
	},=0A=
=0A=
	dispatch: function( event ) {=0A=
=0A=
		// Make a writable jQuery.Event from the native event object=0A=
		event =3D jQuery.event.fix( event );=0A=
=0A=
		var i, ret, handleObj, matched, j,=0A=
			handlerQueue =3D [],=0A=
			args =3D slice.call( arguments ),=0A=
			handlers =3D ( jQuery._data( this, "events" ) || {} )[ event.type ] =
|| [],=0A=
			special =3D jQuery.event.special[ event.type ] || {};=0A=
=0A=
		// Use the fix-ed jQuery.Event rather than the (read-only) native event=0A=
		args[0] =3D event;=0A=
		event.delegateTarget =3D this;=0A=
=0A=
		// Call the preDispatch hook for the mapped type, and let it bail if =
desired=0A=
		if ( special.preDispatch && special.preDispatch.call( this, event ) =
=3D=3D=3D false ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Determine handlers=0A=
		handlerQueue =3D jQuery.event.handlers.call( this, event, handlers );=0A=
=0A=
		// Run delegates first; they may want to stop propagation beneath us=0A=
		i =3D 0;=0A=
		while ( (matched =3D handlerQueue[ i++ ]) && =
!event.isPropagationStopped() ) {=0A=
			event.currentTarget =3D matched.elem;=0A=
=0A=
			j =3D 0;=0A=
			while ( (handleObj =3D matched.handlers[ j++ ]) && =
!event.isImmediatePropagationStopped() ) {=0A=
=0A=
				// Triggered event must either 1) have no namespace, or=0A=
				// 2) have namespace(s) a subset or equal to those in the bound =
event (both can have no namespace).=0A=
				if ( !event.namespace_re || event.namespace_re.test( =
handleObj.namespace ) ) {=0A=
=0A=
					event.handleObj =3D handleObj;=0A=
					event.data =3D handleObj.data;=0A=
=0A=
					ret =3D ( (jQuery.event.special[ handleObj.origType ] || {}).handle =
|| handleObj.handler )=0A=
							.apply( matched.elem, args );=0A=
=0A=
					if ( ret !=3D=3D undefined ) {=0A=
						if ( (event.result =3D ret) =3D=3D=3D false ) {=0A=
							event.preventDefault();=0A=
							event.stopPropagation();=0A=
						}=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// Call the postDispatch hook for the mapped type=0A=
		if ( special.postDispatch ) {=0A=
			special.postDispatch.call( this, event );=0A=
		}=0A=
=0A=
		return event.result;=0A=
	},=0A=
=0A=
	handlers: function( event, handlers ) {=0A=
		var sel, handleObj, matches, i,=0A=
			handlerQueue =3D [],=0A=
			delegateCount =3D handlers.delegateCount,=0A=
			cur =3D event.target;=0A=
=0A=
		// Find delegate handlers=0A=
		// Black-hole SVG <use> instance trees (#13180)=0A=
		// Avoid non-left-click bubbling in Firefox (#3861)=0A=
		if ( delegateCount && cur.nodeType && (!event.button || event.type =
!=3D=3D "click") ) {=0A=
=0A=
			/* jshint eqeqeq: false */=0A=
			for ( ; cur !=3D this; cur =3D cur.parentNode || this ) {=0A=
				/* jshint eqeqeq: true */=0A=
=0A=
				// Don't check non-elements (#13208)=0A=
				// Don't process clicks on disabled elements (#6911, #8165, #11382, =
#11764)=0A=
				if ( cur.nodeType =3D=3D=3D 1 && (cur.disabled !=3D=3D true || =
event.type !=3D=3D "click") ) {=0A=
					matches =3D [];=0A=
					for ( i =3D 0; i < delegateCount; i++ ) {=0A=
						handleObj =3D handlers[ i ];=0A=
=0A=
						// Don't conflict with Object.prototype properties (#13203)=0A=
						sel =3D handleObj.selector + " ";=0A=
=0A=
						if ( matches[ sel ] =3D=3D=3D undefined ) {=0A=
							matches[ sel ] =3D handleObj.needsContext ?=0A=
								jQuery( sel, this ).index( cur ) >=3D 0 :=0A=
								jQuery.find( sel, this, null, [ cur ] ).length;=0A=
						}=0A=
						if ( matches[ sel ] ) {=0A=
							matches.push( handleObj );=0A=
						}=0A=
					}=0A=
					if ( matches.length ) {=0A=
						handlerQueue.push({ elem: cur, handlers: matches });=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// Add the remaining (directly-bound) handlers=0A=
		if ( delegateCount < handlers.length ) {=0A=
			handlerQueue.push({ elem: this, handlers: handlers.slice( =
delegateCount ) });=0A=
		}=0A=
=0A=
		return handlerQueue;=0A=
	},=0A=
=0A=
	fix: function( event ) {=0A=
		if ( event[ jQuery.expando ] ) {=0A=
			return event;=0A=
		}=0A=
=0A=
		// Create a writable copy of the event object and normalize some =
properties=0A=
		var i, prop, copy,=0A=
			type =3D event.type,=0A=
			originalEvent =3D event,=0A=
			fixHook =3D this.fixHooks[ type ];=0A=
=0A=
		if ( !fixHook ) {=0A=
			this.fixHooks[ type ] =3D fixHook =3D=0A=
				rmouseEvent.test( type ) ? this.mouseHooks :=0A=
				rkeyEvent.test( type ) ? this.keyHooks :=0A=
				{};=0A=
		}=0A=
		copy =3D fixHook.props ? this.props.concat( fixHook.props ) : =
this.props;=0A=
=0A=
		event =3D new jQuery.Event( originalEvent );=0A=
=0A=
		i =3D copy.length;=0A=
		while ( i-- ) {=0A=
			prop =3D copy[ i ];=0A=
			event[ prop ] =3D originalEvent[ prop ];=0A=
		}=0A=
=0A=
		// Support: IE<9=0A=
		// Fix target property (#1925)=0A=
		if ( !event.target ) {=0A=
			event.target =3D originalEvent.srcElement || document;=0A=
		}=0A=
=0A=
		// Support: Chrome 23+, Safari?=0A=
		// Target should not be a text node (#504, #13143)=0A=
		if ( event.target.nodeType =3D=3D=3D 3 ) {=0A=
			event.target =3D event.target.parentNode;=0A=
		}=0A=
=0A=
		// Support: IE<9=0A=
		// For mouse/key events, metaKey=3D=3Dfalse if it's undefined (#3368, =
#11328)=0A=
		event.metaKey =3D !!event.metaKey;=0A=
=0A=
		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;=0A=
	},=0A=
=0A=
	// Includes some event props shared by KeyEvent and MouseEvent=0A=
	props: "altKey bubbles cancelable ctrlKey currentTarget eventPhase =
metaKey relatedTarget shiftKey target timeStamp view which".split(" "),=0A=
=0A=
	fixHooks: {},=0A=
=0A=
	keyHooks: {=0A=
		props: "char charCode key keyCode".split(" "),=0A=
		filter: function( event, original ) {=0A=
=0A=
			// Add which for key events=0A=
			if ( event.which =3D=3D null ) {=0A=
				event.which =3D original.charCode !=3D null ? original.charCode : =
original.keyCode;=0A=
			}=0A=
=0A=
			return event;=0A=
		}=0A=
	},=0A=
=0A=
	mouseHooks: {=0A=
		props: "button buttons clientX clientY fromElement offsetX offsetY =
pageX pageY screenX screenY toElement".split(" "),=0A=
		filter: function( event, original ) {=0A=
			var body, eventDoc, doc,=0A=
				button =3D original.button,=0A=
				fromElement =3D original.fromElement;=0A=
=0A=
			// Calculate pageX/Y if missing and clientX/Y available=0A=
			if ( event.pageX =3D=3D null && original.clientX !=3D null ) {=0A=
				eventDoc =3D event.target.ownerDocument || document;=0A=
				doc =3D eventDoc.documentElement;=0A=
				body =3D eventDoc.body;=0A=
=0A=
				event.pageX =3D original.clientX + ( doc && doc.scrollLeft || body =
&& body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && =
body.clientLeft || 0 );=0A=
				event.pageY =3D original.clientY + ( doc && doc.scrollTop  || body =
&& body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && =
body.clientTop  || 0 );=0A=
			}=0A=
=0A=
			// Add relatedTarget, if necessary=0A=
			if ( !event.relatedTarget && fromElement ) {=0A=
				event.relatedTarget =3D fromElement =3D=3D=3D event.target ? =
original.toElement : fromElement;=0A=
			}=0A=
=0A=
			// Add which for click: 1 =3D=3D=3D left; 2 =3D=3D=3D middle; 3 =
=3D=3D=3D right=0A=
			// Note: button is not normalized, so don't use it=0A=
			if ( !event.which && button !=3D=3D undefined ) {=0A=
				event.which =3D ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? =
2 : 0 ) ) );=0A=
			}=0A=
=0A=
			return event;=0A=
		}=0A=
	},=0A=
=0A=
	special: {=0A=
		load: {=0A=
			// Prevent triggered image.load events from bubbling to window.load=0A=
			noBubble: true=0A=
		},=0A=
		focus: {=0A=
			// Fire native event if possible so blur/focus sequence is correct=0A=
			trigger: function() {=0A=
				if ( this !=3D=3D safeActiveElement() && this.focus ) {=0A=
					try {=0A=
						this.focus();=0A=
						return false;=0A=
					} catch ( e ) {=0A=
						// Support: IE<9=0A=
						// If we error on focus to hidden element (#1486, #12518),=0A=
						// let .trigger() run the handlers=0A=
					}=0A=
				}=0A=
			},=0A=
			delegateType: "focusin"=0A=
		},=0A=
		blur: {=0A=
			trigger: function() {=0A=
				if ( this =3D=3D=3D safeActiveElement() && this.blur ) {=0A=
					this.blur();=0A=
					return false;=0A=
				}=0A=
			},=0A=
			delegateType: "focusout"=0A=
		},=0A=
		click: {=0A=
			// For checkbox, fire native event so checked state will be right=0A=
			trigger: function() {=0A=
				if ( jQuery.nodeName( this, "input" ) && this.type =3D=3D=3D =
"checkbox" && this.click ) {=0A=
					this.click();=0A=
					return false;=0A=
				}=0A=
			},=0A=
=0A=
			// For cross-browser consistency, don't fire native .click() on links=0A=
			_default: function( event ) {=0A=
				return jQuery.nodeName( event.target, "a" );=0A=
			}=0A=
		},=0A=
=0A=
		beforeunload: {=0A=
			postDispatch: function( event ) {=0A=
=0A=
				// Support: Firefox 20+=0A=
				// Firefox doesn't alert if the returnValue field is not set.=0A=
				if ( event.result !=3D=3D undefined && event.originalEvent ) {=0A=
					event.originalEvent.returnValue =3D event.result;=0A=
				}=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	simulate: function( type, elem, event, bubble ) {=0A=
		// Piggyback on a donor event to simulate a different one.=0A=
		// Fake originalEvent to avoid donor's stopPropagation, but if the=0A=
		// simulated event prevents default then we do the same on the donor.=0A=
		var e =3D jQuery.extend(=0A=
			new jQuery.Event(),=0A=
			event,=0A=
			{=0A=
				type: type,=0A=
				isSimulated: true,=0A=
				originalEvent: {}=0A=
			}=0A=
		);=0A=
		if ( bubble ) {=0A=
			jQuery.event.trigger( e, null, elem );=0A=
		} else {=0A=
			jQuery.event.dispatch.call( elem, e );=0A=
		}=0A=
		if ( e.isDefaultPrevented() ) {=0A=
			event.preventDefault();=0A=
		}=0A=
	}=0A=
};=0A=
=0A=
jQuery.removeEvent =3D document.removeEventListener ?=0A=
	function( elem, type, handle ) {=0A=
		if ( elem.removeEventListener ) {=0A=
			elem.removeEventListener( type, handle, false );=0A=
		}=0A=
	} :=0A=
	function( elem, type, handle ) {=0A=
		var name =3D "on" + type;=0A=
=0A=
		if ( elem.detachEvent ) {=0A=
=0A=
			// #8545, #7054, preventing memory leaks for custom events in IE6-8=0A=
			// detachEvent needed property on element, by name of that event, to =
properly expose it to GC=0A=
			if ( typeof elem[ name ] =3D=3D=3D strundefined ) {=0A=
				elem[ name ] =3D null;=0A=
			}=0A=
=0A=
			elem.detachEvent( name, handle );=0A=
		}=0A=
	};=0A=
=0A=
jQuery.Event =3D function( src, props ) {=0A=
	// Allow instantiation without the 'new' keyword=0A=
	if ( !(this instanceof jQuery.Event) ) {=0A=
		return new jQuery.Event( src, props );=0A=
	}=0A=
=0A=
	// Event object=0A=
	if ( src && src.type ) {=0A=
		this.originalEvent =3D src;=0A=
		this.type =3D src.type;=0A=
=0A=
		// Events bubbling up the document may have been marked as prevented=0A=
		// by a handler lower down the tree; reflect the correct value.=0A=
		this.isDefaultPrevented =3D src.defaultPrevented ||=0A=
				src.defaultPrevented =3D=3D=3D undefined &&=0A=
				// Support: IE < 9, Android < 4.0=0A=
				src.returnValue =3D=3D=3D false ?=0A=
			returnTrue :=0A=
			returnFalse;=0A=
=0A=
	// Event type=0A=
	} else {=0A=
		this.type =3D src;=0A=
	}=0A=
=0A=
	// Put explicitly provided properties onto the event object=0A=
	if ( props ) {=0A=
		jQuery.extend( this, props );=0A=
	}=0A=
=0A=
	// Create a timestamp if incoming event doesn't have one=0A=
	this.timeStamp =3D src && src.timeStamp || jQuery.now();=0A=
=0A=
	// Mark it as fixed=0A=
	this[ jQuery.expando ] =3D true;=0A=
};=0A=
=0A=
// jQuery.Event is based on DOM3 Events as specified by the ECMAScript =
Language Binding=0A=
// =
http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-bind=
ing.html=0A=
jQuery.Event.prototype =3D {=0A=
	isDefaultPrevented: returnFalse,=0A=
	isPropagationStopped: returnFalse,=0A=
	isImmediatePropagationStopped: returnFalse,=0A=
=0A=
	preventDefault: function() {=0A=
		var e =3D this.originalEvent;=0A=
=0A=
		this.isDefaultPrevented =3D returnTrue;=0A=
		if ( !e ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// If preventDefault exists, run it on the original event=0A=
		if ( e.preventDefault ) {=0A=
			e.preventDefault();=0A=
=0A=
		// Support: IE=0A=
		// Otherwise set the returnValue property of the original event to =
false=0A=
		} else {=0A=
			e.returnValue =3D false;=0A=
		}=0A=
	},=0A=
	stopPropagation: function() {=0A=
		var e =3D this.originalEvent;=0A=
=0A=
		this.isPropagationStopped =3D returnTrue;=0A=
		if ( !e ) {=0A=
			return;=0A=
		}=0A=
		// If stopPropagation exists, run it on the original event=0A=
		if ( e.stopPropagation ) {=0A=
			e.stopPropagation();=0A=
		}=0A=
=0A=
		// Support: IE=0A=
		// Set the cancelBubble property of the original event to true=0A=
		e.cancelBubble =3D true;=0A=
	},=0A=
	stopImmediatePropagation: function() {=0A=
		var e =3D this.originalEvent;=0A=
=0A=
		this.isImmediatePropagationStopped =3D returnTrue;=0A=
=0A=
		if ( e && e.stopImmediatePropagation ) {=0A=
			e.stopImmediatePropagation();=0A=
		}=0A=
=0A=
		this.stopPropagation();=0A=
	}=0A=
};=0A=
=0A=
// Create mouseenter/leave events using mouseover/out and event-time =
checks=0A=
jQuery.each({=0A=
	mouseenter: "mouseover",=0A=
	mouseleave: "mouseout",=0A=
	pointerenter: "pointerover",=0A=
	pointerleave: "pointerout"=0A=
}, function( orig, fix ) {=0A=
	jQuery.event.special[ orig ] =3D {=0A=
		delegateType: fix,=0A=
		bindType: fix,=0A=
=0A=
		handle: function( event ) {=0A=
			var ret,=0A=
				target =3D this,=0A=
				related =3D event.relatedTarget,=0A=
				handleObj =3D event.handleObj;=0A=
=0A=
			// For mousenter/leave call the handler if related is outside the =
target.=0A=
			// NB: No relatedTarget if the mouse left/entered the browser window=0A=
			if ( !related || (related !=3D=3D target && !jQuery.contains( target, =
related )) ) {=0A=
				event.type =3D handleObj.origType;=0A=
				ret =3D handleObj.handler.apply( this, arguments );=0A=
				event.type =3D fix;=0A=
			}=0A=
			return ret;=0A=
		}=0A=
	};=0A=
});=0A=
=0A=
// IE submit delegation=0A=
if ( !support.submitBubbles ) {=0A=
=0A=
	jQuery.event.special.submit =3D {=0A=
		setup: function() {=0A=
			// Only need this for delegated form submit events=0A=
			if ( jQuery.nodeName( this, "form" ) ) {=0A=
				return false;=0A=
			}=0A=
=0A=
			// Lazy-add a submit handler when a descendant form may potentially =
be submitted=0A=
			jQuery.event.add( this, "click._submit keypress._submit", function( e =
) {=0A=
				// Node name check avoids a VML-related crash in IE (#9807)=0A=
				var elem =3D e.target,=0A=
					form =3D jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, =
"button" ) ? elem.form : undefined;=0A=
				if ( form && !jQuery._data( form, "submitBubbles" ) ) {=0A=
					jQuery.event.add( form, "submit._submit", function( event ) {=0A=
						event._submit_bubble =3D true;=0A=
					});=0A=
					jQuery._data( form, "submitBubbles", true );=0A=
				}=0A=
			});=0A=
			// return undefined since we don't need an event listener=0A=
		},=0A=
=0A=
		postDispatch: function( event ) {=0A=
			// If form was submitted by the user, bubble the event up the tree=0A=
			if ( event._submit_bubble ) {=0A=
				delete event._submit_bubble;=0A=
				if ( this.parentNode && !event.isTrigger ) {=0A=
					jQuery.event.simulate( "submit", this.parentNode, event, true );=0A=
				}=0A=
			}=0A=
		},=0A=
=0A=
		teardown: function() {=0A=
			// Only need this for delegated form submit events=0A=
			if ( jQuery.nodeName( this, "form" ) ) {=0A=
				return false;=0A=
			}=0A=
=0A=
			// Remove delegated handlers; cleanData eventually reaps submit =
handlers attached above=0A=
			jQuery.event.remove( this, "._submit" );=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
// IE change delegation and checkbox/radio fix=0A=
if ( !support.changeBubbles ) {=0A=
=0A=
	jQuery.event.special.change =3D {=0A=
=0A=
		setup: function() {=0A=
=0A=
			if ( rformElems.test( this.nodeName ) ) {=0A=
				// IE doesn't fire change on a check/radio until blur; trigger it on =
click=0A=
				// after a propertychange. Eat the blur-change in =
special.change.handle.=0A=
				// This still fires onchange a second time for check/radio after =
blur.=0A=
				if ( this.type =3D=3D=3D "checkbox" || this.type =3D=3D=3D "radio" ) =
{=0A=
					jQuery.event.add( this, "propertychange._change", function( event ) =
{=0A=
						if ( event.originalEvent.propertyName =3D=3D=3D "checked" ) {=0A=
							this._just_changed =3D true;=0A=
						}=0A=
					});=0A=
					jQuery.event.add( this, "click._change", function( event ) {=0A=
						if ( this._just_changed && !event.isTrigger ) {=0A=
							this._just_changed =3D false;=0A=
						}=0A=
						// Allow triggered, simulated change events (#11500)=0A=
						jQuery.event.simulate( "change", this, event, true );=0A=
					});=0A=
				}=0A=
				return false;=0A=
			}=0A=
			// Delegated event; lazy-add a change handler on descendant inputs=0A=
			jQuery.event.add( this, "beforeactivate._change", function( e ) {=0A=
				var elem =3D e.target;=0A=
=0A=
				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, =
"changeBubbles" ) ) {=0A=
					jQuery.event.add( elem, "change._change", function( event ) {=0A=
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {=0A=
							jQuery.event.simulate( "change", this.parentNode, event, true );=0A=
						}=0A=
					});=0A=
					jQuery._data( elem, "changeBubbles", true );=0A=
				}=0A=
			});=0A=
		},=0A=
=0A=
		handle: function( event ) {=0A=
			var elem =3D event.target;=0A=
=0A=
			// Swallow native change events from checkbox/radio, we already =
triggered them above=0A=
			if ( this !=3D=3D elem || event.isSimulated || event.isTrigger || =
(elem.type !=3D=3D "radio" && elem.type !=3D=3D "checkbox") ) {=0A=
				return event.handleObj.handler.apply( this, arguments );=0A=
			}=0A=
		},=0A=
=0A=
		teardown: function() {=0A=
			jQuery.event.remove( this, "._change" );=0A=
=0A=
			return !rformElems.test( this.nodeName );=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
// Create "bubbling" focus and blur events=0A=
if ( !support.focusinBubbles ) {=0A=
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix =
) {=0A=
=0A=
		// Attach a single capturing handler on the document while someone =
wants focusin/focusout=0A=
		var handler =3D function( event ) {=0A=
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), =
true );=0A=
			};=0A=
=0A=
		jQuery.event.special[ fix ] =3D {=0A=
			setup: function() {=0A=
				var doc =3D this.ownerDocument || this,=0A=
					attaches =3D jQuery._data( doc, fix );=0A=
=0A=
				if ( !attaches ) {=0A=
					doc.addEventListener( orig, handler, true );=0A=
				}=0A=
				jQuery._data( doc, fix, ( attaches || 0 ) + 1 );=0A=
			},=0A=
			teardown: function() {=0A=
				var doc =3D this.ownerDocument || this,=0A=
					attaches =3D jQuery._data( doc, fix ) - 1;=0A=
=0A=
				if ( !attaches ) {=0A=
					doc.removeEventListener( orig, handler, true );=0A=
					jQuery._removeData( doc, fix );=0A=
				} else {=0A=
					jQuery._data( doc, fix, attaches );=0A=
				}=0A=
			}=0A=
		};=0A=
	});=0A=
}=0A=
=0A=
jQuery.fn.extend({=0A=
=0A=
	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {=0A=
		var type, origFn;=0A=
=0A=
		// Types can be a map of types/handlers=0A=
		if ( typeof types =3D=3D=3D "object" ) {=0A=
			// ( types-Object, selector, data )=0A=
			if ( typeof selector !=3D=3D "string" ) {=0A=
				// ( types-Object, data )=0A=
				data =3D data || selector;=0A=
				selector =3D undefined;=0A=
			}=0A=
			for ( type in types ) {=0A=
				this.on( type, selector, data, types[ type ], one );=0A=
			}=0A=
			return this;=0A=
		}=0A=
=0A=
		if ( data =3D=3D null && fn =3D=3D null ) {=0A=
			// ( types, fn )=0A=
			fn =3D selector;=0A=
			data =3D selector =3D undefined;=0A=
		} else if ( fn =3D=3D null ) {=0A=
			if ( typeof selector =3D=3D=3D "string" ) {=0A=
				// ( types, selector, fn )=0A=
				fn =3D data;=0A=
				data =3D undefined;=0A=
			} else {=0A=
				// ( types, data, fn )=0A=
				fn =3D data;=0A=
				data =3D selector;=0A=
				selector =3D undefined;=0A=
			}=0A=
		}=0A=
		if ( fn =3D=3D=3D false ) {=0A=
			fn =3D returnFalse;=0A=
		} else if ( !fn ) {=0A=
			return this;=0A=
		}=0A=
=0A=
		if ( one =3D=3D=3D 1 ) {=0A=
			origFn =3D fn;=0A=
			fn =3D function( event ) {=0A=
				// Can use an empty set, since event contains the info=0A=
				jQuery().off( event );=0A=
				return origFn.apply( this, arguments );=0A=
			};=0A=
			// Use same guid so caller can remove using origFn=0A=
			fn.guid =3D origFn.guid || ( origFn.guid =3D jQuery.guid++ );=0A=
		}=0A=
		return this.each( function() {=0A=
			jQuery.event.add( this, types, fn, data, selector );=0A=
		});=0A=
	},=0A=
	one: function( types, selector, data, fn ) {=0A=
		return this.on( types, selector, data, fn, 1 );=0A=
	},=0A=
	off: function( types, selector, fn ) {=0A=
		var handleObj, type;=0A=
		if ( types && types.preventDefault && types.handleObj ) {=0A=
			// ( event )  dispatched jQuery.Event=0A=
			handleObj =3D types.handleObj;=0A=
			jQuery( types.delegateTarget ).off(=0A=
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace =
: handleObj.origType,=0A=
				handleObj.selector,=0A=
				handleObj.handler=0A=
			);=0A=
			return this;=0A=
		}=0A=
		if ( typeof types =3D=3D=3D "object" ) {=0A=
			// ( types-object [, selector] )=0A=
			for ( type in types ) {=0A=
				this.off( type, selector, types[ type ] );=0A=
			}=0A=
			return this;=0A=
		}=0A=
		if ( selector =3D=3D=3D false || typeof selector =3D=3D=3D "function" =
) {=0A=
			// ( types [, fn] )=0A=
			fn =3D selector;=0A=
			selector =3D undefined;=0A=
		}=0A=
		if ( fn =3D=3D=3D false ) {=0A=
			fn =3D returnFalse;=0A=
		}=0A=
		return this.each(function() {=0A=
			jQuery.event.remove( this, types, fn, selector );=0A=
		});=0A=
	},=0A=
=0A=
	trigger: function( type, data ) {=0A=
		return this.each(function() {=0A=
			jQuery.event.trigger( type, data, this );=0A=
		});=0A=
	},=0A=
	triggerHandler: function( type, data ) {=0A=
		var elem =3D this[0];=0A=
		if ( elem ) {=0A=
			return jQuery.event.trigger( type, data, elem, true );=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
=0A=
function createSafeFragment( document ) {=0A=
	var list =3D nodeNames.split( "|" ),=0A=
		safeFrag =3D document.createDocumentFragment();=0A=
=0A=
	if ( safeFrag.createElement ) {=0A=
		while ( list.length ) {=0A=
			safeFrag.createElement(=0A=
				list.pop()=0A=
			);=0A=
		}=0A=
	}=0A=
	return safeFrag;=0A=
}=0A=
=0A=
var nodeNames =3D =
"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|fig=
ure|footer|" +=0A=
		=
"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video"=
,=0A=
	rinlinejQuery =3D / jQuery\d+=3D"(?:null|\d+)"/g,=0A=
	rnoshimcache =3D new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),=0A=
	rleadingWhitespace =3D /^\s+/,=0A=
	rxhtmlTag =3D =
/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi=
,=0A=
	rtagName =3D /<([\w:]+)/,=0A=
	rtbody =3D /<tbody/i,=0A=
	rhtml =3D /<|&#?\w+;/,=0A=
	rnoInnerhtml =3D /<(?:script|style|link)/i,=0A=
	// checked=3D"checked" or checked=0A=
	rchecked =3D /checked\s*(?:[^=3D]|=3D\s*.checked.)/i,=0A=
	rscriptType =3D /^$|\/(?:java|ecma)script/i,=0A=
	rscriptTypeMasked =3D /^true\/(.*)/,=0A=
	rcleanScript =3D /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,=0A=
=0A=
	// We have to close these tags to support XHTML (#13200)=0A=
	wrapMap =3D {=0A=
		option: [ 1, "<select multiple=3D'multiple'>", "</select>" ],=0A=
		legend: [ 1, "<fieldset>", "</fieldset>" ],=0A=
		area: [ 1, "<map>", "</map>" ],=0A=
		param: [ 1, "<object>", "</object>" ],=0A=
		thead: [ 1, "<table>", "</table>" ],=0A=
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],=0A=
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],=0A=
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],=0A=
=0A=
		// IE6-8 can't serialize link, script, style, or any html5 (NoScope) =
tags,=0A=
		// unless wrapped in a div with non-breaking characters in front of it.=0A=
		_default: support.htmlSerialize ? [ 0, "", "" ] : [ 1, "X<div>", =
"</div>"  ]=0A=
	},=0A=
	safeFragment =3D createSafeFragment( document ),=0A=
	fragmentDiv =3D safeFragment.appendChild( document.createElement("div") =
);=0A=
=0A=
wrapMap.optgroup =3D wrapMap.option;=0A=
wrapMap.tbody =3D wrapMap.tfoot =3D wrapMap.colgroup =3D wrapMap.caption =
=3D wrapMap.thead;=0A=
wrapMap.th =3D wrapMap.td;=0A=
=0A=
function getAll( context, tag ) {=0A=
	var elems, elem,=0A=
		i =3D 0,=0A=
		found =3D typeof context.getElementsByTagName !=3D=3D strundefined ? =
context.getElementsByTagName( tag || "*" ) :=0A=
			typeof context.querySelectorAll !=3D=3D strundefined ? =
context.querySelectorAll( tag || "*" ) :=0A=
			undefined;=0A=
=0A=
	if ( !found ) {=0A=
		for ( found =3D [], elems =3D context.childNodes || context; (elem =3D =
elems[i]) !=3D null; i++ ) {=0A=
			if ( !tag || jQuery.nodeName( elem, tag ) ) {=0A=
				found.push( elem );=0A=
			} else {=0A=
				jQuery.merge( found, getAll( elem, tag ) );=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	return tag =3D=3D=3D undefined || tag && jQuery.nodeName( context, tag =
) ?=0A=
		jQuery.merge( [ context ], found ) :=0A=
		found;=0A=
}=0A=
=0A=
// Used in buildFragment, fixes the defaultChecked property=0A=
function fixDefaultChecked( elem ) {=0A=
	if ( rcheckableType.test( elem.type ) ) {=0A=
		elem.defaultChecked =3D elem.checked;=0A=
	}=0A=
}=0A=
=0A=
// Support: IE<8=0A=
// Manipulating tables requires a tbody=0A=
function manipulationTarget( elem, content ) {=0A=
	return jQuery.nodeName( elem, "table" ) &&=0A=
		jQuery.nodeName( content.nodeType !=3D=3D 11 ? content : =
content.firstChild, "tr" ) ?=0A=
=0A=
		elem.getElementsByTagName("tbody")[0] ||=0A=
			elem.appendChild( elem.ownerDocument.createElement("tbody") ) :=0A=
		elem;=0A=
}=0A=
=0A=
// Replace/restore the type attribute of script elements for safe DOM =
manipulation=0A=
function disableScript( elem ) {=0A=
	elem.type =3D (jQuery.find.attr( elem, "type" ) !=3D=3D null) + "/" + =
elem.type;=0A=
	return elem;=0A=
}=0A=
function restoreScript( elem ) {=0A=
	var match =3D rscriptTypeMasked.exec( elem.type );=0A=
	if ( match ) {=0A=
		elem.type =3D match[1];=0A=
	} else {=0A=
		elem.removeAttribute("type");=0A=
	}=0A=
	return elem;=0A=
}=0A=
=0A=
// Mark scripts as having already been evaluated=0A=
function setGlobalEval( elems, refElements ) {=0A=
	var elem,=0A=
		i =3D 0;=0A=
	for ( ; (elem =3D elems[i]) !=3D null; i++ ) {=0A=
		jQuery._data( elem, "globalEval", !refElements || jQuery._data( =
refElements[i], "globalEval" ) );=0A=
	}=0A=
}=0A=
=0A=
function cloneCopyEvent( src, dest ) {=0A=
=0A=
	if ( dest.nodeType !=3D=3D 1 || !jQuery.hasData( src ) ) {=0A=
		return;=0A=
	}=0A=
=0A=
	var type, i, l,=0A=
		oldData =3D jQuery._data( src ),=0A=
		curData =3D jQuery._data( dest, oldData ),=0A=
		events =3D oldData.events;=0A=
=0A=
	if ( events ) {=0A=
		delete curData.handle;=0A=
		curData.events =3D {};=0A=
=0A=
		for ( type in events ) {=0A=
			for ( i =3D 0, l =3D events[ type ].length; i < l; i++ ) {=0A=
				jQuery.event.add( dest, type, events[ type ][ i ] );=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	// make the cloned public data object a copy from the original=0A=
	if ( curData.data ) {=0A=
		curData.data =3D jQuery.extend( {}, curData.data );=0A=
	}=0A=
}=0A=
=0A=
function fixCloneNodeIssues( src, dest ) {=0A=
	var nodeName, e, data;=0A=
=0A=
	// We do not need to do anything for non-Elements=0A=
	if ( dest.nodeType !=3D=3D 1 ) {=0A=
		return;=0A=
	}=0A=
=0A=
	nodeName =3D dest.nodeName.toLowerCase();=0A=
=0A=
	// IE6-8 copies events bound via attachEvent when using cloneNode.=0A=
	if ( !support.noCloneEvent && dest[ jQuery.expando ] ) {=0A=
		data =3D jQuery._data( dest );=0A=
=0A=
		for ( e in data.events ) {=0A=
			jQuery.removeEvent( dest, e, data.handle );=0A=
		}=0A=
=0A=
		// Event data gets referenced instead of copied if the expando gets =
copied too=0A=
		dest.removeAttribute( jQuery.expando );=0A=
	}=0A=
=0A=
	// IE blanks contents when cloning scripts, and tries to evaluate =
newly-set text=0A=
	if ( nodeName =3D=3D=3D "script" && dest.text !=3D=3D src.text ) {=0A=
		disableScript( dest ).text =3D src.text;=0A=
		restoreScript( dest );=0A=
=0A=
	// IE6-10 improperly clones children of object elements using classid.=0A=
	// IE10 throws NoModificationAllowedError if parent is null, #12132.=0A=
	} else if ( nodeName =3D=3D=3D "object" ) {=0A=
		if ( dest.parentNode ) {=0A=
			dest.outerHTML =3D src.outerHTML;=0A=
		}=0A=
=0A=
		// This path appears unavoidable for IE9. When cloning an object=0A=
		// element in IE9, the outerHTML strategy above is not sufficient.=0A=
		// If the src has innerHTML and the destination does not,=0A=
		// copy the src.innerHTML into the dest.innerHTML. #10324=0A=
		if ( support.html5Clone && ( src.innerHTML && =
!jQuery.trim(dest.innerHTML) ) ) {=0A=
			dest.innerHTML =3D src.innerHTML;=0A=
		}=0A=
=0A=
	} else if ( nodeName =3D=3D=3D "input" && rcheckableType.test( src.type =
) ) {=0A=
		// IE6-8 fails to persist the checked state of a cloned checkbox=0A=
		// or radio button. Worse, IE6-7 fail to give the cloned element=0A=
		// a checked appearance if the defaultChecked value isn't also set=0A=
=0A=
		dest.defaultChecked =3D dest.checked =3D src.checked;=0A=
=0A=
		// IE6-7 get confused and end up setting the value of a cloned=0A=
		// checkbox/radio button to an empty string instead of "on"=0A=
		if ( dest.value !=3D=3D src.value ) {=0A=
			dest.value =3D src.value;=0A=
		}=0A=
=0A=
	// IE6-8 fails to return the selected option to the default selected=0A=
	// state when cloning options=0A=
	} else if ( nodeName =3D=3D=3D "option" ) {=0A=
		dest.defaultSelected =3D dest.selected =3D src.defaultSelected;=0A=
=0A=
	// IE6-8 fails to set the defaultValue to the correct value when=0A=
	// cloning other types of input fields=0A=
	} else if ( nodeName =3D=3D=3D "input" || nodeName =3D=3D=3D "textarea" =
) {=0A=
		dest.defaultValue =3D src.defaultValue;=0A=
	}=0A=
}=0A=
=0A=
jQuery.extend({=0A=
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {=0A=
		var destElements, node, clone, i, srcElements,=0A=
			inPage =3D jQuery.contains( elem.ownerDocument, elem );=0A=
=0A=
		if ( support.html5Clone || jQuery.isXMLDoc(elem) || =
!rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {=0A=
			clone =3D elem.cloneNode( true );=0A=
=0A=
		// IE<=3D8 does not properly clone detached, unknown element nodes=0A=
		} else {=0A=
			fragmentDiv.innerHTML =3D elem.outerHTML;=0A=
			fragmentDiv.removeChild( clone =3D fragmentDiv.firstChild );=0A=
		}=0A=
=0A=
		if ( (!support.noCloneEvent || !support.noCloneChecked) &&=0A=
				(elem.nodeType =3D=3D=3D 1 || elem.nodeType =3D=3D=3D 11) && =
!jQuery.isXMLDoc(elem) ) {=0A=
=0A=
			// We eschew Sizzle here for performance reasons: =
http://jsperf.com/getall-vs-sizzle/2=0A=
			destElements =3D getAll( clone );=0A=
			srcElements =3D getAll( elem );=0A=
=0A=
			// Fix all IE cloning issues=0A=
			for ( i =3D 0; (node =3D srcElements[i]) !=3D null; ++i ) {=0A=
				// Ensure that the destination node is not null; Fixes #9587=0A=
				if ( destElements[i] ) {=0A=
					fixCloneNodeIssues( node, destElements[i] );=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// Copy the events from the original to the clone=0A=
		if ( dataAndEvents ) {=0A=
			if ( deepDataAndEvents ) {=0A=
				srcElements =3D srcElements || getAll( elem );=0A=
				destElements =3D destElements || getAll( clone );=0A=
=0A=
				for ( i =3D 0; (node =3D srcElements[i]) !=3D null; i++ ) {=0A=
					cloneCopyEvent( node, destElements[i] );=0A=
				}=0A=
			} else {=0A=
				cloneCopyEvent( elem, clone );=0A=
			}=0A=
		}=0A=
=0A=
		// Preserve script evaluation history=0A=
		destElements =3D getAll( clone, "script" );=0A=
		if ( destElements.length > 0 ) {=0A=
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );=0A=
		}=0A=
=0A=
		destElements =3D srcElements =3D node =3D null;=0A=
=0A=
		// Return the cloned set=0A=
		return clone;=0A=
	},=0A=
=0A=
	buildFragment: function( elems, context, scripts, selection ) {=0A=
		var j, elem, contains,=0A=
			tmp, tag, tbody, wrap,=0A=
			l =3D elems.length,=0A=
=0A=
			// Ensure a safe fragment=0A=
			safe =3D createSafeFragment( context ),=0A=
=0A=
			nodes =3D [],=0A=
			i =3D 0;=0A=
=0A=
		for ( ; i < l; i++ ) {=0A=
			elem =3D elems[ i ];=0A=
=0A=
			if ( elem || elem =3D=3D=3D 0 ) {=0A=
=0A=
				// Add nodes directly=0A=
				if ( jQuery.type( elem ) =3D=3D=3D "object" ) {=0A=
					jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );=0A=
=0A=
				// Convert non-html into a text node=0A=
				} else if ( !rhtml.test( elem ) ) {=0A=
					nodes.push( context.createTextNode( elem ) );=0A=
=0A=
				// Convert html into DOM nodes=0A=
				} else {=0A=
					tmp =3D tmp || safe.appendChild( context.createElement("div") );=0A=
=0A=
					// Deserialize a standard representation=0A=
					tag =3D (rtagName.exec( elem ) || [ "", "" ])[ 1 ].toLowerCase();=0A=
					wrap =3D wrapMap[ tag ] || wrapMap._default;=0A=
=0A=
					tmp.innerHTML =3D wrap[1] + elem.replace( rxhtmlTag, "<$1></$2>" ) =
+ wrap[2];=0A=
=0A=
					// Descend through wrappers to the right content=0A=
					j =3D wrap[0];=0A=
					while ( j-- ) {=0A=
						tmp =3D tmp.lastChild;=0A=
					}=0A=
=0A=
					// Manually add leading whitespace removed by IE=0A=
					if ( !support.leadingWhitespace && rleadingWhitespace.test( elem ) =
) {=0A=
						nodes.push( context.createTextNode( rleadingWhitespace.exec( elem =
)[0] ) );=0A=
					}=0A=
=0A=
					// Remove IE's autoinserted <tbody> from table fragments=0A=
					if ( !support.tbody ) {=0A=
=0A=
						// String was a <table>, *may* have spurious <tbody>=0A=
						elem =3D tag =3D=3D=3D "table" && !rtbody.test( elem ) ?=0A=
							tmp.firstChild :=0A=
=0A=
							// String was a bare <thead> or <tfoot>=0A=
							wrap[1] =3D=3D=3D "<table>" && !rtbody.test( elem ) ?=0A=
								tmp :=0A=
								0;=0A=
=0A=
						j =3D elem && elem.childNodes.length;=0A=
						while ( j-- ) {=0A=
							if ( jQuery.nodeName( (tbody =3D elem.childNodes[j]), "tbody" ) =
&& !tbody.childNodes.length ) {=0A=
								elem.removeChild( tbody );=0A=
							}=0A=
						}=0A=
					}=0A=
=0A=
					jQuery.merge( nodes, tmp.childNodes );=0A=
=0A=
					// Fix #12392 for WebKit and IE > 9=0A=
					tmp.textContent =3D "";=0A=
=0A=
					// Fix #12392 for oldIE=0A=
					while ( tmp.firstChild ) {=0A=
						tmp.removeChild( tmp.firstChild );=0A=
					}=0A=
=0A=
					// Remember the top-level container for proper cleanup=0A=
					tmp =3D safe.lastChild;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// Fix #11356: Clear elements from fragment=0A=
		if ( tmp ) {=0A=
			safe.removeChild( tmp );=0A=
		}=0A=
=0A=
		// Reset defaultChecked for any radios and checkboxes=0A=
		// about to be appended to the DOM in IE 6/7 (#8060)=0A=
		if ( !support.appendChecked ) {=0A=
			jQuery.grep( getAll( nodes, "input" ), fixDefaultChecked );=0A=
		}=0A=
=0A=
		i =3D 0;=0A=
		while ( (elem =3D nodes[ i++ ]) ) {=0A=
=0A=
			// #4087 - If origin and destination elements are the same, and this =
is=0A=
			// that element, do not do anything=0A=
			if ( selection && jQuery.inArray( elem, selection ) !=3D=3D -1 ) {=0A=
				continue;=0A=
			}=0A=
=0A=
			contains =3D jQuery.contains( elem.ownerDocument, elem );=0A=
=0A=
			// Append to fragment=0A=
			tmp =3D getAll( safe.appendChild( elem ), "script" );=0A=
=0A=
			// Preserve script evaluation history=0A=
			if ( contains ) {=0A=
				setGlobalEval( tmp );=0A=
			}=0A=
=0A=
			// Capture executables=0A=
			if ( scripts ) {=0A=
				j =3D 0;=0A=
				while ( (elem =3D tmp[ j++ ]) ) {=0A=
					if ( rscriptType.test( elem.type || "" ) ) {=0A=
						scripts.push( elem );=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		tmp =3D null;=0A=
=0A=
		return safe;=0A=
	},=0A=
=0A=
	cleanData: function( elems, /* internal */ acceptData ) {=0A=
		var elem, type, id, data,=0A=
			i =3D 0,=0A=
			internalKey =3D jQuery.expando,=0A=
			cache =3D jQuery.cache,=0A=
			deleteExpando =3D support.deleteExpando,=0A=
			special =3D jQuery.event.special;=0A=
=0A=
		for ( ; (elem =3D elems[i]) !=3D null; i++ ) {=0A=
			if ( acceptData || jQuery.acceptData( elem ) ) {=0A=
=0A=
				id =3D elem[ internalKey ];=0A=
				data =3D id && cache[ id ];=0A=
=0A=
				if ( data ) {=0A=
					if ( data.events ) {=0A=
						for ( type in data.events ) {=0A=
							if ( special[ type ] ) {=0A=
								jQuery.event.remove( elem, type );=0A=
=0A=
							// This is a shortcut to avoid jQuery.event.remove's overhead=0A=
							} else {=0A=
								jQuery.removeEvent( elem, type, data.handle );=0A=
							}=0A=
						}=0A=
					}=0A=
=0A=
					// Remove cache only if it was not already removed by =
jQuery.event.remove=0A=
					if ( cache[ id ] ) {=0A=
=0A=
						delete cache[ id ];=0A=
=0A=
						// IE does not allow us to delete expando properties from nodes,=0A=
						// nor does it have a removeAttribute function on Document nodes;=0A=
						// we must handle all of these cases=0A=
						if ( deleteExpando ) {=0A=
							delete elem[ internalKey ];=0A=
=0A=
						} else if ( typeof elem.removeAttribute !=3D=3D strundefined ) {=0A=
							elem.removeAttribute( internalKey );=0A=
=0A=
						} else {=0A=
							elem[ internalKey ] =3D null;=0A=
						}=0A=
=0A=
						deletedIds.push( id );=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
jQuery.fn.extend({=0A=
	text: function( value ) {=0A=
		return access( this, function( value ) {=0A=
			return value =3D=3D=3D undefined ?=0A=
				jQuery.text( this ) :=0A=
				this.empty().append( ( this[0] && this[0].ownerDocument || document =
).createTextNode( value ) );=0A=
		}, null, value, arguments.length );=0A=
	},=0A=
=0A=
	append: function() {=0A=
		return this.domManip( arguments, function( elem ) {=0A=
			if ( this.nodeType =3D=3D=3D 1 || this.nodeType =3D=3D=3D 11 || =
this.nodeType =3D=3D=3D 9 ) {=0A=
				var target =3D manipulationTarget( this, elem );=0A=
				target.appendChild( elem );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	prepend: function() {=0A=
		return this.domManip( arguments, function( elem ) {=0A=
			if ( this.nodeType =3D=3D=3D 1 || this.nodeType =3D=3D=3D 11 || =
this.nodeType =3D=3D=3D 9 ) {=0A=
				var target =3D manipulationTarget( this, elem );=0A=
				target.insertBefore( elem, target.firstChild );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	before: function() {=0A=
		return this.domManip( arguments, function( elem ) {=0A=
			if ( this.parentNode ) {=0A=
				this.parentNode.insertBefore( elem, this );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	after: function() {=0A=
		return this.domManip( arguments, function( elem ) {=0A=
			if ( this.parentNode ) {=0A=
				this.parentNode.insertBefore( elem, this.nextSibling );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	remove: function( selector, keepData /* Internal Use Only */ ) {=0A=
		var elem,=0A=
			elems =3D selector ? jQuery.filter( selector, this ) : this,=0A=
			i =3D 0;=0A=
=0A=
		for ( ; (elem =3D elems[i]) !=3D null; i++ ) {=0A=
=0A=
			if ( !keepData && elem.nodeType =3D=3D=3D 1 ) {=0A=
				jQuery.cleanData( getAll( elem ) );=0A=
			}=0A=
=0A=
			if ( elem.parentNode ) {=0A=
				if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {=0A=
					setGlobalEval( getAll( elem, "script" ) );=0A=
				}=0A=
				elem.parentNode.removeChild( elem );=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	empty: function() {=0A=
		var elem,=0A=
			i =3D 0;=0A=
=0A=
		for ( ; (elem =3D this[i]) !=3D null; i++ ) {=0A=
			// Remove element nodes and prevent memory leaks=0A=
			if ( elem.nodeType =3D=3D=3D 1 ) {=0A=
				jQuery.cleanData( getAll( elem, false ) );=0A=
			}=0A=
=0A=
			// Remove any remaining nodes=0A=
			while ( elem.firstChild ) {=0A=
				elem.removeChild( elem.firstChild );=0A=
			}=0A=
=0A=
			// If this is a select, ensure that it displays empty (#12336)=0A=
			// Support: IE<9=0A=
			if ( elem.options && jQuery.nodeName( elem, "select" ) ) {=0A=
				elem.options.length =3D 0;=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	clone: function( dataAndEvents, deepDataAndEvents ) {=0A=
		dataAndEvents =3D dataAndEvents =3D=3D null ? false : dataAndEvents;=0A=
		deepDataAndEvents =3D deepDataAndEvents =3D=3D null ? dataAndEvents : =
deepDataAndEvents;=0A=
=0A=
		return this.map(function() {=0A=
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );=0A=
		});=0A=
	},=0A=
=0A=
	html: function( value ) {=0A=
		return access( this, function( value ) {=0A=
			var elem =3D this[ 0 ] || {},=0A=
				i =3D 0,=0A=
				l =3D this.length;=0A=
=0A=
			if ( value =3D=3D=3D undefined ) {=0A=
				return elem.nodeType =3D=3D=3D 1 ?=0A=
					elem.innerHTML.replace( rinlinejQuery, "" ) :=0A=
					undefined;=0A=
			}=0A=
=0A=
			// See if we can take a shortcut and just use innerHTML=0A=
			if ( typeof value =3D=3D=3D "string" && !rnoInnerhtml.test( value ) &&=0A=
				( support.htmlSerialize || !rnoshimcache.test( value )  ) &&=0A=
				( support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&=0A=
				!wrapMap[ (rtagName.exec( value ) || [ "", "" ])[ 1 ].toLowerCase() =
] ) {=0A=
=0A=
				value =3D value.replace( rxhtmlTag, "<$1></$2>" );=0A=
=0A=
				try {=0A=
					for (; i < l; i++ ) {=0A=
						// Remove element nodes and prevent memory leaks=0A=
						elem =3D this[i] || {};=0A=
						if ( elem.nodeType =3D=3D=3D 1 ) {=0A=
							jQuery.cleanData( getAll( elem, false ) );=0A=
							elem.innerHTML =3D value;=0A=
						}=0A=
					}=0A=
=0A=
					elem =3D 0;=0A=
=0A=
				// If using innerHTML throws an exception, use the fallback method=0A=
				} catch(e) {}=0A=
			}=0A=
=0A=
			if ( elem ) {=0A=
				this.empty().append( value );=0A=
			}=0A=
		}, null, value, arguments.length );=0A=
	},=0A=
=0A=
	replaceWith: function() {=0A=
		var arg =3D arguments[ 0 ];=0A=
=0A=
		// Make the changes, replacing each context element with the new =
content=0A=
		this.domManip( arguments, function( elem ) {=0A=
			arg =3D this.parentNode;=0A=
=0A=
			jQuery.cleanData( getAll( this ) );=0A=
=0A=
			if ( arg ) {=0A=
				arg.replaceChild( elem, this );=0A=
			}=0A=
		});=0A=
=0A=
		// Force removal if there was no new content (e.g., from empty =
arguments)=0A=
		return arg && (arg.length || arg.nodeType) ? this : this.remove();=0A=
	},=0A=
=0A=
	detach: function( selector ) {=0A=
		return this.remove( selector, true );=0A=
	},=0A=
=0A=
	domManip: function( args, callback ) {=0A=
=0A=
		// Flatten any nested arrays=0A=
		args =3D concat.apply( [], args );=0A=
=0A=
		var first, node, hasScripts,=0A=
			scripts, doc, fragment,=0A=
			i =3D 0,=0A=
			l =3D this.length,=0A=
			set =3D this,=0A=
			iNoClone =3D l - 1,=0A=
			value =3D args[0],=0A=
			isFunction =3D jQuery.isFunction( value );=0A=
=0A=
		// We can't cloneNode fragments that contain checked, in WebKit=0A=
		if ( isFunction ||=0A=
				( l > 1 && typeof value =3D=3D=3D "string" &&=0A=
					!support.checkClone && rchecked.test( value ) ) ) {=0A=
			return this.each(function( index ) {=0A=
				var self =3D set.eq( index );=0A=
				if ( isFunction ) {=0A=
					args[0] =3D value.call( this, index, self.html() );=0A=
				}=0A=
				self.domManip( args, callback );=0A=
			});=0A=
		}=0A=
=0A=
		if ( l ) {=0A=
			fragment =3D jQuery.buildFragment( args, this[ 0 ].ownerDocument, =
false, this );=0A=
			first =3D fragment.firstChild;=0A=
=0A=
			if ( fragment.childNodes.length =3D=3D=3D 1 ) {=0A=
				fragment =3D first;=0A=
			}=0A=
=0A=
			if ( first ) {=0A=
				scripts =3D jQuery.map( getAll( fragment, "script" ), disableScript =
);=0A=
				hasScripts =3D scripts.length;=0A=
=0A=
				// Use the original fragment for the last item instead of the first =
because it can end up=0A=
				// being emptied incorrectly in certain situations (#8070).=0A=
				for ( ; i < l; i++ ) {=0A=
					node =3D fragment;=0A=
=0A=
					if ( i !=3D=3D iNoClone ) {=0A=
						node =3D jQuery.clone( node, true, true );=0A=
=0A=
						// Keep references to cloned scripts for later restoration=0A=
						if ( hasScripts ) {=0A=
							jQuery.merge( scripts, getAll( node, "script" ) );=0A=
						}=0A=
					}=0A=
=0A=
					callback.call( this[i], node, i );=0A=
				}=0A=
=0A=
				if ( hasScripts ) {=0A=
					doc =3D scripts[ scripts.length - 1 ].ownerDocument;=0A=
=0A=
					// Reenable scripts=0A=
					jQuery.map( scripts, restoreScript );=0A=
=0A=
					// Evaluate executable scripts on first document insertion=0A=
					for ( i =3D 0; i < hasScripts; i++ ) {=0A=
						node =3D scripts[ i ];=0A=
						if ( rscriptType.test( node.type || "" ) &&=0A=
							!jQuery._data( node, "globalEval" ) && jQuery.contains( doc, node =
) ) {=0A=
=0A=
							if ( node.src ) {=0A=
								// Optional AJAX dependency, but won't run scripts if not present=0A=
								if ( jQuery._evalUrl ) {=0A=
									jQuery._evalUrl( node.src );=0A=
								}=0A=
							} else {=0A=
								jQuery.globalEval( ( node.text || node.textContent || =
node.innerHTML || "" ).replace( rcleanScript, "" ) );=0A=
							}=0A=
						}=0A=
					}=0A=
				}=0A=
=0A=
				// Fix #11809: Avoid leaking memory=0A=
				fragment =3D first =3D null;=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	}=0A=
});=0A=
=0A=
jQuery.each({=0A=
	appendTo: "append",=0A=
	prependTo: "prepend",=0A=
	insertBefore: "before",=0A=
	insertAfter: "after",=0A=
	replaceAll: "replaceWith"=0A=
}, function( name, original ) {=0A=
	jQuery.fn[ name ] =3D function( selector ) {=0A=
		var elems,=0A=
			i =3D 0,=0A=
			ret =3D [],=0A=
			insert =3D jQuery( selector ),=0A=
			last =3D insert.length - 1;=0A=
=0A=
		for ( ; i <=3D last; i++ ) {=0A=
			elems =3D i =3D=3D=3D last ? this : this.clone(true);=0A=
			jQuery( insert[i] )[ original ]( elems );=0A=
=0A=
			// Modern browsers can apply jQuery collections as arrays, but oldIE =
needs a .get()=0A=
			push.apply( ret, elems.get() );=0A=
		}=0A=
=0A=
		return this.pushStack( ret );=0A=
	};=0A=
});=0A=
=0A=
=0A=
var iframe,=0A=
	elemdisplay =3D {};=0A=
=0A=
/**=0A=
 * Retrieve the actual display of a element=0A=
 * @param {String} name nodeName of the element=0A=
 * @param {Object} doc Document object=0A=
 */=0A=
// Called only from within defaultDisplay=0A=
function actualDisplay( name, doc ) {=0A=
	var style,=0A=
		elem =3D jQuery( doc.createElement( name ) ).appendTo( doc.body ),=0A=
=0A=
		// getDefaultComputedStyle might be reliably used only on attached =
element=0A=
		display =3D window.getDefaultComputedStyle && ( style =3D =
window.getDefaultComputedStyle( elem[ 0 ] ) ) ?=0A=
=0A=
			// Use of this method is a temporary fix (more like optmization) =
until something better comes along,=0A=
			// since it was removed from specification and supported only in FF=0A=
			style.display : jQuery.css( elem[ 0 ], "display" );=0A=
=0A=
	// We don't have any data stored on the element,=0A=
	// so use "detach" method as fast way to get rid of the element=0A=
	elem.detach();=0A=
=0A=
	return display;=0A=
}=0A=
=0A=
/**=0A=
 * Try to determine the default display value of an element=0A=
 * @param {String} nodeName=0A=
 */=0A=
function defaultDisplay( nodeName ) {=0A=
	var doc =3D document,=0A=
		display =3D elemdisplay[ nodeName ];=0A=
=0A=
	if ( !display ) {=0A=
		display =3D actualDisplay( nodeName, doc );=0A=
=0A=
		// If the simple way fails, read from inside an iframe=0A=
		if ( display =3D=3D=3D "none" || !display ) {=0A=
=0A=
			// Use the already-created iframe if possible=0A=
			iframe =3D (iframe || jQuery( "<iframe frameborder=3D'0' width=3D'0' =
height=3D'0'/>" )).appendTo( doc.documentElement );=0A=
=0A=
			// Always write a new HTML skeleton so Webkit and Firefox don't choke =
on reuse=0A=
			doc =3D ( iframe[ 0 ].contentWindow || iframe[ 0 ].contentDocument =
).document;=0A=
=0A=
			// Support: IE=0A=
			doc.write();=0A=
			doc.close();=0A=
=0A=
			display =3D actualDisplay( nodeName, doc );=0A=
			iframe.detach();=0A=
		}=0A=
=0A=
		// Store the correct default display=0A=
		elemdisplay[ nodeName ] =3D display;=0A=
	}=0A=
=0A=
	return display;=0A=
}=0A=
=0A=
=0A=
(function() {=0A=
	var shrinkWrapBlocksVal;=0A=
=0A=
	support.shrinkWrapBlocks =3D function() {=0A=
		if ( shrinkWrapBlocksVal !=3D null ) {=0A=
			return shrinkWrapBlocksVal;=0A=
		}=0A=
=0A=
		// Will be changed later if needed.=0A=
		shrinkWrapBlocksVal =3D false;=0A=
=0A=
		// Minified: var b,c,d=0A=
		var div, body, container;=0A=
=0A=
		body =3D document.getElementsByTagName( "body" )[ 0 ];=0A=
		if ( !body || !body.style ) {=0A=
			// Test fired too early or in an unsupported environment, exit.=0A=
			return;=0A=
		}=0A=
=0A=
		// Setup=0A=
		div =3D document.createElement( "div" );=0A=
		container =3D document.createElement( "div" );=0A=
		container.style.cssText =3D =
"position:absolute;border:0;width:0;height:0;top:0;left:-9999px";=0A=
		body.appendChild( container ).appendChild( div );=0A=
=0A=
		// Support: IE6=0A=
		// Check if elements with layout shrink-wrap their children=0A=
		if ( typeof div.style.zoom !=3D=3D strundefined ) {=0A=
			// Reset CSS: box-sizing; display; margin; border=0A=
			div.style.cssText =3D=0A=
				// Support: Firefox<29, Android 2.3=0A=
				// Vendor-prefix box-sizing=0A=
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +=0A=
				"box-sizing:content-box;display:block;margin:0;border:0;" +=0A=
				"padding:1px;width:1px;zoom:1";=0A=
			div.appendChild( document.createElement( "div" ) ).style.width =3D =
"5px";=0A=
			shrinkWrapBlocksVal =3D div.offsetWidth !=3D=3D 3;=0A=
		}=0A=
=0A=
		body.removeChild( container );=0A=
=0A=
		return shrinkWrapBlocksVal;=0A=
	};=0A=
=0A=
})();=0A=
var rmargin =3D (/^margin/);=0A=
=0A=
var rnumnonpx =3D new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );=0A=
=0A=
=0A=
=0A=
var getStyles, curCSS,=0A=
	rposition =3D /^(top|right|bottom|left)$/;=0A=
=0A=
if ( window.getComputedStyle ) {=0A=
	getStyles =3D function( elem ) {=0A=
		// Support: IE<=3D11+, Firefox<=3D30+ (#15098, #14150)=0A=
		// IE throws on elements created in popups=0A=
		// FF meanwhile throws on frame elements through =
"defaultView.getComputedStyle"=0A=
		if ( elem.ownerDocument.defaultView.opener ) {=0A=
			return elem.ownerDocument.defaultView.getComputedStyle( elem, null );=0A=
		}=0A=
=0A=
		return window.getComputedStyle( elem, null );=0A=
	};=0A=
=0A=
	curCSS =3D function( elem, name, computed ) {=0A=
		var width, minWidth, maxWidth, ret,=0A=
			style =3D elem.style;=0A=
=0A=
		computed =3D computed || getStyles( elem );=0A=
=0A=
		// getPropertyValue is only needed for .css('filter') in IE9, see =
#12537=0A=
		ret =3D computed ? computed.getPropertyValue( name ) || computed[ name =
] : undefined;=0A=
=0A=
		if ( computed ) {=0A=
=0A=
			if ( ret =3D=3D=3D "" && !jQuery.contains( elem.ownerDocument, elem ) =
) {=0A=
				ret =3D jQuery.style( elem, name );=0A=
			}=0A=
=0A=
			// A tribute to the "awesome hack by Dean Edwards"=0A=
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used =
value" for margin-right=0A=
			// Safari 5.1.7 (at least) returns percentage for a larger set of =
values, but width seems to be reliably pixels=0A=
			// this is against the CSSOM draft spec: =
http://dev.w3.org/csswg/cssom/#resolved-values=0A=
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {=0A=
=0A=
				// Remember the original values=0A=
				width =3D style.width;=0A=
				minWidth =3D style.minWidth;=0A=
				maxWidth =3D style.maxWidth;=0A=
=0A=
				// Put in the new values to get a computed value out=0A=
				style.minWidth =3D style.maxWidth =3D style.width =3D ret;=0A=
				ret =3D computed.width;=0A=
=0A=
				// Revert the changed values=0A=
				style.width =3D width;=0A=
				style.minWidth =3D minWidth;=0A=
				style.maxWidth =3D maxWidth;=0A=
			}=0A=
		}=0A=
=0A=
		// Support: IE=0A=
		// IE returns zIndex value as an integer.=0A=
		return ret =3D=3D=3D undefined ?=0A=
			ret :=0A=
			ret + "";=0A=
	};=0A=
} else if ( document.documentElement.currentStyle ) {=0A=
	getStyles =3D function( elem ) {=0A=
		return elem.currentStyle;=0A=
	};=0A=
=0A=
	curCSS =3D function( elem, name, computed ) {=0A=
		var left, rs, rsLeft, ret,=0A=
			style =3D elem.style;=0A=
=0A=
		computed =3D computed || getStyles( elem );=0A=
		ret =3D computed ? computed[ name ] : undefined;=0A=
=0A=
		// Avoid setting ret to empty string here=0A=
		// so we don't default to auto=0A=
		if ( ret =3D=3D null && style && style[ name ] ) {=0A=
			ret =3D style[ name ];=0A=
		}=0A=
=0A=
		// From the awesome hack by Dean Edwards=0A=
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291=0A=
=0A=
		// If we're not dealing with a regular pixel number=0A=
		// but a number that has a weird ending, we need to convert it to =
pixels=0A=
		// but not position css attributes, as those are proportional to the =
parent element instead=0A=
		// and we can't measure the parent instead because it might trigger a =
"stacking dolls" problem=0A=
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {=0A=
=0A=
			// Remember the original values=0A=
			left =3D style.left;=0A=
			rs =3D elem.runtimeStyle;=0A=
			rsLeft =3D rs && rs.left;=0A=
=0A=
			// Put in the new values to get a computed value out=0A=
			if ( rsLeft ) {=0A=
				rs.left =3D elem.currentStyle.left;=0A=
			}=0A=
			style.left =3D name =3D=3D=3D "fontSize" ? "1em" : ret;=0A=
			ret =3D style.pixelLeft + "px";=0A=
=0A=
			// Revert the changed values=0A=
			style.left =3D left;=0A=
			if ( rsLeft ) {=0A=
				rs.left =3D rsLeft;=0A=
			}=0A=
		}=0A=
=0A=
		// Support: IE=0A=
		// IE returns zIndex value as an integer.=0A=
		return ret =3D=3D=3D undefined ?=0A=
			ret :=0A=
			ret + "" || "auto";=0A=
	};=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
function addGetHookIf( conditionFn, hookFn ) {=0A=
	// Define the hook, we'll check on the first run if it's really needed.=0A=
	return {=0A=
		get: function() {=0A=
			var condition =3D conditionFn();=0A=
=0A=
			if ( condition =3D=3D null ) {=0A=
				// The test was not ready at this point; screw the hook this time=0A=
				// but check again when needed next time.=0A=
				return;=0A=
			}=0A=
=0A=
			if ( condition ) {=0A=
				// Hook not needed (or it's not possible to use it due to missing =
dependency),=0A=
				// remove it.=0A=
				// Since there are no other hooks for marginRight, remove the whole =
object.=0A=
				delete this.get;=0A=
				return;=0A=
			}=0A=
=0A=
			// Hook needed; redefine it so that the support test is not executed =
again.=0A=
=0A=
			return (this.get =3D hookFn).apply( this, arguments );=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
=0A=
(function() {=0A=
	// Minified: var b,c,d,e,f,g, h,i=0A=
	var div, style, a, pixelPositionVal, boxSizingReliableVal,=0A=
		reliableHiddenOffsetsVal, reliableMarginRightVal;=0A=
=0A=
	// Setup=0A=
	div =3D document.createElement( "div" );=0A=
	div.innerHTML =3D "  <link/><table></table><a href=3D'/a'>a</a><input =
type=3D'checkbox'/>";=0A=
	a =3D div.getElementsByTagName( "a" )[ 0 ];=0A=
	style =3D a && a.style;=0A=
=0A=
	// Finish early in limited (non-browser) environments=0A=
	if ( !style ) {=0A=
		return;=0A=
	}=0A=
=0A=
	style.cssText =3D "float:left;opacity:.5";=0A=
=0A=
	// Support: IE<9=0A=
	// Make sure that element opacity exists (as opposed to filter)=0A=
	support.opacity =3D style.opacity =3D=3D=3D "0.5";=0A=
=0A=
	// Verify style float existence=0A=
	// (IE uses styleFloat instead of cssFloat)=0A=
	support.cssFloat =3D !!style.cssFloat;=0A=
=0A=
	div.style.backgroundClip =3D "content-box";=0A=
	div.cloneNode( true ).style.backgroundClip =3D "";=0A=
	support.clearCloneStyle =3D div.style.backgroundClip =3D=3D=3D =
"content-box";=0A=
=0A=
	// Support: Firefox<29, Android 2.3=0A=
	// Vendor-prefix box-sizing=0A=
	support.boxSizing =3D style.boxSizing =3D=3D=3D "" || =
style.MozBoxSizing =3D=3D=3D "" ||=0A=
		style.WebkitBoxSizing =3D=3D=3D "";=0A=
=0A=
	jQuery.extend(support, {=0A=
		reliableHiddenOffsets: function() {=0A=
			if ( reliableHiddenOffsetsVal =3D=3D null ) {=0A=
				computeStyleTests();=0A=
			}=0A=
			return reliableHiddenOffsetsVal;=0A=
		},=0A=
=0A=
		boxSizingReliable: function() {=0A=
			if ( boxSizingReliableVal =3D=3D null ) {=0A=
				computeStyleTests();=0A=
			}=0A=
			return boxSizingReliableVal;=0A=
		},=0A=
=0A=
		pixelPosition: function() {=0A=
			if ( pixelPositionVal =3D=3D null ) {=0A=
				computeStyleTests();=0A=
			}=0A=
			return pixelPositionVal;=0A=
		},=0A=
=0A=
		// Support: Android 2.3=0A=
		reliableMarginRight: function() {=0A=
			if ( reliableMarginRightVal =3D=3D null ) {=0A=
				computeStyleTests();=0A=
			}=0A=
			return reliableMarginRightVal;=0A=
		}=0A=
	});=0A=
=0A=
	function computeStyleTests() {=0A=
		// Minified: var b,c,d,j=0A=
		var div, body, container, contents;=0A=
=0A=
		body =3D document.getElementsByTagName( "body" )[ 0 ];=0A=
		if ( !body || !body.style ) {=0A=
			// Test fired too early or in an unsupported environment, exit.=0A=
			return;=0A=
		}=0A=
=0A=
		// Setup=0A=
		div =3D document.createElement( "div" );=0A=
		container =3D document.createElement( "div" );=0A=
		container.style.cssText =3D =
"position:absolute;border:0;width:0;height:0;top:0;left:-9999px";=0A=
		body.appendChild( container ).appendChild( div );=0A=
=0A=
		div.style.cssText =3D=0A=
			// Support: Firefox<29, Android 2.3=0A=
			// Vendor-prefix box-sizing=0A=
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;" +=0A=
			"box-sizing:border-box;display:block;margin-top:1%;top:1%;" +=0A=
			"border:1px;padding:1px;width:4px;position:absolute";=0A=
=0A=
		// Support: IE<9=0A=
		// Assume reasonable values in the absence of getComputedStyle=0A=
		pixelPositionVal =3D boxSizingReliableVal =3D false;=0A=
		reliableMarginRightVal =3D true;=0A=
=0A=
		// Check for getComputedStyle so that this code is not run in IE<9.=0A=
		if ( window.getComputedStyle ) {=0A=
			pixelPositionVal =3D ( window.getComputedStyle( div, null ) || {} =
).top !=3D=3D "1%";=0A=
			boxSizingReliableVal =3D=0A=
				( window.getComputedStyle( div, null ) || { width: "4px" } ).width =
=3D=3D=3D "4px";=0A=
=0A=
			// Support: Android 2.3=0A=
			// Div with explicit width and no margin-right incorrectly=0A=
			// gets computed margin-right based on width of container (#3333)=0A=
			// WebKit Bug 13343 - getComputedStyle returns wrong value for =
margin-right=0A=
			contents =3D div.appendChild( document.createElement( "div" ) );=0A=
=0A=
			// Reset CSS: box-sizing; display; margin; border; padding=0A=
			contents.style.cssText =3D div.style.cssText =3D=0A=
				// Support: Firefox<29, Android 2.3=0A=
				// Vendor-prefix box-sizing=0A=
				"-webkit-box-sizing:content-box;-moz-box-sizing:content-box;" +=0A=
				"box-sizing:content-box;display:block;margin:0;border:0;padding:0";=0A=
			contents.style.marginRight =3D contents.style.width =3D "0";=0A=
			div.style.width =3D "1px";=0A=
=0A=
			reliableMarginRightVal =3D=0A=
				!parseFloat( ( window.getComputedStyle( contents, null ) || {} =
).marginRight );=0A=
=0A=
			div.removeChild( contents );=0A=
		}=0A=
=0A=
		// Support: IE8=0A=
		// Check if table cells still have offsetWidth/Height when they are set=0A=
		// to display:none and there are still other visible table cells in a=0A=
		// table row; if so, offsetWidth/Height are not reliable for use when=0A=
		// determining if an element has been hidden directly using=0A=
		// display:none (it is still safe to use offsets if a parent element is=0A=
		// hidden; don safety goggles and see bug #4512 for more information).=0A=
		div.innerHTML =3D "<table><tr><td></td><td>t</td></tr></table>";=0A=
		contents =3D div.getElementsByTagName( "td" );=0A=
		contents[ 0 ].style.cssText =3D =
"margin:0;border:0;padding:0;display:none";=0A=
		reliableHiddenOffsetsVal =3D contents[ 0 ].offsetHeight =3D=3D=3D 0;=0A=
		if ( reliableHiddenOffsetsVal ) {=0A=
			contents[ 0 ].style.display =3D "";=0A=
			contents[ 1 ].style.display =3D "none";=0A=
			reliableHiddenOffsetsVal =3D contents[ 0 ].offsetHeight =3D=3D=3D 0;=0A=
		}=0A=
=0A=
		body.removeChild( container );=0A=
	}=0A=
=0A=
})();=0A=
=0A=
=0A=
// A method for quickly swapping in/out CSS properties to get correct =
calculations.=0A=
jQuery.swap =3D function( elem, options, callback, args ) {=0A=
	var ret, name,=0A=
		old =3D {};=0A=
=0A=
	// Remember the old values, and insert the new ones=0A=
	for ( name in options ) {=0A=
		old[ name ] =3D elem.style[ name ];=0A=
		elem.style[ name ] =3D options[ name ];=0A=
	}=0A=
=0A=
	ret =3D callback.apply( elem, args || [] );=0A=
=0A=
	// Revert the old values=0A=
	for ( name in options ) {=0A=
		elem.style[ name ] =3D old[ name ];=0A=
	}=0A=
=0A=
	return ret;=0A=
};=0A=
=0A=
=0A=
var=0A=
		ralpha =3D /alpha\([^)]*\)/i,=0A=
	ropacity =3D /opacity\s*=3D\s*([^)]*)/,=0A=
=0A=
	// swappable if display is none or starts with table except "table", =
"table-cell", or "table-caption"=0A=
	// see here for display values: =
https://developer.mozilla.org/en-US/docs/CSS/display=0A=
	rdisplayswap =3D /^(none|table(?!-c[ea]).+)/,=0A=
	rnumsplit =3D new RegExp( "^(" + pnum + ")(.*)$", "i" ),=0A=
	rrelNum =3D new RegExp( "^([+-])=3D(" + pnum + ")", "i" ),=0A=
=0A=
	cssShow =3D { position: "absolute", visibility: "hidden", display: =
"block" },=0A=
	cssNormalTransform =3D {=0A=
		letterSpacing: "0",=0A=
		fontWeight: "400"=0A=
	},=0A=
=0A=
	cssPrefixes =3D [ "Webkit", "O", "Moz", "ms" ];=0A=
=0A=
=0A=
// return a css property mapped to a potentially vendor prefixed property=0A=
function vendorPropName( style, name ) {=0A=
=0A=
	// shortcut for names that are not vendor prefixed=0A=
	if ( name in style ) {=0A=
		return name;=0A=
	}=0A=
=0A=
	// check for vendor prefixed names=0A=
	var capName =3D name.charAt(0).toUpperCase() + name.slice(1),=0A=
		origName =3D name,=0A=
		i =3D cssPrefixes.length;=0A=
=0A=
	while ( i-- ) {=0A=
		name =3D cssPrefixes[ i ] + capName;=0A=
		if ( name in style ) {=0A=
			return name;=0A=
		}=0A=
	}=0A=
=0A=
	return origName;=0A=
}=0A=
=0A=
function showHide( elements, show ) {=0A=
	var display, elem, hidden,=0A=
		values =3D [],=0A=
		index =3D 0,=0A=
		length =3D elements.length;=0A=
=0A=
	for ( ; index < length; index++ ) {=0A=
		elem =3D elements[ index ];=0A=
		if ( !elem.style ) {=0A=
			continue;=0A=
		}=0A=
=0A=
		values[ index ] =3D jQuery._data( elem, "olddisplay" );=0A=
		display =3D elem.style.display;=0A=
		if ( show ) {=0A=
			// Reset the inline display of this element to learn if it is=0A=
			// being hidden by cascaded rules or not=0A=
			if ( !values[ index ] && display =3D=3D=3D "none" ) {=0A=
				elem.style.display =3D "";=0A=
			}=0A=
=0A=
			// Set elements which have been overridden with display: none=0A=
			// in a stylesheet to whatever the default browser style is=0A=
			// for such an element=0A=
			if ( elem.style.display =3D=3D=3D "" && isHidden( elem ) ) {=0A=
				values[ index ] =3D jQuery._data( elem, "olddisplay", =
defaultDisplay(elem.nodeName) );=0A=
			}=0A=
		} else {=0A=
			hidden =3D isHidden( elem );=0A=
=0A=
			if ( display && display !=3D=3D "none" || !hidden ) {=0A=
				jQuery._data( elem, "olddisplay", hidden ? display : jQuery.css( =
elem, "display" ) );=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	// Set the display of most of the elements in a second loop=0A=
	// to avoid the constant reflow=0A=
	for ( index =3D 0; index < length; index++ ) {=0A=
		elem =3D elements[ index ];=0A=
		if ( !elem.style ) {=0A=
			continue;=0A=
		}=0A=
		if ( !show || elem.style.display =3D=3D=3D "none" || =
elem.style.display =3D=3D=3D "" ) {=0A=
			elem.style.display =3D show ? values[ index ] || "" : "none";=0A=
		}=0A=
	}=0A=
=0A=
	return elements;=0A=
}=0A=
=0A=
function setPositiveNumber( elem, value, subtract ) {=0A=
	var matches =3D rnumsplit.exec( value );=0A=
	return matches ?=0A=
		// Guard against undefined "subtract", e.g., when used as in cssHooks=0A=
		Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || =
"px" ) :=0A=
		value;=0A=
}=0A=
=0A=
function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {=0A=
	var i =3D extra =3D=3D=3D ( isBorderBox ? "border" : "content" ) ?=0A=
		// If we already have the right measurement, avoid augmentation=0A=
		4 :=0A=
		// Otherwise initialize for horizontal or vertical properties=0A=
		name =3D=3D=3D "width" ? 1 : 0,=0A=
=0A=
		val =3D 0;=0A=
=0A=
	for ( ; i < 4; i +=3D 2 ) {=0A=
		// both box models exclude margin, so add it if we want it=0A=
		if ( extra =3D=3D=3D "margin" ) {=0A=
			val +=3D jQuery.css( elem, extra + cssExpand[ i ], true, styles );=0A=
		}=0A=
=0A=
		if ( isBorderBox ) {=0A=
			// border-box includes padding, so remove it if we want content=0A=
			if ( extra =3D=3D=3D "content" ) {=0A=
				val -=3D jQuery.css( elem, "padding" + cssExpand[ i ], true, styles =
);=0A=
			}=0A=
=0A=
			// at this point, extra isn't border nor margin, so remove border=0A=
			if ( extra !=3D=3D "margin" ) {=0A=
				val -=3D jQuery.css( elem, "border" + cssExpand[ i ] + "Width", =
true, styles );=0A=
			}=0A=
		} else {=0A=
			// at this point, extra isn't content, so add padding=0A=
			val +=3D jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );=0A=
=0A=
			// at this point, extra isn't content nor padding, so add border=0A=
			if ( extra !=3D=3D "padding" ) {=0A=
				val +=3D jQuery.css( elem, "border" + cssExpand[ i ] + "Width", =
true, styles );=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	return val;=0A=
}=0A=
=0A=
function getWidthOrHeight( elem, name, extra ) {=0A=
=0A=
	// Start with offset property, which is equivalent to the border-box =
value=0A=
	var valueIsBorderBox =3D true,=0A=
		val =3D name =3D=3D=3D "width" ? elem.offsetWidth : elem.offsetHeight,=0A=
		styles =3D getStyles( elem ),=0A=
		isBorderBox =3D support.boxSizing && jQuery.css( elem, "boxSizing", =
false, styles ) =3D=3D=3D "border-box";=0A=
=0A=
	// some non-html elements return undefined for offsetWidth, so check =
for null/undefined=0A=
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=3D649285=0A=
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=3D491668=0A=
	if ( val <=3D 0 || val =3D=3D null ) {=0A=
		// Fall back to computed then uncomputed css if necessary=0A=
		val =3D curCSS( elem, name, styles );=0A=
		if ( val < 0 || val =3D=3D null ) {=0A=
			val =3D elem.style[ name ];=0A=
		}=0A=
=0A=
		// Computed unit is not pixels. Stop here and return.=0A=
		if ( rnumnonpx.test(val) ) {=0A=
			return val;=0A=
		}=0A=
=0A=
		// we need the check for style in case a browser which returns =
unreliable values=0A=
		// for getComputedStyle silently falls back to the reliable elem.style=0A=
		valueIsBorderBox =3D isBorderBox && ( support.boxSizingReliable() || =
val =3D=3D=3D elem.style[ name ] );=0A=
=0A=
		// Normalize "", auto, and prepare for extra=0A=
		val =3D parseFloat( val ) || 0;=0A=
	}=0A=
=0A=
	// use the active box-sizing model to add/subtract irrelevant styles=0A=
	return ( val +=0A=
		augmentWidthOrHeight(=0A=
			elem,=0A=
			name,=0A=
			extra || ( isBorderBox ? "border" : "content" ),=0A=
			valueIsBorderBox,=0A=
			styles=0A=
		)=0A=
	) + "px";=0A=
}=0A=
=0A=
jQuery.extend({=0A=
	// Add in style property hooks for overriding the default=0A=
	// behavior of getting and setting a style property=0A=
	cssHooks: {=0A=
		opacity: {=0A=
			get: function( elem, computed ) {=0A=
				if ( computed ) {=0A=
					// We should always get a number back from opacity=0A=
					var ret =3D curCSS( elem, "opacity" );=0A=
					return ret =3D=3D=3D "" ? "1" : ret;=0A=
				}=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	// Don't automatically add "px" to these possibly-unitless properties=0A=
	cssNumber: {=0A=
		"columnCount": true,=0A=
		"fillOpacity": true,=0A=
		"flexGrow": true,=0A=
		"flexShrink": true,=0A=
		"fontWeight": true,=0A=
		"lineHeight": true,=0A=
		"opacity": true,=0A=
		"order": true,=0A=
		"orphans": true,=0A=
		"widows": true,=0A=
		"zIndex": true,=0A=
		"zoom": true=0A=
	},=0A=
=0A=
	// Add in properties whose names you wish to fix before=0A=
	// setting or getting the value=0A=
	cssProps: {=0A=
		// normalize float css property=0A=
		"float": support.cssFloat ? "cssFloat" : "styleFloat"=0A=
	},=0A=
=0A=
	// Get and set the style property on a DOM Node=0A=
	style: function( elem, name, value, extra ) {=0A=
		// Don't set styles on text and comment nodes=0A=
		if ( !elem || elem.nodeType =3D=3D=3D 3 || elem.nodeType =3D=3D=3D 8 =
|| !elem.style ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Make sure that we're working with the right name=0A=
		var ret, type, hooks,=0A=
			origName =3D jQuery.camelCase( name ),=0A=
			style =3D elem.style;=0A=
=0A=
		name =3D jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] =
=3D vendorPropName( style, origName ) );=0A=
=0A=
		// gets hook for the prefixed version=0A=
		// followed by the unprefixed version=0A=
		hooks =3D jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];=0A=
=0A=
		// Check if we're setting a value=0A=
		if ( value !=3D=3D undefined ) {=0A=
			type =3D typeof value;=0A=
=0A=
			// convert relative number strings (+=3D or -=3D) to relative =
numbers. #7345=0A=
			if ( type =3D=3D=3D "string" && (ret =3D rrelNum.exec( value )) ) {=0A=
				value =3D ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, =
name ) );=0A=
				// Fixes bug #9237=0A=
				type =3D "number";=0A=
			}=0A=
=0A=
			// Make sure that null and NaN values aren't set. See: #7116=0A=
			if ( value =3D=3D null || value !=3D=3D value ) {=0A=
				return;=0A=
			}=0A=
=0A=
			// If a number was passed in, add 'px' to the (except for certain CSS =
properties)=0A=
			if ( type =3D=3D=3D "number" && !jQuery.cssNumber[ origName ] ) {=0A=
				value +=3D "px";=0A=
			}=0A=
=0A=
			// Fixes #8908, it can be done more correctly by specifing setters in =
cssHooks,=0A=
			// but it would mean to define eight (for every problematic property) =
identical functions=0A=
			if ( !support.clearCloneStyle && value =3D=3D=3D "" && =
name.indexOf("background") =3D=3D=3D 0 ) {=0A=
				style[ name ] =3D "inherit";=0A=
			}=0A=
=0A=
			// If a hook was provided, use that value, otherwise just set the =
specified value=0A=
			if ( !hooks || !("set" in hooks) || (value =3D hooks.set( elem, =
value, extra )) !=3D=3D undefined ) {=0A=
=0A=
				// Support: IE=0A=
				// Swallow errors from 'invalid' CSS values (#5509)=0A=
				try {=0A=
					style[ name ] =3D value;=0A=
				} catch(e) {}=0A=
			}=0A=
=0A=
		} else {=0A=
			// If a hook was provided get the non-computed value from there=0A=
			if ( hooks && "get" in hooks && (ret =3D hooks.get( elem, false, =
extra )) !=3D=3D undefined ) {=0A=
				return ret;=0A=
			}=0A=
=0A=
			// Otherwise just get the value from the style object=0A=
			return style[ name ];=0A=
		}=0A=
	},=0A=
=0A=
	css: function( elem, name, extra, styles ) {=0A=
		var num, val, hooks,=0A=
			origName =3D jQuery.camelCase( name );=0A=
=0A=
		// Make sure that we're working with the right name=0A=
		name =3D jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] =
=3D vendorPropName( elem.style, origName ) );=0A=
=0A=
		// gets hook for the prefixed version=0A=
		// followed by the unprefixed version=0A=
		hooks =3D jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];=0A=
=0A=
		// If a hook was provided get the computed value from there=0A=
		if ( hooks && "get" in hooks ) {=0A=
			val =3D hooks.get( elem, true, extra );=0A=
		}=0A=
=0A=
		// Otherwise, if a way to get the computed value exists, use that=0A=
		if ( val =3D=3D=3D undefined ) {=0A=
			val =3D curCSS( elem, name, styles );=0A=
		}=0A=
=0A=
		//convert "normal" to computed value=0A=
		if ( val =3D=3D=3D "normal" && name in cssNormalTransform ) {=0A=
			val =3D cssNormalTransform[ name ];=0A=
		}=0A=
=0A=
		// Return, converting to number if forced or a qualifier was provided =
and val looks numeric=0A=
		if ( extra =3D=3D=3D "" || extra ) {=0A=
			num =3D parseFloat( val );=0A=
			return extra =3D=3D=3D true || jQuery.isNumeric( num ) ? num || 0 : =
val;=0A=
		}=0A=
		return val;=0A=
	}=0A=
});=0A=
=0A=
jQuery.each([ "height", "width" ], function( i, name ) {=0A=
	jQuery.cssHooks[ name ] =3D {=0A=
		get: function( elem, computed, extra ) {=0A=
			if ( computed ) {=0A=
				// certain elements can have dimension info if we invisibly show them=0A=
				// however, it must have a current display style that would benefit =
from this=0A=
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) && =
elem.offsetWidth =3D=3D=3D 0 ?=0A=
					jQuery.swap( elem, cssShow, function() {=0A=
						return getWidthOrHeight( elem, name, extra );=0A=
					}) :=0A=
					getWidthOrHeight( elem, name, extra );=0A=
			}=0A=
		},=0A=
=0A=
		set: function( elem, value, extra ) {=0A=
			var styles =3D extra && getStyles( elem );=0A=
			return setPositiveNumber( elem, value, extra ?=0A=
				augmentWidthOrHeight(=0A=
					elem,=0A=
					name,=0A=
					extra,=0A=
					support.boxSizing && jQuery.css( elem, "boxSizing", false, styles ) =
=3D=3D=3D "border-box",=0A=
					styles=0A=
				) : 0=0A=
			);=0A=
		}=0A=
	};=0A=
});=0A=
=0A=
if ( !support.opacity ) {=0A=
	jQuery.cssHooks.opacity =3D {=0A=
		get: function( elem, computed ) {=0A=
			// IE uses filters for opacity=0A=
			return ropacity.test( (computed && elem.currentStyle ? =
elem.currentStyle.filter : elem.style.filter) || "" ) ?=0A=
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :=0A=
				computed ? "1" : "";=0A=
		},=0A=
=0A=
		set: function( elem, value ) {=0A=
			var style =3D elem.style,=0A=
				currentStyle =3D elem.currentStyle,=0A=
				opacity =3D jQuery.isNumeric( value ) ? "alpha(opacity=3D" + value * =
100 + ")" : "",=0A=
				filter =3D currentStyle && currentStyle.filter || style.filter || "";=0A=
=0A=
			// IE has trouble with opacity if it does not have layout=0A=
			// Force it by setting the zoom level=0A=
			style.zoom =3D 1;=0A=
=0A=
			// if setting opacity to 1, and no other filters exist - attempt to =
remove filter attribute #6652=0A=
			// if value =3D=3D=3D "", then remove inline opacity #12685=0A=
			if ( ( value >=3D 1 || value =3D=3D=3D "" ) &&=0A=
					jQuery.trim( filter.replace( ralpha, "" ) ) =3D=3D=3D "" &&=0A=
					style.removeAttribute ) {=0A=
=0A=
				// Setting style.filter to null, "" & " " still leave "filter:" in =
the cssText=0A=
				// if "filter:" is present at all, clearType is disabled, we want to =
avoid this=0A=
				// style.removeAttribute is IE Only, but so apparently is this code =
path...=0A=
				style.removeAttribute( "filter" );=0A=
=0A=
				// if there is no filter style applied in a css rule or unset inline =
opacity, we are done=0A=
				if ( value =3D=3D=3D "" || currentStyle && !currentStyle.filter ) {=0A=
					return;=0A=
				}=0A=
			}=0A=
=0A=
			// otherwise, set new filter values=0A=
			style.filter =3D ralpha.test( filter ) ?=0A=
				filter.replace( ralpha, opacity ) :=0A=
				filter + " " + opacity;=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
jQuery.cssHooks.marginRight =3D addGetHookIf( =
support.reliableMarginRight,=0A=
	function( elem, computed ) {=0A=
		if ( computed ) {=0A=
			// WebKit Bug 13343 - getComputedStyle returns wrong value for =
margin-right=0A=
			// Work around by temporarily setting element display to inline-block=0A=
			return jQuery.swap( elem, { "display": "inline-block" },=0A=
				curCSS, [ elem, "marginRight" ] );=0A=
		}=0A=
	}=0A=
);=0A=
=0A=
// These hooks are used by animate to expand properties=0A=
jQuery.each({=0A=
	margin: "",=0A=
	padding: "",=0A=
	border: "Width"=0A=
}, function( prefix, suffix ) {=0A=
	jQuery.cssHooks[ prefix + suffix ] =3D {=0A=
		expand: function( value ) {=0A=
			var i =3D 0,=0A=
				expanded =3D {},=0A=
=0A=
				// assumes a single number if not a string=0A=
				parts =3D typeof value =3D=3D=3D "string" ? value.split(" ") : [ =
value ];=0A=
=0A=
			for ( ; i < 4; i++ ) {=0A=
				expanded[ prefix + cssExpand[ i ] + suffix ] =3D=0A=
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];=0A=
			}=0A=
=0A=
			return expanded;=0A=
		}=0A=
	};=0A=
=0A=
	if ( !rmargin.test( prefix ) ) {=0A=
		jQuery.cssHooks[ prefix + suffix ].set =3D setPositiveNumber;=0A=
	}=0A=
});=0A=
=0A=
jQuery.fn.extend({=0A=
	css: function( name, value ) {=0A=
		return access( this, function( elem, name, value ) {=0A=
			var styles, len,=0A=
				map =3D {},=0A=
				i =3D 0;=0A=
=0A=
			if ( jQuery.isArray( name ) ) {=0A=
				styles =3D getStyles( elem );=0A=
				len =3D name.length;=0A=
=0A=
				for ( ; i < len; i++ ) {=0A=
					map[ name[ i ] ] =3D jQuery.css( elem, name[ i ], false, styles );=0A=
				}=0A=
=0A=
				return map;=0A=
			}=0A=
=0A=
			return value !=3D=3D undefined ?=0A=
				jQuery.style( elem, name, value ) :=0A=
				jQuery.css( elem, name );=0A=
		}, name, value, arguments.length > 1 );=0A=
	},=0A=
	show: function() {=0A=
		return showHide( this, true );=0A=
	},=0A=
	hide: function() {=0A=
		return showHide( this );=0A=
	},=0A=
	toggle: function( state ) {=0A=
		if ( typeof state =3D=3D=3D "boolean" ) {=0A=
			return state ? this.show() : this.hide();=0A=
		}=0A=
=0A=
		return this.each(function() {=0A=
			if ( isHidden( this ) ) {=0A=
				jQuery( this ).show();=0A=
			} else {=0A=
				jQuery( this ).hide();=0A=
			}=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
=0A=
function Tween( elem, options, prop, end, easing ) {=0A=
	return new Tween.prototype.init( elem, options, prop, end, easing );=0A=
}=0A=
jQuery.Tween =3D Tween;=0A=
=0A=
Tween.prototype =3D {=0A=
	constructor: Tween,=0A=
	init: function( elem, options, prop, end, easing, unit ) {=0A=
		this.elem =3D elem;=0A=
		this.prop =3D prop;=0A=
		this.easing =3D easing || "swing";=0A=
		this.options =3D options;=0A=
		this.start =3D this.now =3D this.cur();=0A=
		this.end =3D end;=0A=
		this.unit =3D unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );=0A=
	},=0A=
	cur: function() {=0A=
		var hooks =3D Tween.propHooks[ this.prop ];=0A=
=0A=
		return hooks && hooks.get ?=0A=
			hooks.get( this ) :=0A=
			Tween.propHooks._default.get( this );=0A=
	},=0A=
	run: function( percent ) {=0A=
		var eased,=0A=
			hooks =3D Tween.propHooks[ this.prop ];=0A=
=0A=
		if ( this.options.duration ) {=0A=
			this.pos =3D eased =3D jQuery.easing[ this.easing ](=0A=
				percent, this.options.duration * percent, 0, 1, this.options.duration=0A=
			);=0A=
		} else {=0A=
			this.pos =3D eased =3D percent;=0A=
		}=0A=
		this.now =3D ( this.end - this.start ) * eased + this.start;=0A=
=0A=
		if ( this.options.step ) {=0A=
			this.options.step.call( this.elem, this.now, this );=0A=
		}=0A=
=0A=
		if ( hooks && hooks.set ) {=0A=
			hooks.set( this );=0A=
		} else {=0A=
			Tween.propHooks._default.set( this );=0A=
		}=0A=
		return this;=0A=
	}=0A=
};=0A=
=0A=
Tween.prototype.init.prototype =3D Tween.prototype;=0A=
=0A=
Tween.propHooks =3D {=0A=
	_default: {=0A=
		get: function( tween ) {=0A=
			var result;=0A=
=0A=
			if ( tween.elem[ tween.prop ] !=3D null &&=0A=
				(!tween.elem.style || tween.elem.style[ tween.prop ] =3D=3D null) ) {=0A=
				return tween.elem[ tween.prop ];=0A=
			}=0A=
=0A=
			// passing an empty string as a 3rd parameter to .css will =
automatically=0A=
			// attempt a parseFloat and fallback to a string if the parse fails=0A=
			// so, simple values such as "10px" are parsed to Float.=0A=
			// complex values such as "rotate(1rad)" are returned as is.=0A=
			result =3D jQuery.css( tween.elem, tween.prop, "" );=0A=
			// Empty strings, null, undefined and "auto" are converted to 0.=0A=
			return !result || result =3D=3D=3D "auto" ? 0 : result;=0A=
		},=0A=
		set: function( tween ) {=0A=
			// use step hook for back compat - use cssHook if its there - use =
.style if its=0A=
			// available and use plain properties where available=0A=
			if ( jQuery.fx.step[ tween.prop ] ) {=0A=
				jQuery.fx.step[ tween.prop ]( tween );=0A=
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ =
tween.prop ] ] !=3D null || jQuery.cssHooks[ tween.prop ] ) ) {=0A=
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );=0A=
			} else {=0A=
				tween.elem[ tween.prop ] =3D tween.now;=0A=
			}=0A=
		}=0A=
	}=0A=
};=0A=
=0A=
// Support: IE <=3D9=0A=
// Panic based approach to setting things on disconnected nodes=0A=
=0A=
Tween.propHooks.scrollTop =3D Tween.propHooks.scrollLeft =3D {=0A=
	set: function( tween ) {=0A=
		if ( tween.elem.nodeType && tween.elem.parentNode ) {=0A=
			tween.elem[ tween.prop ] =3D tween.now;=0A=
		}=0A=
	}=0A=
};=0A=
=0A=
jQuery.easing =3D {=0A=
	linear: function( p ) {=0A=
		return p;=0A=
	},=0A=
	swing: function( p ) {=0A=
		return 0.5 - Math.cos( p * Math.PI ) / 2;=0A=
	}=0A=
};=0A=
=0A=
jQuery.fx =3D Tween.prototype.init;=0A=
=0A=
// Back Compat <1.8 extension point=0A=
jQuery.fx.step =3D {};=0A=
=0A=
=0A=
=0A=
=0A=
var=0A=
	fxNow, timerId,=0A=
	rfxtypes =3D /^(?:toggle|show|hide)$/,=0A=
	rfxnum =3D new RegExp( "^(?:([+-])=3D|)(" + pnum + ")([a-z%]*)$", "i" ),=0A=
	rrun =3D /queueHooks$/,=0A=
	animationPrefilters =3D [ defaultPrefilter ],=0A=
	tweeners =3D {=0A=
		"*": [ function( prop, value ) {=0A=
			var tween =3D this.createTween( prop, value ),=0A=
				target =3D tween.cur(),=0A=
				parts =3D rfxnum.exec( value ),=0A=
				unit =3D parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : =
"px" ),=0A=
=0A=
				// Starting value computation is required for potential unit =
mismatches=0A=
				start =3D ( jQuery.cssNumber[ prop ] || unit !=3D=3D "px" && +target =
) &&=0A=
					rfxnum.exec( jQuery.css( tween.elem, prop ) ),=0A=
				scale =3D 1,=0A=
				maxIterations =3D 20;=0A=
=0A=
			if ( start && start[ 3 ] !=3D=3D unit ) {=0A=
				// Trust units reported by jQuery.css=0A=
				unit =3D unit || start[ 3 ];=0A=
=0A=
				// Make sure we update the tween properties later on=0A=
				parts =3D parts || [];=0A=
=0A=
				// Iteratively approximate from a nonzero starting point=0A=
				start =3D +target || 1;=0A=
=0A=
				do {=0A=
					// If previous iteration zeroed out, double until we get *something*=0A=
					// Use a string for doubling factor so we don't accidentally see =
scale as unchanged below=0A=
					scale =3D scale || ".5";=0A=
=0A=
					// Adjust and apply=0A=
					start =3D start / scale;=0A=
					jQuery.style( tween.elem, prop, start + unit );=0A=
=0A=
				// Update scale, tolerating zero or NaN from tween.cur()=0A=
				// And breaking the loop if scale is unchanged or perfect, or if =
we've just had enough=0A=
				} while ( scale !=3D=3D (scale =3D tween.cur() / target) && scale =
!=3D=3D 1 && --maxIterations );=0A=
			}=0A=
=0A=
			// Update tween properties=0A=
			if ( parts ) {=0A=
				start =3D tween.start =3D +start || +target || 0;=0A=
				tween.unit =3D unit;=0A=
				// If a +=3D/-=3D token was provided, we're doing a relative =
animation=0A=
				tween.end =3D parts[ 1 ] ?=0A=
					start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :=0A=
					+parts[ 2 ];=0A=
			}=0A=
=0A=
			return tween;=0A=
		} ]=0A=
	};=0A=
=0A=
// Animations created synchronously will run synchronously=0A=
function createFxNow() {=0A=
	setTimeout(function() {=0A=
		fxNow =3D undefined;=0A=
	});=0A=
	return ( fxNow =3D jQuery.now() );=0A=
}=0A=
=0A=
// Generate parameters to create a standard animation=0A=
function genFx( type, includeWidth ) {=0A=
	var which,=0A=
		attrs =3D { height: type },=0A=
		i =3D 0;=0A=
=0A=
	// if we include width, step value is 1 to do all cssExpand values,=0A=
	// if we don't include width, step value is 2 to skip over Left and =
Right=0A=
	includeWidth =3D includeWidth ? 1 : 0;=0A=
	for ( ; i < 4 ; i +=3D 2 - includeWidth ) {=0A=
		which =3D cssExpand[ i ];=0A=
		attrs[ "margin" + which ] =3D attrs[ "padding" + which ] =3D type;=0A=
	}=0A=
=0A=
	if ( includeWidth ) {=0A=
		attrs.opacity =3D attrs.width =3D type;=0A=
	}=0A=
=0A=
	return attrs;=0A=
}=0A=
=0A=
function createTween( value, prop, animation ) {=0A=
	var tween,=0A=
		collection =3D ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),=0A=
		index =3D 0,=0A=
		length =3D collection.length;=0A=
	for ( ; index < length; index++ ) {=0A=
		if ( (tween =3D collection[ index ].call( animation, prop, value )) ) {=0A=
=0A=
			// we're done with this property=0A=
			return tween;=0A=
		}=0A=
	}=0A=
}=0A=
=0A=
function defaultPrefilter( elem, props, opts ) {=0A=
	/* jshint validthis: true */=0A=
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,=0A=
		anim =3D this,=0A=
		orig =3D {},=0A=
		style =3D elem.style,=0A=
		hidden =3D elem.nodeType && isHidden( elem ),=0A=
		dataShow =3D jQuery._data( elem, "fxshow" );=0A=
=0A=
	// handle queue: false promises=0A=
	if ( !opts.queue ) {=0A=
		hooks =3D jQuery._queueHooks( elem, "fx" );=0A=
		if ( hooks.unqueued =3D=3D null ) {=0A=
			hooks.unqueued =3D 0;=0A=
			oldfire =3D hooks.empty.fire;=0A=
			hooks.empty.fire =3D function() {=0A=
				if ( !hooks.unqueued ) {=0A=
					oldfire();=0A=
				}=0A=
			};=0A=
		}=0A=
		hooks.unqueued++;=0A=
=0A=
		anim.always(function() {=0A=
			// doing this makes sure that the complete handler will be called=0A=
			// before this completes=0A=
			anim.always(function() {=0A=
				hooks.unqueued--;=0A=
				if ( !jQuery.queue( elem, "fx" ).length ) {=0A=
					hooks.empty.fire();=0A=
				}=0A=
			});=0A=
		});=0A=
	}=0A=
=0A=
	// height/width overflow pass=0A=
	if ( elem.nodeType =3D=3D=3D 1 && ( "height" in props || "width" in =
props ) ) {=0A=
		// Make sure that nothing sneaks out=0A=
		// Record all 3 overflow attributes because IE does not=0A=
		// change the overflow attribute when overflowX and=0A=
		// overflowY are set to the same value=0A=
		opts.overflow =3D [ style.overflow, style.overflowX, style.overflowY ];=0A=
=0A=
		// Set display property to inline-block for height/width=0A=
		// animations on inline elements that are having width/height animated=0A=
		display =3D jQuery.css( elem, "display" );=0A=
=0A=
		// Test default display if display is currently "none"=0A=
		checkDisplay =3D display =3D=3D=3D "none" ?=0A=
			jQuery._data( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) =
: display;=0A=
=0A=
		if ( checkDisplay =3D=3D=3D "inline" && jQuery.css( elem, "float" ) =
=3D=3D=3D "none" ) {=0A=
=0A=
			// inline-level elements accept inline-block;=0A=
			// block-level elements need to be inline with layout=0A=
			if ( !support.inlineBlockNeedsLayout || defaultDisplay( elem.nodeName =
) =3D=3D=3D "inline" ) {=0A=
				style.display =3D "inline-block";=0A=
			} else {=0A=
				style.zoom =3D 1;=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	if ( opts.overflow ) {=0A=
		style.overflow =3D "hidden";=0A=
		if ( !support.shrinkWrapBlocks() ) {=0A=
			anim.always(function() {=0A=
				style.overflow =3D opts.overflow[ 0 ];=0A=
				style.overflowX =3D opts.overflow[ 1 ];=0A=
				style.overflowY =3D opts.overflow[ 2 ];=0A=
			});=0A=
		}=0A=
	}=0A=
=0A=
	// show/hide pass=0A=
	for ( prop in props ) {=0A=
		value =3D props[ prop ];=0A=
		if ( rfxtypes.exec( value ) ) {=0A=
			delete props[ prop ];=0A=
			toggle =3D toggle || value =3D=3D=3D "toggle";=0A=
			if ( value =3D=3D=3D ( hidden ? "hide" : "show" ) ) {=0A=
=0A=
				// If there is dataShow left over from a stopped hide or show and we =
are going to proceed with show, we should pretend to be hidden=0A=
				if ( value =3D=3D=3D "show" && dataShow && dataShow[ prop ] !=3D=3D =
undefined ) {=0A=
					hidden =3D true;=0A=
				} else {=0A=
					continue;=0A=
				}=0A=
			}=0A=
			orig[ prop ] =3D dataShow && dataShow[ prop ] || jQuery.style( elem, =
prop );=0A=
=0A=
		// Any non-fx value stops us from restoring the original display value=0A=
		} else {=0A=
			display =3D undefined;=0A=
		}=0A=
	}=0A=
=0A=
	if ( !jQuery.isEmptyObject( orig ) ) {=0A=
		if ( dataShow ) {=0A=
			if ( "hidden" in dataShow ) {=0A=
				hidden =3D dataShow.hidden;=0A=
			}=0A=
		} else {=0A=
			dataShow =3D jQuery._data( elem, "fxshow", {} );=0A=
		}=0A=
=0A=
		// store state if its toggle - enables .stop().toggle() to "reverse"=0A=
		if ( toggle ) {=0A=
			dataShow.hidden =3D !hidden;=0A=
		}=0A=
		if ( hidden ) {=0A=
			jQuery( elem ).show();=0A=
		} else {=0A=
			anim.done(function() {=0A=
				jQuery( elem ).hide();=0A=
			});=0A=
		}=0A=
		anim.done(function() {=0A=
			var prop;=0A=
			jQuery._removeData( elem, "fxshow" );=0A=
			for ( prop in orig ) {=0A=
				jQuery.style( elem, prop, orig[ prop ] );=0A=
			}=0A=
		});=0A=
		for ( prop in orig ) {=0A=
			tween =3D createTween( hidden ? dataShow[ prop ] : 0, prop, anim );=0A=
=0A=
			if ( !( prop in dataShow ) ) {=0A=
				dataShow[ prop ] =3D tween.start;=0A=
				if ( hidden ) {=0A=
					tween.end =3D tween.start;=0A=
					tween.start =3D prop =3D=3D=3D "width" || prop =3D=3D=3D "height" ? =
1 : 0;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
	// If this is a noop like .hide().hide(), restore an overwritten =
display value=0A=
	} else if ( (display =3D=3D=3D "none" ? defaultDisplay( elem.nodeName ) =
: display) =3D=3D=3D "inline" ) {=0A=
		style.display =3D display;=0A=
	}=0A=
}=0A=
=0A=
function propFilter( props, specialEasing ) {=0A=
	var index, name, easing, value, hooks;=0A=
=0A=
	// camelCase, specialEasing and expand cssHook pass=0A=
	for ( index in props ) {=0A=
		name =3D jQuery.camelCase( index );=0A=
		easing =3D specialEasing[ name ];=0A=
		value =3D props[ index ];=0A=
		if ( jQuery.isArray( value ) ) {=0A=
			easing =3D value[ 1 ];=0A=
			value =3D props[ index ] =3D value[ 0 ];=0A=
		}=0A=
=0A=
		if ( index !=3D=3D name ) {=0A=
			props[ name ] =3D value;=0A=
			delete props[ index ];=0A=
		}=0A=
=0A=
		hooks =3D jQuery.cssHooks[ name ];=0A=
		if ( hooks && "expand" in hooks ) {=0A=
			value =3D hooks.expand( value );=0A=
			delete props[ name ];=0A=
=0A=
			// not quite $.extend, this wont overwrite keys already present.=0A=
			// also - reusing 'index' from above because we have the correct =
"name"=0A=
			for ( index in value ) {=0A=
				if ( !( index in props ) ) {=0A=
					props[ index ] =3D value[ index ];=0A=
					specialEasing[ index ] =3D easing;=0A=
				}=0A=
			}=0A=
		} else {=0A=
			specialEasing[ name ] =3D easing;=0A=
		}=0A=
	}=0A=
}=0A=
=0A=
function Animation( elem, properties, options ) {=0A=
	var result,=0A=
		stopped,=0A=
		index =3D 0,=0A=
		length =3D animationPrefilters.length,=0A=
		deferred =3D jQuery.Deferred().always( function() {=0A=
			// don't match elem in the :animated selector=0A=
			delete tick.elem;=0A=
		}),=0A=
		tick =3D function() {=0A=
			if ( stopped ) {=0A=
				return false;=0A=
			}=0A=
			var currentTime =3D fxNow || createFxNow(),=0A=
				remaining =3D Math.max( 0, animation.startTime + animation.duration =
- currentTime ),=0A=
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)=0A=
				temp =3D remaining / animation.duration || 0,=0A=
				percent =3D 1 - temp,=0A=
				index =3D 0,=0A=
				length =3D animation.tweens.length;=0A=
=0A=
			for ( ; index < length ; index++ ) {=0A=
				animation.tweens[ index ].run( percent );=0A=
			}=0A=
=0A=
			deferred.notifyWith( elem, [ animation, percent, remaining ]);=0A=
=0A=
			if ( percent < 1 && length ) {=0A=
				return remaining;=0A=
			} else {=0A=
				deferred.resolveWith( elem, [ animation ] );=0A=
				return false;=0A=
			}=0A=
		},=0A=
		animation =3D deferred.promise({=0A=
			elem: elem,=0A=
			props: jQuery.extend( {}, properties ),=0A=
			opts: jQuery.extend( true, { specialEasing: {} }, options ),=0A=
			originalProperties: properties,=0A=
			originalOptions: options,=0A=
			startTime: fxNow || createFxNow(),=0A=
			duration: options.duration,=0A=
			tweens: [],=0A=
			createTween: function( prop, end ) {=0A=
				var tween =3D jQuery.Tween( elem, animation.opts, prop, end,=0A=
						animation.opts.specialEasing[ prop ] || animation.opts.easing );=0A=
				animation.tweens.push( tween );=0A=
				return tween;=0A=
			},=0A=
			stop: function( gotoEnd ) {=0A=
				var index =3D 0,=0A=
					// if we are going to the end, we want to run all the tweens=0A=
					// otherwise we skip this part=0A=
					length =3D gotoEnd ? animation.tweens.length : 0;=0A=
				if ( stopped ) {=0A=
					return this;=0A=
				}=0A=
				stopped =3D true;=0A=
				for ( ; index < length ; index++ ) {=0A=
					animation.tweens[ index ].run( 1 );=0A=
				}=0A=
=0A=
				// resolve when we played the last frame=0A=
				// otherwise, reject=0A=
				if ( gotoEnd ) {=0A=
					deferred.resolveWith( elem, [ animation, gotoEnd ] );=0A=
				} else {=0A=
					deferred.rejectWith( elem, [ animation, gotoEnd ] );=0A=
				}=0A=
				return this;=0A=
			}=0A=
		}),=0A=
		props =3D animation.props;=0A=
=0A=
	propFilter( props, animation.opts.specialEasing );=0A=
=0A=
	for ( ; index < length ; index++ ) {=0A=
		result =3D animationPrefilters[ index ].call( animation, elem, props, =
animation.opts );=0A=
		if ( result ) {=0A=
			return result;=0A=
		}=0A=
	}=0A=
=0A=
	jQuery.map( props, createTween, animation );=0A=
=0A=
	if ( jQuery.isFunction( animation.opts.start ) ) {=0A=
		animation.opts.start.call( elem, animation );=0A=
	}=0A=
=0A=
	jQuery.fx.timer(=0A=
		jQuery.extend( tick, {=0A=
			elem: elem,=0A=
			anim: animation,=0A=
			queue: animation.opts.queue=0A=
		})=0A=
	);=0A=
=0A=
	// attach callbacks from options=0A=
	return animation.progress( animation.opts.progress )=0A=
		.done( animation.opts.done, animation.opts.complete )=0A=
		.fail( animation.opts.fail )=0A=
		.always( animation.opts.always );=0A=
}=0A=
=0A=
jQuery.Animation =3D jQuery.extend( Animation, {=0A=
	tweener: function( props, callback ) {=0A=
		if ( jQuery.isFunction( props ) ) {=0A=
			callback =3D props;=0A=
			props =3D [ "*" ];=0A=
		} else {=0A=
			props =3D props.split(" ");=0A=
		}=0A=
=0A=
		var prop,=0A=
			index =3D 0,=0A=
			length =3D props.length;=0A=
=0A=
		for ( ; index < length ; index++ ) {=0A=
			prop =3D props[ index ];=0A=
			tweeners[ prop ] =3D tweeners[ prop ] || [];=0A=
			tweeners[ prop ].unshift( callback );=0A=
		}=0A=
	},=0A=
=0A=
	prefilter: function( callback, prepend ) {=0A=
		if ( prepend ) {=0A=
			animationPrefilters.unshift( callback );=0A=
		} else {=0A=
			animationPrefilters.push( callback );=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
jQuery.speed =3D function( speed, easing, fn ) {=0A=
	var opt =3D speed && typeof speed =3D=3D=3D "object" ? jQuery.extend( =
{}, speed ) : {=0A=
		complete: fn || !fn && easing ||=0A=
			jQuery.isFunction( speed ) && speed,=0A=
		duration: speed,=0A=
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && =
easing=0A=
	};=0A=
=0A=
	opt.duration =3D jQuery.fx.off ? 0 : typeof opt.duration =3D=3D=3D =
"number" ? opt.duration :=0A=
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : =
jQuery.fx.speeds._default;=0A=
=0A=
	// normalize opt.queue - true/undefined/null -> "fx"=0A=
	if ( opt.queue =3D=3D null || opt.queue =3D=3D=3D true ) {=0A=
		opt.queue =3D "fx";=0A=
	}=0A=
=0A=
	// Queueing=0A=
	opt.old =3D opt.complete;=0A=
=0A=
	opt.complete =3D function() {=0A=
		if ( jQuery.isFunction( opt.old ) ) {=0A=
			opt.old.call( this );=0A=
		}=0A=
=0A=
		if ( opt.queue ) {=0A=
			jQuery.dequeue( this, opt.queue );=0A=
		}=0A=
	};=0A=
=0A=
	return opt;=0A=
};=0A=
=0A=
jQuery.fn.extend({=0A=
	fadeTo: function( speed, to, easing, callback ) {=0A=
=0A=
		// show any hidden elements after setting opacity to 0=0A=
		return this.filter( isHidden ).css( "opacity", 0 ).show()=0A=
=0A=
			// animate to the value specified=0A=
			.end().animate({ opacity: to }, speed, easing, callback );=0A=
	},=0A=
	animate: function( prop, speed, easing, callback ) {=0A=
		var empty =3D jQuery.isEmptyObject( prop ),=0A=
			optall =3D jQuery.speed( speed, easing, callback ),=0A=
			doAnimation =3D function() {=0A=
				// Operate on a copy of prop so per-property easing won't be lost=0A=
				var anim =3D Animation( this, jQuery.extend( {}, prop ), optall );=0A=
=0A=
				// Empty animations, or finishing resolves immediately=0A=
				if ( empty || jQuery._data( this, "finish" ) ) {=0A=
					anim.stop( true );=0A=
				}=0A=
			};=0A=
			doAnimation.finish =3D doAnimation;=0A=
=0A=
		return empty || optall.queue =3D=3D=3D false ?=0A=
			this.each( doAnimation ) :=0A=
			this.queue( optall.queue, doAnimation );=0A=
	},=0A=
	stop: function( type, clearQueue, gotoEnd ) {=0A=
		var stopQueue =3D function( hooks ) {=0A=
			var stop =3D hooks.stop;=0A=
			delete hooks.stop;=0A=
			stop( gotoEnd );=0A=
		};=0A=
=0A=
		if ( typeof type !=3D=3D "string" ) {=0A=
			gotoEnd =3D clearQueue;=0A=
			clearQueue =3D type;=0A=
			type =3D undefined;=0A=
		}=0A=
		if ( clearQueue && type !=3D=3D false ) {=0A=
			this.queue( type || "fx", [] );=0A=
		}=0A=
=0A=
		return this.each(function() {=0A=
			var dequeue =3D true,=0A=
				index =3D type !=3D null && type + "queueHooks",=0A=
				timers =3D jQuery.timers,=0A=
				data =3D jQuery._data( this );=0A=
=0A=
			if ( index ) {=0A=
				if ( data[ index ] && data[ index ].stop ) {=0A=
					stopQueue( data[ index ] );=0A=
				}=0A=
			} else {=0A=
				for ( index in data ) {=0A=
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {=0A=
						stopQueue( data[ index ] );=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			for ( index =3D timers.length; index--; ) {=0A=
				if ( timers[ index ].elem =3D=3D=3D this && (type =3D=3D null || =
timers[ index ].queue =3D=3D=3D type) ) {=0A=
					timers[ index ].anim.stop( gotoEnd );=0A=
					dequeue =3D false;=0A=
					timers.splice( index, 1 );=0A=
				}=0A=
			}=0A=
=0A=
			// start the next in the queue if the last step wasn't forced=0A=
			// timers currently will call their complete callbacks, which will =
dequeue=0A=
			// but only if they were gotoEnd=0A=
			if ( dequeue || !gotoEnd ) {=0A=
				jQuery.dequeue( this, type );=0A=
			}=0A=
		});=0A=
	},=0A=
	finish: function( type ) {=0A=
		if ( type !=3D=3D false ) {=0A=
			type =3D type || "fx";=0A=
		}=0A=
		return this.each(function() {=0A=
			var index,=0A=
				data =3D jQuery._data( this ),=0A=
				queue =3D data[ type + "queue" ],=0A=
				hooks =3D data[ type + "queueHooks" ],=0A=
				timers =3D jQuery.timers,=0A=
				length =3D queue ? queue.length : 0;=0A=
=0A=
			// enable finishing flag on private data=0A=
			data.finish =3D true;=0A=
=0A=
			// empty the queue first=0A=
			jQuery.queue( this, type, [] );=0A=
=0A=
			if ( hooks && hooks.stop ) {=0A=
				hooks.stop.call( this, true );=0A=
			}=0A=
=0A=
			// look for any active animations, and finish them=0A=
			for ( index =3D timers.length; index--; ) {=0A=
				if ( timers[ index ].elem =3D=3D=3D this && timers[ index ].queue =
=3D=3D=3D type ) {=0A=
					timers[ index ].anim.stop( true );=0A=
					timers.splice( index, 1 );=0A=
				}=0A=
			}=0A=
=0A=
			// look for any animations in the old queue and finish them=0A=
			for ( index =3D 0; index < length; index++ ) {=0A=
				if ( queue[ index ] && queue[ index ].finish ) {=0A=
					queue[ index ].finish.call( this );=0A=
				}=0A=
			}=0A=
=0A=
			// turn off finishing flag=0A=
			delete data.finish;=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {=0A=
	var cssFn =3D jQuery.fn[ name ];=0A=
	jQuery.fn[ name ] =3D function( speed, easing, callback ) {=0A=
		return speed =3D=3D null || typeof speed =3D=3D=3D "boolean" ?=0A=
			cssFn.apply( this, arguments ) :=0A=
			this.animate( genFx( name, true ), speed, easing, callback );=0A=
	};=0A=
});=0A=
=0A=
// Generate shortcuts for custom animations=0A=
jQuery.each({=0A=
	slideDown: genFx("show"),=0A=
	slideUp: genFx("hide"),=0A=
	slideToggle: genFx("toggle"),=0A=
	fadeIn: { opacity: "show" },=0A=
	fadeOut: { opacity: "hide" },=0A=
	fadeToggle: { opacity: "toggle" }=0A=
}, function( name, props ) {=0A=
	jQuery.fn[ name ] =3D function( speed, easing, callback ) {=0A=
		return this.animate( props, speed, easing, callback );=0A=
	};=0A=
});=0A=
=0A=
jQuery.timers =3D [];=0A=
jQuery.fx.tick =3D function() {=0A=
	var timer,=0A=
		timers =3D jQuery.timers,=0A=
		i =3D 0;=0A=
=0A=
	fxNow =3D jQuery.now();=0A=
=0A=
	for ( ; i < timers.length; i++ ) {=0A=
		timer =3D timers[ i ];=0A=
		// Checks the timer has not already been removed=0A=
		if ( !timer() && timers[ i ] =3D=3D=3D timer ) {=0A=
			timers.splice( i--, 1 );=0A=
		}=0A=
	}=0A=
=0A=
	if ( !timers.length ) {=0A=
		jQuery.fx.stop();=0A=
	}=0A=
	fxNow =3D undefined;=0A=
};=0A=
=0A=
jQuery.fx.timer =3D function( timer ) {=0A=
	jQuery.timers.push( timer );=0A=
	if ( timer() ) {=0A=
		jQuery.fx.start();=0A=
	} else {=0A=
		jQuery.timers.pop();=0A=
	}=0A=
};=0A=
=0A=
jQuery.fx.interval =3D 13;=0A=
=0A=
jQuery.fx.start =3D function() {=0A=
	if ( !timerId ) {=0A=
		timerId =3D setInterval( jQuery.fx.tick, jQuery.fx.interval );=0A=
	}=0A=
};=0A=
=0A=
jQuery.fx.stop =3D function() {=0A=
	clearInterval( timerId );=0A=
	timerId =3D null;=0A=
};=0A=
=0A=
jQuery.fx.speeds =3D {=0A=
	slow: 600,=0A=
	fast: 200,=0A=
	// Default speed=0A=
	_default: 400=0A=
};=0A=
=0A=
=0A=
// Based off of the plugin by Clint Helfers, with permission.=0A=
// http://blindsignals.com/index.php/2009/07/jquery-delay/=0A=
jQuery.fn.delay =3D function( time, type ) {=0A=
	time =3D jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;=0A=
	type =3D type || "fx";=0A=
=0A=
	return this.queue( type, function( next, hooks ) {=0A=
		var timeout =3D setTimeout( next, time );=0A=
		hooks.stop =3D function() {=0A=
			clearTimeout( timeout );=0A=
		};=0A=
	});=0A=
};=0A=
=0A=
=0A=
(function() {=0A=
	// Minified: var a,b,c,d,e=0A=
	var input, div, select, a, opt;=0A=
=0A=
	// Setup=0A=
	div =3D document.createElement( "div" );=0A=
	div.setAttribute( "className", "t" );=0A=
	div.innerHTML =3D "  <link/><table></table><a href=3D'/a'>a</a><input =
type=3D'checkbox'/>";=0A=
	a =3D div.getElementsByTagName("a")[ 0 ];=0A=
=0A=
	// First batch of tests.=0A=
	select =3D document.createElement("select");=0A=
	opt =3D select.appendChild( document.createElement("option") );=0A=
	input =3D div.getElementsByTagName("input")[ 0 ];=0A=
=0A=
	a.style.cssText =3D "top:1px";=0A=
=0A=
	// Test setAttribute on camelCase class. If it works, we need attrFixes =
when doing get/setAttribute (ie6/7)=0A=
	support.getSetAttribute =3D div.className !=3D=3D "t";=0A=
=0A=
	// Get the style information from getAttribute=0A=
	// (IE uses .cssText instead)=0A=
	support.style =3D /top/.test( a.getAttribute("style") );=0A=
=0A=
	// Make sure that URLs aren't manipulated=0A=
	// (IE normalizes it by default)=0A=
	support.hrefNormalized =3D a.getAttribute("href") =3D=3D=3D "/a";=0A=
=0A=
	// Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)=0A=
	support.checkOn =3D !!input.value;=0A=
=0A=
	// Make sure that a selected-by-default option has a working selected =
property.=0A=
	// (WebKit defaults to false instead of true, IE too, if it's in an =
optgroup)=0A=
	support.optSelected =3D opt.selected;=0A=
=0A=
	// Tests for enctype support on a form (#6743)=0A=
	support.enctype =3D !!document.createElement("form").enctype;=0A=
=0A=
	// Make sure that the options inside disabled selects aren't marked as =
disabled=0A=
	// (WebKit marks them as disabled)=0A=
	select.disabled =3D true;=0A=
	support.optDisabled =3D !opt.disabled;=0A=
=0A=
	// Support: IE8 only=0A=
	// Check if we can trust getAttribute("value")=0A=
	input =3D document.createElement( "input" );=0A=
	input.setAttribute( "value", "" );=0A=
	support.input =3D input.getAttribute( "value" ) =3D=3D=3D "";=0A=
=0A=
	// Check if an input maintains its value after becoming a radio=0A=
	input.value =3D "t";=0A=
	input.setAttribute( "type", "radio" );=0A=
	support.radioValue =3D input.value =3D=3D=3D "t";=0A=
})();=0A=
=0A=
=0A=
var rreturn =3D /\r/g;=0A=
=0A=
jQuery.fn.extend({=0A=
	val: function( value ) {=0A=
		var hooks, ret, isFunction,=0A=
			elem =3D this[0];=0A=
=0A=
		if ( !arguments.length ) {=0A=
			if ( elem ) {=0A=
				hooks =3D jQuery.valHooks[ elem.type ] || jQuery.valHooks[ =
elem.nodeName.toLowerCase() ];=0A=
=0A=
				if ( hooks && "get" in hooks && (ret =3D hooks.get( elem, "value" )) =
!=3D=3D undefined ) {=0A=
					return ret;=0A=
				}=0A=
=0A=
				ret =3D elem.value;=0A=
=0A=
				return typeof ret =3D=3D=3D "string" ?=0A=
					// handle most common string cases=0A=
					ret.replace(rreturn, "") :=0A=
					// handle cases where value is null/undef or number=0A=
					ret =3D=3D null ? "" : ret;=0A=
			}=0A=
=0A=
			return;=0A=
		}=0A=
=0A=
		isFunction =3D jQuery.isFunction( value );=0A=
=0A=
		return this.each(function( i ) {=0A=
			var val;=0A=
=0A=
			if ( this.nodeType !=3D=3D 1 ) {=0A=
				return;=0A=
			}=0A=
=0A=
			if ( isFunction ) {=0A=
				val =3D value.call( this, i, jQuery( this ).val() );=0A=
			} else {=0A=
				val =3D value;=0A=
			}=0A=
=0A=
			// Treat null/undefined as ""; convert numbers to string=0A=
			if ( val =3D=3D null ) {=0A=
				val =3D "";=0A=
			} else if ( typeof val =3D=3D=3D "number" ) {=0A=
				val +=3D "";=0A=
			} else if ( jQuery.isArray( val ) ) {=0A=
				val =3D jQuery.map( val, function( value ) {=0A=
					return value =3D=3D null ? "" : value + "";=0A=
				});=0A=
			}=0A=
=0A=
			hooks =3D jQuery.valHooks[ this.type ] || jQuery.valHooks[ =
this.nodeName.toLowerCase() ];=0A=
=0A=
			// If set returns undefined, fall back to normal setting=0A=
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) =
=3D=3D=3D undefined ) {=0A=
				this.value =3D val;=0A=
			}=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
jQuery.extend({=0A=
	valHooks: {=0A=
		option: {=0A=
			get: function( elem ) {=0A=
				var val =3D jQuery.find.attr( elem, "value" );=0A=
				return val !=3D null ?=0A=
					val :=0A=
					// Support: IE10-11+=0A=
					// option.text throws exceptions (#14686, #14858)=0A=
					jQuery.trim( jQuery.text( elem ) );=0A=
			}=0A=
		},=0A=
		select: {=0A=
			get: function( elem ) {=0A=
				var value, option,=0A=
					options =3D elem.options,=0A=
					index =3D elem.selectedIndex,=0A=
					one =3D elem.type =3D=3D=3D "select-one" || index < 0,=0A=
					values =3D one ? null : [],=0A=
					max =3D one ? index + 1 : options.length,=0A=
					i =3D index < 0 ?=0A=
						max :=0A=
						one ? index : 0;=0A=
=0A=
				// Loop through all the selected options=0A=
				for ( ; i < max; i++ ) {=0A=
					option =3D options[ i ];=0A=
=0A=
					// oldIE doesn't update selected after form reset (#2551)=0A=
					if ( ( option.selected || i =3D=3D=3D index ) &&=0A=
							// Don't return options that are disabled or in a disabled =
optgroup=0A=
							( support.optDisabled ? !option.disabled : =
option.getAttribute("disabled") =3D=3D=3D null ) &&=0A=
							( !option.parentNode.disabled || !jQuery.nodeName( =
option.parentNode, "optgroup" ) ) ) {=0A=
=0A=
						// Get the specific value for the option=0A=
						value =3D jQuery( option ).val();=0A=
=0A=
						// We don't need an array for one selects=0A=
						if ( one ) {=0A=
							return value;=0A=
						}=0A=
=0A=
						// Multi-Selects return an array=0A=
						values.push( value );=0A=
					}=0A=
				}=0A=
=0A=
				return values;=0A=
			},=0A=
=0A=
			set: function( elem, value ) {=0A=
				var optionSet, option,=0A=
					options =3D elem.options,=0A=
					values =3D jQuery.makeArray( value ),=0A=
					i =3D options.length;=0A=
=0A=
				while ( i-- ) {=0A=
					option =3D options[ i ];=0A=
=0A=
					if ( jQuery.inArray( jQuery.valHooks.option.get( option ), values ) =
>=3D 0 ) {=0A=
=0A=
						// Support: IE6=0A=
						// When new option element is added to select box we need to=0A=
						// force reflow of newly added node in order to workaround delay=0A=
						// of initialization properties=0A=
						try {=0A=
							option.selected =3D optionSet =3D true;=0A=
=0A=
						} catch ( _ ) {=0A=
=0A=
							// Will be executed only in IE6=0A=
							option.scrollHeight;=0A=
						}=0A=
=0A=
					} else {=0A=
						option.selected =3D false;=0A=
					}=0A=
				}=0A=
=0A=
				// Force browsers to behave consistently when non-matching value is =
set=0A=
				if ( !optionSet ) {=0A=
					elem.selectedIndex =3D -1;=0A=
				}=0A=
=0A=
				return options;=0A=
			}=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
// Radios and checkboxes getter/setter=0A=
jQuery.each([ "radio", "checkbox" ], function() {=0A=
	jQuery.valHooks[ this ] =3D {=0A=
		set: function( elem, value ) {=0A=
			if ( jQuery.isArray( value ) ) {=0A=
				return ( elem.checked =3D jQuery.inArray( jQuery(elem).val(), value =
) >=3D 0 );=0A=
			}=0A=
		}=0A=
	};=0A=
	if ( !support.checkOn ) {=0A=
		jQuery.valHooks[ this ].get =3D function( elem ) {=0A=
			// Support: Webkit=0A=
			// "" is returned instead of "on" if a value isn't specified=0A=
			return elem.getAttribute("value") =3D=3D=3D null ? "on" : elem.value;=0A=
		};=0A=
	}=0A=
});=0A=
=0A=
=0A=
=0A=
=0A=
var nodeHook, boolHook,=0A=
	attrHandle =3D jQuery.expr.attrHandle,=0A=
	ruseDefault =3D /^(?:checked|selected)$/i,=0A=
	getSetAttribute =3D support.getSetAttribute,=0A=
	getSetInput =3D support.input;=0A=
=0A=
jQuery.fn.extend({=0A=
	attr: function( name, value ) {=0A=
		return access( this, jQuery.attr, name, value, arguments.length > 1 );=0A=
	},=0A=
=0A=
	removeAttr: function( name ) {=0A=
		return this.each(function() {=0A=
			jQuery.removeAttr( this, name );=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
jQuery.extend({=0A=
	attr: function( elem, name, value ) {=0A=
		var hooks, ret,=0A=
			nType =3D elem.nodeType;=0A=
=0A=
		// don't get/set attributes on text, comment and attribute nodes=0A=
		if ( !elem || nType =3D=3D=3D 3 || nType =3D=3D=3D 8 || nType =
=3D=3D=3D 2 ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Fallback to prop when attributes are not supported=0A=
		if ( typeof elem.getAttribute =3D=3D=3D strundefined ) {=0A=
			return jQuery.prop( elem, name, value );=0A=
		}=0A=
=0A=
		// All attributes are lowercase=0A=
		// Grab necessary hook if one is defined=0A=
		if ( nType !=3D=3D 1 || !jQuery.isXMLDoc( elem ) ) {=0A=
			name =3D name.toLowerCase();=0A=
			hooks =3D jQuery.attrHooks[ name ] ||=0A=
				( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );=0A=
		}=0A=
=0A=
		if ( value !=3D=3D undefined ) {=0A=
=0A=
			if ( value =3D=3D=3D null ) {=0A=
				jQuery.removeAttr( elem, name );=0A=
=0A=
			} else if ( hooks && "set" in hooks && (ret =3D hooks.set( elem, =
value, name )) !=3D=3D undefined ) {=0A=
				return ret;=0A=
=0A=
			} else {=0A=
				elem.setAttribute( name, value + "" );=0A=
				return value;=0A=
			}=0A=
=0A=
		} else if ( hooks && "get" in hooks && (ret =3D hooks.get( elem, name =
)) !=3D=3D null ) {=0A=
			return ret;=0A=
=0A=
		} else {=0A=
			ret =3D jQuery.find.attr( elem, name );=0A=
=0A=
			// Non-existent attributes return null, we normalize to undefined=0A=
			return ret =3D=3D null ?=0A=
				undefined :=0A=
				ret;=0A=
		}=0A=
	},=0A=
=0A=
	removeAttr: function( elem, value ) {=0A=
		var name, propName,=0A=
			i =3D 0,=0A=
			attrNames =3D value && value.match( rnotwhite );=0A=
=0A=
		if ( attrNames && elem.nodeType =3D=3D=3D 1 ) {=0A=
			while ( (name =3D attrNames[i++]) ) {=0A=
				propName =3D jQuery.propFix[ name ] || name;=0A=
=0A=
				// Boolean attributes get special treatment (#10870)=0A=
				if ( jQuery.expr.match.bool.test( name ) ) {=0A=
					// Set corresponding property to false=0A=
					if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {=0A=
						elem[ propName ] =3D false;=0A=
					// Support: IE<9=0A=
					// Also clear defaultChecked/defaultSelected (if appropriate)=0A=
					} else {=0A=
						elem[ jQuery.camelCase( "default-" + name ) ] =3D=0A=
							elem[ propName ] =3D false;=0A=
					}=0A=
=0A=
				// See #9699 for explanation of this approach (setting first, then =
removal)=0A=
				} else {=0A=
					jQuery.attr( elem, name, "" );=0A=
				}=0A=
=0A=
				elem.removeAttribute( getSetAttribute ? name : propName );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	attrHooks: {=0A=
		type: {=0A=
			set: function( elem, value ) {=0A=
				if ( !support.radioValue && value =3D=3D=3D "radio" && =
jQuery.nodeName(elem, "input") ) {=0A=
					// Setting the type on a radio button after the value resets the =
value in IE6-9=0A=
					// Reset value to default in case type is set after value during =
creation=0A=
					var val =3D elem.value;=0A=
					elem.setAttribute( "type", value );=0A=
					if ( val ) {=0A=
						elem.value =3D val;=0A=
					}=0A=
					return value;=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
// Hook for boolean attributes=0A=
boolHook =3D {=0A=
	set: function( elem, value, name ) {=0A=
		if ( value =3D=3D=3D false ) {=0A=
			// Remove boolean attributes when set to false=0A=
			jQuery.removeAttr( elem, name );=0A=
		} else if ( getSetInput && getSetAttribute || !ruseDefault.test( name =
) ) {=0A=
			// IE<8 needs the *property* name=0A=
			elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || =
name, name );=0A=
=0A=
		// Use defaultChecked and defaultSelected for oldIE=0A=
		} else {=0A=
			elem[ jQuery.camelCase( "default-" + name ) ] =3D elem[ name ] =3D =
true;=0A=
		}=0A=
=0A=
		return name;=0A=
	}=0A=
};=0A=
=0A=
// Retrieve booleans specially=0A=
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, =
name ) {=0A=
=0A=
	var getter =3D attrHandle[ name ] || jQuery.find.attr;=0A=
=0A=
	attrHandle[ name ] =3D getSetInput && getSetAttribute || =
!ruseDefault.test( name ) ?=0A=
		function( elem, name, isXML ) {=0A=
			var ret, handle;=0A=
			if ( !isXML ) {=0A=
				// Avoid an infinite loop by temporarily removing this function from =
the getter=0A=
				handle =3D attrHandle[ name ];=0A=
				attrHandle[ name ] =3D ret;=0A=
				ret =3D getter( elem, name, isXML ) !=3D null ?=0A=
					name.toLowerCase() :=0A=
					null;=0A=
				attrHandle[ name ] =3D handle;=0A=
			}=0A=
			return ret;=0A=
		} :=0A=
		function( elem, name, isXML ) {=0A=
			if ( !isXML ) {=0A=
				return elem[ jQuery.camelCase( "default-" + name ) ] ?=0A=
					name.toLowerCase() :=0A=
					null;=0A=
			}=0A=
		};=0A=
});=0A=
=0A=
// fix oldIE attroperties=0A=
if ( !getSetInput || !getSetAttribute ) {=0A=
	jQuery.attrHooks.value =3D {=0A=
		set: function( elem, value, name ) {=0A=
			if ( jQuery.nodeName( elem, "input" ) ) {=0A=
				// Does not return so that setAttribute is also used=0A=
				elem.defaultValue =3D value;=0A=
			} else {=0A=
				// Use nodeHook if defined (#1954); otherwise setAttribute is fine=0A=
				return nodeHook && nodeHook.set( elem, value, name );=0A=
			}=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
// IE6/7 do not support getting/setting some attributes with =
get/setAttribute=0A=
if ( !getSetAttribute ) {=0A=
=0A=
	// Use this for any attribute in IE6/7=0A=
	// This fixes almost every IE6/7 issue=0A=
	nodeHook =3D {=0A=
		set: function( elem, value, name ) {=0A=
			// Set the existing or create a new attribute node=0A=
			var ret =3D elem.getAttributeNode( name );=0A=
			if ( !ret ) {=0A=
				elem.setAttributeNode(=0A=
					(ret =3D elem.ownerDocument.createAttribute( name ))=0A=
				);=0A=
			}=0A=
=0A=
			ret.value =3D value +=3D "";=0A=
=0A=
			// Break association with cloned elements by also using setAttribute =
(#9646)=0A=
			if ( name =3D=3D=3D "value" || value =3D=3D=3D elem.getAttribute( =
name ) ) {=0A=
				return value;=0A=
			}=0A=
		}=0A=
	};=0A=
=0A=
	// Some attributes are constructed with empty-string values when not =
defined=0A=
	attrHandle.id =3D attrHandle.name =3D attrHandle.coords =3D=0A=
		function( elem, name, isXML ) {=0A=
			var ret;=0A=
			if ( !isXML ) {=0A=
				return (ret =3D elem.getAttributeNode( name )) && ret.value !=3D=3D =
"" ?=0A=
					ret.value :=0A=
					null;=0A=
			}=0A=
		};=0A=
=0A=
	// Fixing value retrieval on a button requires this module=0A=
	jQuery.valHooks.button =3D {=0A=
		get: function( elem, name ) {=0A=
			var ret =3D elem.getAttributeNode( name );=0A=
			if ( ret && ret.specified ) {=0A=
				return ret.value;=0A=
			}=0A=
		},=0A=
		set: nodeHook.set=0A=
	};=0A=
=0A=
	// Set contenteditable to false on removals(#10429)=0A=
	// Setting to empty string throws an error as an invalid value=0A=
	jQuery.attrHooks.contenteditable =3D {=0A=
		set: function( elem, value, name ) {=0A=
			nodeHook.set( elem, value =3D=3D=3D "" ? false : value, name );=0A=
		}=0A=
	};=0A=
=0A=
	// Set width and height to auto instead of 0 on empty string( Bug #8150 =
)=0A=
	// This is for removals=0A=
	jQuery.each([ "width", "height" ], function( i, name ) {=0A=
		jQuery.attrHooks[ name ] =3D {=0A=
			set: function( elem, value ) {=0A=
				if ( value =3D=3D=3D "" ) {=0A=
					elem.setAttribute( name, "auto" );=0A=
					return value;=0A=
				}=0A=
			}=0A=
		};=0A=
	});=0A=
}=0A=
=0A=
if ( !support.style ) {=0A=
	jQuery.attrHooks.style =3D {=0A=
		get: function( elem ) {=0A=
			// Return undefined in the case of empty string=0A=
			// Note: IE uppercases css property names, but if we were to =
.toLowerCase()=0A=
			// .cssText, that would destroy case senstitivity in URL's, like in =
"background"=0A=
			return elem.style.cssText || undefined;=0A=
		},=0A=
		set: function( elem, value ) {=0A=
			return ( elem.style.cssText =3D value + "" );=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
var rfocusable =3D /^(?:input|select|textarea|button|object)$/i,=0A=
	rclickable =3D /^(?:a|area)$/i;=0A=
=0A=
jQuery.fn.extend({=0A=
	prop: function( name, value ) {=0A=
		return access( this, jQuery.prop, name, value, arguments.length > 1 );=0A=
	},=0A=
=0A=
	removeProp: function( name ) {=0A=
		name =3D jQuery.propFix[ name ] || name;=0A=
		return this.each(function() {=0A=
			// try/catch handles cases where IE balks (such as removing a =
property on window)=0A=
			try {=0A=
				this[ name ] =3D undefined;=0A=
				delete this[ name ];=0A=
			} catch( e ) {}=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
jQuery.extend({=0A=
	propFix: {=0A=
		"for": "htmlFor",=0A=
		"class": "className"=0A=
	},=0A=
=0A=
	prop: function( elem, name, value ) {=0A=
		var ret, hooks, notxml,=0A=
			nType =3D elem.nodeType;=0A=
=0A=
		// don't get/set properties on text, comment and attribute nodes=0A=
		if ( !elem || nType =3D=3D=3D 3 || nType =3D=3D=3D 8 || nType =
=3D=3D=3D 2 ) {=0A=
			return;=0A=
		}=0A=
=0A=
		notxml =3D nType !=3D=3D 1 || !jQuery.isXMLDoc( elem );=0A=
=0A=
		if ( notxml ) {=0A=
			// Fix name and attach hooks=0A=
			name =3D jQuery.propFix[ name ] || name;=0A=
			hooks =3D jQuery.propHooks[ name ];=0A=
		}=0A=
=0A=
		if ( value !=3D=3D undefined ) {=0A=
			return hooks && "set" in hooks && (ret =3D hooks.set( elem, value, =
name )) !=3D=3D undefined ?=0A=
				ret :=0A=
				( elem[ name ] =3D value );=0A=
=0A=
		} else {=0A=
			return hooks && "get" in hooks && (ret =3D hooks.get( elem, name )) =
!=3D=3D null ?=0A=
				ret :=0A=
				elem[ name ];=0A=
		}=0A=
	},=0A=
=0A=
	propHooks: {=0A=
		tabIndex: {=0A=
			get: function( elem ) {=0A=
				// elem.tabIndex doesn't always return the correct value when it =
hasn't been explicitly set=0A=
				// =
http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabi=
ndex-values-with-javascript/=0A=
				// Use proper attribute retrieval(#12072)=0A=
				var tabindex =3D jQuery.find.attr( elem, "tabindex" );=0A=
=0A=
				return tabindex ?=0A=
					parseInt( tabindex, 10 ) :=0A=
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName =
) && elem.href ?=0A=
						0 :=0A=
						-1;=0A=
			}=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
// Some attributes require a special call on IE=0A=
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx=0A=
if ( !support.hrefNormalized ) {=0A=
	// href/src property should get the full normalized URL (#10299/#12915)=0A=
	jQuery.each([ "href", "src" ], function( i, name ) {=0A=
		jQuery.propHooks[ name ] =3D {=0A=
			get: function( elem ) {=0A=
				return elem.getAttribute( name, 4 );=0A=
			}=0A=
		};=0A=
	});=0A=
}=0A=
=0A=
// Support: Safari, IE9+=0A=
// mis-reports the default selected property of an option=0A=
// Accessing the parent's selectedIndex property fixes it=0A=
if ( !support.optSelected ) {=0A=
	jQuery.propHooks.selected =3D {=0A=
		get: function( elem ) {=0A=
			var parent =3D elem.parentNode;=0A=
=0A=
			if ( parent ) {=0A=
				parent.selectedIndex;=0A=
=0A=
				// Make sure that it also works with optgroups, see #5701=0A=
				if ( parent.parentNode ) {=0A=
					parent.parentNode.selectedIndex;=0A=
				}=0A=
			}=0A=
			return null;=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
jQuery.each([=0A=
	"tabIndex",=0A=
	"readOnly",=0A=
	"maxLength",=0A=
	"cellSpacing",=0A=
	"cellPadding",=0A=
	"rowSpan",=0A=
	"colSpan",=0A=
	"useMap",=0A=
	"frameBorder",=0A=
	"contentEditable"=0A=
], function() {=0A=
	jQuery.propFix[ this.toLowerCase() ] =3D this;=0A=
});=0A=
=0A=
// IE6/7 call enctype encoding=0A=
if ( !support.enctype ) {=0A=
	jQuery.propFix.enctype =3D "encoding";=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
var rclass =3D /[\t\r\n\f]/g;=0A=
=0A=
jQuery.fn.extend({=0A=
	addClass: function( value ) {=0A=
		var classes, elem, cur, clazz, j, finalValue,=0A=
			i =3D 0,=0A=
			len =3D this.length,=0A=
			proceed =3D typeof value =3D=3D=3D "string" && value;=0A=
=0A=
		if ( jQuery.isFunction( value ) ) {=0A=
			return this.each(function( j ) {=0A=
				jQuery( this ).addClass( value.call( this, j, this.className ) );=0A=
			});=0A=
		}=0A=
=0A=
		if ( proceed ) {=0A=
			// The disjunction here is for better compressibility (see =
removeClass)=0A=
			classes =3D ( value || "" ).match( rnotwhite ) || [];=0A=
=0A=
			for ( ; i < len; i++ ) {=0A=
				elem =3D this[ i ];=0A=
				cur =3D elem.nodeType =3D=3D=3D 1 && ( elem.className ?=0A=
					( " " + elem.className + " " ).replace( rclass, " " ) :=0A=
					" "=0A=
				);=0A=
=0A=
				if ( cur ) {=0A=
					j =3D 0;=0A=
					while ( (clazz =3D classes[j++]) ) {=0A=
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {=0A=
							cur +=3D clazz + " ";=0A=
						}=0A=
					}=0A=
=0A=
					// only assign if different to avoid unneeded rendering.=0A=
					finalValue =3D jQuery.trim( cur );=0A=
					if ( elem.className !=3D=3D finalValue ) {=0A=
						elem.className =3D finalValue;=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	removeClass: function( value ) {=0A=
		var classes, elem, cur, clazz, j, finalValue,=0A=
			i =3D 0,=0A=
			len =3D this.length,=0A=
			proceed =3D arguments.length =3D=3D=3D 0 || typeof value =3D=3D=3D =
"string" && value;=0A=
=0A=
		if ( jQuery.isFunction( value ) ) {=0A=
			return this.each(function( j ) {=0A=
				jQuery( this ).removeClass( value.call( this, j, this.className ) );=0A=
			});=0A=
		}=0A=
		if ( proceed ) {=0A=
			classes =3D ( value || "" ).match( rnotwhite ) || [];=0A=
=0A=
			for ( ; i < len; i++ ) {=0A=
				elem =3D this[ i ];=0A=
				// This expression is here for better compressibility (see addClass)=0A=
				cur =3D elem.nodeType =3D=3D=3D 1 && ( elem.className ?=0A=
					( " " + elem.className + " " ).replace( rclass, " " ) :=0A=
					""=0A=
				);=0A=
=0A=
				if ( cur ) {=0A=
					j =3D 0;=0A=
					while ( (clazz =3D classes[j++]) ) {=0A=
						// Remove *all* instances=0A=
						while ( cur.indexOf( " " + clazz + " " ) >=3D 0 ) {=0A=
							cur =3D cur.replace( " " + clazz + " ", " " );=0A=
						}=0A=
					}=0A=
=0A=
					// only assign if different to avoid unneeded rendering.=0A=
					finalValue =3D value ? jQuery.trim( cur ) : "";=0A=
					if ( elem.className !=3D=3D finalValue ) {=0A=
						elem.className =3D finalValue;=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	toggleClass: function( value, stateVal ) {=0A=
		var type =3D typeof value;=0A=
=0A=
		if ( typeof stateVal =3D=3D=3D "boolean" && type =3D=3D=3D "string" ) {=0A=
			return stateVal ? this.addClass( value ) : this.removeClass( value );=0A=
		}=0A=
=0A=
		if ( jQuery.isFunction( value ) ) {=0A=
			return this.each(function( i ) {=0A=
				jQuery( this ).toggleClass( value.call(this, i, this.className, =
stateVal), stateVal );=0A=
			});=0A=
		}=0A=
=0A=
		return this.each(function() {=0A=
			if ( type =3D=3D=3D "string" ) {=0A=
				// toggle individual class names=0A=
				var className,=0A=
					i =3D 0,=0A=
					self =3D jQuery( this ),=0A=
					classNames =3D value.match( rnotwhite ) || [];=0A=
=0A=
				while ( (className =3D classNames[ i++ ]) ) {=0A=
					// check each className given, space separated list=0A=
					if ( self.hasClass( className ) ) {=0A=
						self.removeClass( className );=0A=
					} else {=0A=
						self.addClass( className );=0A=
					}=0A=
				}=0A=
=0A=
			// Toggle whole class name=0A=
			} else if ( type =3D=3D=3D strundefined || type =3D=3D=3D "boolean" ) =
{=0A=
				if ( this.className ) {=0A=
					// store className if set=0A=
					jQuery._data( this, "__className__", this.className );=0A=
				}=0A=
=0A=
				// If the element has a class name or if we're passed "false",=0A=
				// then remove the whole classname (if there was one, the above =
saved it).=0A=
				// Otherwise bring back whatever was previously saved (if anything),=0A=
				// falling back to the empty string if nothing was stored.=0A=
				this.className =3D this.className || value =3D=3D=3D false ? "" : =
jQuery._data( this, "__className__" ) || "";=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	hasClass: function( selector ) {=0A=
		var className =3D " " + selector + " ",=0A=
			i =3D 0,=0A=
			l =3D this.length;=0A=
		for ( ; i < l; i++ ) {=0A=
			if ( this[i].nodeType =3D=3D=3D 1 && (" " + this[i].className + " =
").replace(rclass, " ").indexOf( className ) >=3D 0 ) {=0A=
				return true;=0A=
			}=0A=
		}=0A=
=0A=
		return false;=0A=
	}=0A=
});=0A=
=0A=
=0A=
=0A=
=0A=
// Return jQuery for attributes-only inclusion=0A=
=0A=
=0A=
jQuery.each( ("blur focus focusin focusout load resize scroll unload =
click dblclick " +=0A=
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " =
+=0A=
	"change select submit keydown keypress keyup error =
contextmenu").split(" "), function( i, name ) {=0A=
=0A=
	// Handle event binding=0A=
	jQuery.fn[ name ] =3D function( data, fn ) {=0A=
		return arguments.length > 0 ?=0A=
			this.on( name, null, data, fn ) :=0A=
			this.trigger( name );=0A=
	};=0A=
});=0A=
=0A=
jQuery.fn.extend({=0A=
	hover: function( fnOver, fnOut ) {=0A=
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );=0A=
	},=0A=
=0A=
	bind: function( types, data, fn ) {=0A=
		return this.on( types, null, data, fn );=0A=
	},=0A=
	unbind: function( types, fn ) {=0A=
		return this.off( types, null, fn );=0A=
	},=0A=
=0A=
	delegate: function( selector, types, data, fn ) {=0A=
		return this.on( types, selector, data, fn );=0A=
	},=0A=
	undelegate: function( selector, types, fn ) {=0A=
		// ( namespace ) or ( selector, types [, fn] )=0A=
		return arguments.length =3D=3D=3D 1 ? this.off( selector, "**" ) : =
this.off( types, selector || "**", fn );=0A=
	}=0A=
});=0A=
=0A=
=0A=
var nonce =3D jQuery.now();=0A=
=0A=
var rquery =3D (/\?/);=0A=
=0A=
=0A=
=0A=
var rvalidtokens =3D =
/(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|=
true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;=0A=
=0A=
jQuery.parseJSON =3D function( data ) {=0A=
	// Attempt to parse using the native JSON parser first=0A=
	if ( window.JSON && window.JSON.parse ) {=0A=
		// Support: Android 2.3=0A=
		// Workaround failure to string-cast null input=0A=
		return window.JSON.parse( data + "" );=0A=
	}=0A=
=0A=
	var requireNonComma,=0A=
		depth =3D null,=0A=
		str =3D jQuery.trim( data + "" );=0A=
=0A=
	// Guard against invalid (and possibly dangerous) input by ensuring =
that nothing remains=0A=
	// after removing valid tokens=0A=
	return str && !jQuery.trim( str.replace( rvalidtokens, function( token, =
comma, open, close ) {=0A=
=0A=
		// Force termination if we see a misplaced comma=0A=
		if ( requireNonComma && comma ) {=0A=
			depth =3D 0;=0A=
		}=0A=
=0A=
		// Perform no more replacements after returning to outermost depth=0A=
		if ( depth =3D=3D=3D 0 ) {=0A=
			return token;=0A=
		}=0A=
=0A=
		// Commas must not follow "[", "{", or ","=0A=
		requireNonComma =3D open || comma;=0A=
=0A=
		// Determine new depth=0A=
		// array/object open ("[" or "{"): depth +=3D true - false (increment)=0A=
		// array/object close ("]" or "}"): depth +=3D false - true (decrement)=0A=
		// other cases ("," or primitive): depth +=3D true - true (numeric =
cast)=0A=
		depth +=3D !close - !open;=0A=
=0A=
		// Remove this token=0A=
		return "";=0A=
	}) ) ?=0A=
		( Function( "return " + str ) )() :=0A=
		jQuery.error( "Invalid JSON: " + data );=0A=
};=0A=
=0A=
=0A=
// Cross-browser xml parsing=0A=
jQuery.parseXML =3D function( data ) {=0A=
	var xml, tmp;=0A=
	if ( !data || typeof data !=3D=3D "string" ) {=0A=
		return null;=0A=
	}=0A=
	try {=0A=
		if ( window.DOMParser ) { // Standard=0A=
			tmp =3D new DOMParser();=0A=
			xml =3D tmp.parseFromString( data, "text/xml" );=0A=
		} else { // IE=0A=
			xml =3D new ActiveXObject( "Microsoft.XMLDOM" );=0A=
			xml.async =3D "false";=0A=
			xml.loadXML( data );=0A=
		}=0A=
	} catch( e ) {=0A=
		xml =3D undefined;=0A=
	}=0A=
	if ( !xml || !xml.documentElement || xml.getElementsByTagName( =
"parsererror" ).length ) {=0A=
		jQuery.error( "Invalid XML: " + data );=0A=
	}=0A=
	return xml;=0A=
};=0A=
=0A=
=0A=
var=0A=
	// Document location=0A=
	ajaxLocParts,=0A=
	ajaxLocation,=0A=
=0A=
	rhash =3D /#.*$/,=0A=
	rts =3D /([?&])_=3D[^&]*/,=0A=
	rheaders =3D /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r =
character at EOL=0A=
	// #7653, #8125, #8152: local protocol detection=0A=
	rlocalProtocol =3D =
/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,=0A=
	rnoContent =3D /^(?:GET|HEAD)$/,=0A=
	rprotocol =3D /^\/\//,=0A=
	rurl =3D /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,=0A=
=0A=
	/* Prefilters=0A=
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js =
for an example)=0A=
	 * 2) These are called:=0A=
	 *    - BEFORE asking for a transport=0A=
	 *    - AFTER param serialization (s.data is a string if s.processData =
is true)=0A=
	 * 3) key is the dataType=0A=
	 * 4) the catchall symbol "*" can be used=0A=
	 * 5) execution will start with transport dataType and THEN continue =
down to "*" if needed=0A=
	 */=0A=
	prefilters =3D {},=0A=
=0A=
	/* Transports bindings=0A=
	 * 1) key is the dataType=0A=
	 * 2) the catchall symbol "*" can be used=0A=
	 * 3) selection will start with transport dataType and THEN go to "*" =
if needed=0A=
	 */=0A=
	transports =3D {},=0A=
=0A=
	// Avoid comment-prolog char sequence (#10098); must appease lint and =
evade compression=0A=
	allTypes =3D "*/".concat("*");=0A=
=0A=
// #8138, IE may throw an exception when accessing=0A=
// a field from window.location if document.domain has been set=0A=
try {=0A=
	ajaxLocation =3D location.href;=0A=
} catch( e ) {=0A=
	// Use the href attribute of an A element=0A=
	// since IE will modify it given document.location=0A=
	ajaxLocation =3D document.createElement( "a" );=0A=
	ajaxLocation.href =3D "";=0A=
	ajaxLocation =3D ajaxLocation.href;=0A=
}=0A=
=0A=
// Segment location into parts=0A=
ajaxLocParts =3D rurl.exec( ajaxLocation.toLowerCase() ) || [];=0A=
=0A=
// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport=0A=
function addToPrefiltersOrTransports( structure ) {=0A=
=0A=
	// dataTypeExpression is optional and defaults to "*"=0A=
	return function( dataTypeExpression, func ) {=0A=
=0A=
		if ( typeof dataTypeExpression !=3D=3D "string" ) {=0A=
			func =3D dataTypeExpression;=0A=
			dataTypeExpression =3D "*";=0A=
		}=0A=
=0A=
		var dataType,=0A=
			i =3D 0,=0A=
			dataTypes =3D dataTypeExpression.toLowerCase().match( rnotwhite ) || =
[];=0A=
=0A=
		if ( jQuery.isFunction( func ) ) {=0A=
			// For each dataType in the dataTypeExpression=0A=
			while ( (dataType =3D dataTypes[i++]) ) {=0A=
				// Prepend if requested=0A=
				if ( dataType.charAt( 0 ) =3D=3D=3D "+" ) {=0A=
					dataType =3D dataType.slice( 1 ) || "*";=0A=
					(structure[ dataType ] =3D structure[ dataType ] || []).unshift( =
func );=0A=
=0A=
				// Otherwise append=0A=
				} else {=0A=
					(structure[ dataType ] =3D structure[ dataType ] || []).push( func =
);=0A=
				}=0A=
			}=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
// Base inspection function for prefilters and transports=0A=
function inspectPrefiltersOrTransports( structure, options, =
originalOptions, jqXHR ) {=0A=
=0A=
	var inspected =3D {},=0A=
		seekingTransport =3D ( structure =3D=3D=3D transports );=0A=
=0A=
	function inspect( dataType ) {=0A=
		var selected;=0A=
		inspected[ dataType ] =3D true;=0A=
		jQuery.each( structure[ dataType ] || [], function( _, =
prefilterOrFactory ) {=0A=
			var dataTypeOrTransport =3D prefilterOrFactory( options, =
originalOptions, jqXHR );=0A=
			if ( typeof dataTypeOrTransport =3D=3D=3D "string" && =
!seekingTransport && !inspected[ dataTypeOrTransport ] ) {=0A=
				options.dataTypes.unshift( dataTypeOrTransport );=0A=
				inspect( dataTypeOrTransport );=0A=
				return false;=0A=
			} else if ( seekingTransport ) {=0A=
				return !( selected =3D dataTypeOrTransport );=0A=
			}=0A=
		});=0A=
		return selected;=0A=
	}=0A=
=0A=
	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && =
inspect( "*" );=0A=
}=0A=
=0A=
// A special extend for ajax options=0A=
// that takes "flat" options (not to be deep extended)=0A=
// Fixes #9887=0A=
function ajaxExtend( target, src ) {=0A=
	var deep, key,=0A=
		flatOptions =3D jQuery.ajaxSettings.flatOptions || {};=0A=
=0A=
	for ( key in src ) {=0A=
		if ( src[ key ] !=3D=3D undefined ) {=0A=
			( flatOptions[ key ] ? target : ( deep || (deep =3D {}) ) )[ key ] =
=3D src[ key ];=0A=
		}=0A=
	}=0A=
	if ( deep ) {=0A=
		jQuery.extend( true, target, deep );=0A=
	}=0A=
=0A=
	return target;=0A=
}=0A=
=0A=
/* Handles responses to an ajax request:=0A=
 * - finds the right dataType (mediates between content-type and =
expected dataType)=0A=
 * - returns the corresponding response=0A=
 */=0A=
function ajaxHandleResponses( s, jqXHR, responses ) {=0A=
	var firstDataType, ct, finalDataType, type,=0A=
		contents =3D s.contents,=0A=
		dataTypes =3D s.dataTypes;=0A=
=0A=
	// Remove auto dataType and get content-type in the process=0A=
	while ( dataTypes[ 0 ] =3D=3D=3D "*" ) {=0A=
		dataTypes.shift();=0A=
		if ( ct =3D=3D=3D undefined ) {=0A=
			ct =3D s.mimeType || jqXHR.getResponseHeader("Content-Type");=0A=
		}=0A=
	}=0A=
=0A=
	// Check if we're dealing with a known content-type=0A=
	if ( ct ) {=0A=
		for ( type in contents ) {=0A=
			if ( contents[ type ] && contents[ type ].test( ct ) ) {=0A=
				dataTypes.unshift( type );=0A=
				break;=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	// Check to see if we have a response for the expected dataType=0A=
	if ( dataTypes[ 0 ] in responses ) {=0A=
		finalDataType =3D dataTypes[ 0 ];=0A=
	} else {=0A=
		// Try convertible dataTypes=0A=
		for ( type in responses ) {=0A=
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {=0A=
				finalDataType =3D type;=0A=
				break;=0A=
			}=0A=
			if ( !firstDataType ) {=0A=
				firstDataType =3D type;=0A=
			}=0A=
		}=0A=
		// Or just use first one=0A=
		finalDataType =3D finalDataType || firstDataType;=0A=
	}=0A=
=0A=
	// If we found a dataType=0A=
	// We add the dataType to the list if needed=0A=
	// and return the corresponding response=0A=
	if ( finalDataType ) {=0A=
		if ( finalDataType !=3D=3D dataTypes[ 0 ] ) {=0A=
			dataTypes.unshift( finalDataType );=0A=
		}=0A=
		return responses[ finalDataType ];=0A=
	}=0A=
}=0A=
=0A=
/* Chain conversions given the request and the original response=0A=
 * Also sets the responseXXX fields on the jqXHR instance=0A=
 */=0A=
function ajaxConvert( s, response, jqXHR, isSuccess ) {=0A=
	var conv2, current, conv, tmp, prev,=0A=
		converters =3D {},=0A=
		// Work with a copy of dataTypes in case we need to modify it for =
conversion=0A=
		dataTypes =3D s.dataTypes.slice();=0A=
=0A=
	// Create converters map with lowercased keys=0A=
	if ( dataTypes[ 1 ] ) {=0A=
		for ( conv in s.converters ) {=0A=
			converters[ conv.toLowerCase() ] =3D s.converters[ conv ];=0A=
		}=0A=
	}=0A=
=0A=
	current =3D dataTypes.shift();=0A=
=0A=
	// Convert to each sequential dataType=0A=
	while ( current ) {=0A=
=0A=
		if ( s.responseFields[ current ] ) {=0A=
			jqXHR[ s.responseFields[ current ] ] =3D response;=0A=
		}=0A=
=0A=
		// Apply the dataFilter if provided=0A=
		if ( !prev && isSuccess && s.dataFilter ) {=0A=
			response =3D s.dataFilter( response, s.dataType );=0A=
		}=0A=
=0A=
		prev =3D current;=0A=
		current =3D dataTypes.shift();=0A=
=0A=
		if ( current ) {=0A=
=0A=
			// There's only work to do if current dataType is non-auto=0A=
			if ( current =3D=3D=3D "*" ) {=0A=
=0A=
				current =3D prev;=0A=
=0A=
			// Convert response if prev dataType is non-auto and differs from =
current=0A=
			} else if ( prev !=3D=3D "*" && prev !=3D=3D current ) {=0A=
=0A=
				// Seek a direct converter=0A=
				conv =3D converters[ prev + " " + current ] || converters[ "* " + =
current ];=0A=
=0A=
				// If none found, seek a pair=0A=
				if ( !conv ) {=0A=
					for ( conv2 in converters ) {=0A=
=0A=
						// If conv2 outputs current=0A=
						tmp =3D conv2.split( " " );=0A=
						if ( tmp[ 1 ] =3D=3D=3D current ) {=0A=
=0A=
							// If prev can be converted to accepted input=0A=
							conv =3D converters[ prev + " " + tmp[ 0 ] ] ||=0A=
								converters[ "* " + tmp[ 0 ] ];=0A=
							if ( conv ) {=0A=
								// Condense equivalence converters=0A=
								if ( conv =3D=3D=3D true ) {=0A=
									conv =3D converters[ conv2 ];=0A=
=0A=
								// Otherwise, insert the intermediate dataType=0A=
								} else if ( converters[ conv2 ] !=3D=3D true ) {=0A=
									current =3D tmp[ 0 ];=0A=
									dataTypes.unshift( tmp[ 1 ] );=0A=
								}=0A=
								break;=0A=
							}=0A=
						}=0A=
					}=0A=
				}=0A=
=0A=
				// Apply converter (if not an equivalence)=0A=
				if ( conv !=3D=3D true ) {=0A=
=0A=
					// Unless errors are allowed to bubble, catch and return them=0A=
					if ( conv && s[ "throws" ] ) {=0A=
						response =3D conv( response );=0A=
					} else {=0A=
						try {=0A=
							response =3D conv( response );=0A=
						} catch ( e ) {=0A=
							return { state: "parsererror", error: conv ? e : "No conversion =
from " + prev + " to " + current };=0A=
						}=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	return { state: "success", data: response };=0A=
}=0A=
=0A=
jQuery.extend({=0A=
=0A=
	// Counter for holding the number of active queries=0A=
	active: 0,=0A=
=0A=
	// Last-Modified header cache for next request=0A=
	lastModified: {},=0A=
	etag: {},=0A=
=0A=
	ajaxSettings: {=0A=
		url: ajaxLocation,=0A=
		type: "GET",=0A=
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),=0A=
		global: true,=0A=
		processData: true,=0A=
		async: true,=0A=
		contentType: "application/x-www-form-urlencoded; charset=3DUTF-8",=0A=
		/*=0A=
		timeout: 0,=0A=
		data: null,=0A=
		dataType: null,=0A=
		username: null,=0A=
		password: null,=0A=
		cache: null,=0A=
		throws: false,=0A=
		traditional: false,=0A=
		headers: {},=0A=
		*/=0A=
=0A=
		accepts: {=0A=
			"*": allTypes,=0A=
			text: "text/plain",=0A=
			html: "text/html",=0A=
			xml: "application/xml, text/xml",=0A=
			json: "application/json, text/javascript"=0A=
		},=0A=
=0A=
		contents: {=0A=
			xml: /xml/,=0A=
			html: /html/,=0A=
			json: /json/=0A=
		},=0A=
=0A=
		responseFields: {=0A=
			xml: "responseXML",=0A=
			text: "responseText",=0A=
			json: "responseJSON"=0A=
		},=0A=
=0A=
		// Data converters=0A=
		// Keys separate source (or catchall "*") and destination types with a =
single space=0A=
		converters: {=0A=
=0A=
			// Convert anything to text=0A=
			"* text": String,=0A=
=0A=
			// Text to html (true =3D no transformation)=0A=
			"text html": true,=0A=
=0A=
			// Evaluate text as a json expression=0A=
			"text json": jQuery.parseJSON,=0A=
=0A=
			// Parse text as xml=0A=
			"text xml": jQuery.parseXML=0A=
		},=0A=
=0A=
		// For options that shouldn't be deep extended:=0A=
		// you can add your own custom options here if=0A=
		// and when you create one that shouldn't be=0A=
		// deep extended (see ajaxExtend)=0A=
		flatOptions: {=0A=
			url: true,=0A=
			context: true=0A=
		}=0A=
	},=0A=
=0A=
	// Creates a full fledged settings object into target=0A=
	// with both ajaxSettings and settings fields.=0A=
	// If target is omitted, writes into ajaxSettings.=0A=
	ajaxSetup: function( target, settings ) {=0A=
		return settings ?=0A=
=0A=
			// Building a settings object=0A=
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :=0A=
=0A=
			// Extending ajaxSettings=0A=
			ajaxExtend( jQuery.ajaxSettings, target );=0A=
	},=0A=
=0A=
	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),=0A=
	ajaxTransport: addToPrefiltersOrTransports( transports ),=0A=
=0A=
	// Main method=0A=
	ajax: function( url, options ) {=0A=
=0A=
		// If url is an object, simulate pre-1.5 signature=0A=
		if ( typeof url =3D=3D=3D "object" ) {=0A=
			options =3D url;=0A=
			url =3D undefined;=0A=
		}=0A=
=0A=
		// Force options to be an object=0A=
		options =3D options || {};=0A=
=0A=
		var // Cross-domain detection vars=0A=
			parts,=0A=
			// Loop variable=0A=
			i,=0A=
			// URL without anti-cache param=0A=
			cacheURL,=0A=
			// Response headers as string=0A=
			responseHeadersString,=0A=
			// timeout handle=0A=
			timeoutTimer,=0A=
=0A=
			// To know if global events are to be dispatched=0A=
			fireGlobals,=0A=
=0A=
			transport,=0A=
			// Response headers=0A=
			responseHeaders,=0A=
			// Create the final options object=0A=
			s =3D jQuery.ajaxSetup( {}, options ),=0A=
			// Callbacks context=0A=
			callbackContext =3D s.context || s,=0A=
			// Context for global events is callbackContext if it is a DOM node =
or jQuery collection=0A=
			globalEventContext =3D s.context && ( callbackContext.nodeType || =
callbackContext.jquery ) ?=0A=
				jQuery( callbackContext ) :=0A=
				jQuery.event,=0A=
			// Deferreds=0A=
			deferred =3D jQuery.Deferred(),=0A=
			completeDeferred =3D jQuery.Callbacks("once memory"),=0A=
			// Status-dependent callbacks=0A=
			statusCode =3D s.statusCode || {},=0A=
			// Headers (they are sent all at once)=0A=
			requestHeaders =3D {},=0A=
			requestHeadersNames =3D {},=0A=
			// The jqXHR state=0A=
			state =3D 0,=0A=
			// Default abort message=0A=
			strAbort =3D "canceled",=0A=
			// Fake xhr=0A=
			jqXHR =3D {=0A=
				readyState: 0,=0A=
=0A=
				// Builds headers hashtable if needed=0A=
				getResponseHeader: function( key ) {=0A=
					var match;=0A=
					if ( state =3D=3D=3D 2 ) {=0A=
						if ( !responseHeaders ) {=0A=
							responseHeaders =3D {};=0A=
							while ( (match =3D rheaders.exec( responseHeadersString )) ) {=0A=
								responseHeaders[ match[1].toLowerCase() ] =3D match[ 2 ];=0A=
							}=0A=
						}=0A=
						match =3D responseHeaders[ key.toLowerCase() ];=0A=
					}=0A=
					return match =3D=3D null ? null : match;=0A=
				},=0A=
=0A=
				// Raw string=0A=
				getAllResponseHeaders: function() {=0A=
					return state =3D=3D=3D 2 ? responseHeadersString : null;=0A=
				},=0A=
=0A=
				// Caches the header=0A=
				setRequestHeader: function( name, value ) {=0A=
					var lname =3D name.toLowerCase();=0A=
					if ( !state ) {=0A=
						name =3D requestHeadersNames[ lname ] =3D requestHeadersNames[ =
lname ] || name;=0A=
						requestHeaders[ name ] =3D value;=0A=
					}=0A=
					return this;=0A=
				},=0A=
=0A=
				// Overrides response content-type header=0A=
				overrideMimeType: function( type ) {=0A=
					if ( !state ) {=0A=
						s.mimeType =3D type;=0A=
					}=0A=
					return this;=0A=
				},=0A=
=0A=
				// Status-dependent callbacks=0A=
				statusCode: function( map ) {=0A=
					var code;=0A=
					if ( map ) {=0A=
						if ( state < 2 ) {=0A=
							for ( code in map ) {=0A=
								// Lazy-add the new callback in a way that preserves old ones=0A=
								statusCode[ code ] =3D [ statusCode[ code ], map[ code ] ];=0A=
							}=0A=
						} else {=0A=
							// Execute the appropriate callbacks=0A=
							jqXHR.always( map[ jqXHR.status ] );=0A=
						}=0A=
					}=0A=
					return this;=0A=
				},=0A=
=0A=
				// Cancel the request=0A=
				abort: function( statusText ) {=0A=
					var finalText =3D statusText || strAbort;=0A=
					if ( transport ) {=0A=
						transport.abort( finalText );=0A=
					}=0A=
					done( 0, finalText );=0A=
					return this;=0A=
				}=0A=
			};=0A=
=0A=
		// Attach deferreds=0A=
		deferred.promise( jqXHR ).complete =3D completeDeferred.add;=0A=
		jqXHR.success =3D jqXHR.done;=0A=
		jqXHR.error =3D jqXHR.fail;=0A=
=0A=
		// Remove hash character (#7531: and string promotion)=0A=
		// Add protocol if not provided (#5866: IE7 issue with protocol-less =
urls)=0A=
		// Handle falsy url in the settings object (#10093: consistency with =
old signature)=0A=
		// We also use the url parameter if available=0A=
		s.url =3D ( ( url || s.url || ajaxLocation ) + "" ).replace( rhash, "" =
).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );=0A=
=0A=
		// Alias method option to type as per ticket #12004=0A=
		s.type =3D options.method || options.type || s.method || s.type;=0A=
=0A=
		// Extract dataTypes list=0A=
		s.dataTypes =3D jQuery.trim( s.dataType || "*" ).toLowerCase().match( =
rnotwhite ) || [ "" ];=0A=
=0A=
		// A cross-domain request is in order when we have a =
protocol:host:port mismatch=0A=
		if ( s.crossDomain =3D=3D null ) {=0A=
			parts =3D rurl.exec( s.url.toLowerCase() );=0A=
			s.crossDomain =3D !!( parts &&=0A=
				( parts[ 1 ] !=3D=3D ajaxLocParts[ 1 ] || parts[ 2 ] !=3D=3D =
ajaxLocParts[ 2 ] ||=0A=
					( parts[ 3 ] || ( parts[ 1 ] =3D=3D=3D "http:" ? "80" : "443" ) ) =
!=3D=3D=0A=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] =3D=3D=3D "http:" ? =
"80" : "443" ) ) )=0A=
			);=0A=
		}=0A=
=0A=
		// Convert data if not already a string=0A=
		if ( s.data && s.processData && typeof s.data !=3D=3D "string" ) {=0A=
			s.data =3D jQuery.param( s.data, s.traditional );=0A=
		}=0A=
=0A=
		// Apply prefilters=0A=
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );=0A=
=0A=
		// If request was aborted inside a prefilter, stop there=0A=
		if ( state =3D=3D=3D 2 ) {=0A=
			return jqXHR;=0A=
		}=0A=
=0A=
		// We can fire global events as of now if asked to=0A=
		// Don't fire events if jQuery.event is undefined in an AMD-usage =
scenario (#15118)=0A=
		fireGlobals =3D jQuery.event && s.global;=0A=
=0A=
		// Watch for a new set of requests=0A=
		if ( fireGlobals && jQuery.active++ =3D=3D=3D 0 ) {=0A=
			jQuery.event.trigger("ajaxStart");=0A=
		}=0A=
=0A=
		// Uppercase the type=0A=
		s.type =3D s.type.toUpperCase();=0A=
=0A=
		// Determine if request has content=0A=
		s.hasContent =3D !rnoContent.test( s.type );=0A=
=0A=
		// Save the URL in case we're toying with the If-Modified-Since=0A=
		// and/or If-None-Match header later on=0A=
		cacheURL =3D s.url;=0A=
=0A=
		// More options handling for requests with no content=0A=
		if ( !s.hasContent ) {=0A=
=0A=
			// If data is available, append data to url=0A=
			if ( s.data ) {=0A=
				cacheURL =3D ( s.url +=3D ( rquery.test( cacheURL ) ? "&" : "?" ) + =
s.data );=0A=
				// #9682: remove data so that it's not used in an eventual retry=0A=
				delete s.data;=0A=
			}=0A=
=0A=
			// Add anti-cache in url if needed=0A=
			if ( s.cache =3D=3D=3D false ) {=0A=
				s.url =3D rts.test( cacheURL ) ?=0A=
=0A=
					// If there is already a '_' parameter, set its value=0A=
					cacheURL.replace( rts, "$1_=3D" + nonce++ ) :=0A=
=0A=
					// Otherwise add one to the end=0A=
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=3D" + =
nonce++;=0A=
			}=0A=
		}=0A=
=0A=
		// Set the If-Modified-Since and/or If-None-Match header, if in =
ifModified mode.=0A=
		if ( s.ifModified ) {=0A=
			if ( jQuery.lastModified[ cacheURL ] ) {=0A=
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ =
cacheURL ] );=0A=
			}=0A=
			if ( jQuery.etag[ cacheURL ] ) {=0A=
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );=0A=
			}=0A=
		}=0A=
=0A=
		// Set the correct header, if data is being sent=0A=
		if ( s.data && s.hasContent && s.contentType !=3D=3D false || =
options.contentType ) {=0A=
			jqXHR.setRequestHeader( "Content-Type", s.contentType );=0A=
		}=0A=
=0A=
		// Set the Accepts header for the server, depending on the dataType=0A=
		jqXHR.setRequestHeader(=0A=
			"Accept",=0A=
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?=0A=
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !=3D=3D "*" ? ", " =
+ allTypes + "; q=3D0.01" : "" ) :=0A=
				s.accepts[ "*" ]=0A=
		);=0A=
=0A=
		// Check for headers option=0A=
		for ( i in s.headers ) {=0A=
			jqXHR.setRequestHeader( i, s.headers[ i ] );=0A=
		}=0A=
=0A=
		// Allow custom headers/mimetypes and early abort=0A=
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) =
=3D=3D=3D false || state =3D=3D=3D 2 ) ) {=0A=
			// Abort if not done already and return=0A=
			return jqXHR.abort();=0A=
		}=0A=
=0A=
		// aborting is no longer a cancellation=0A=
		strAbort =3D "abort";=0A=
=0A=
		// Install callbacks on deferreds=0A=
		for ( i in { success: 1, error: 1, complete: 1 } ) {=0A=
			jqXHR[ i ]( s[ i ] );=0A=
		}=0A=
=0A=
		// Get transport=0A=
		transport =3D inspectPrefiltersOrTransports( transports, s, options, =
jqXHR );=0A=
=0A=
		// If no transport, we auto-abort=0A=
		if ( !transport ) {=0A=
			done( -1, "No Transport" );=0A=
		} else {=0A=
			jqXHR.readyState =3D 1;=0A=
=0A=
			// Send global event=0A=
			if ( fireGlobals ) {=0A=
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );=0A=
			}=0A=
			// Timeout=0A=
			if ( s.async && s.timeout > 0 ) {=0A=
				timeoutTimer =3D setTimeout(function() {=0A=
					jqXHR.abort("timeout");=0A=
				}, s.timeout );=0A=
			}=0A=
=0A=
			try {=0A=
				state =3D 1;=0A=
				transport.send( requestHeaders, done );=0A=
			} catch ( e ) {=0A=
				// Propagate exception as error if not done=0A=
				if ( state < 2 ) {=0A=
					done( -1, e );=0A=
				// Simply rethrow otherwise=0A=
				} else {=0A=
					throw e;=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		// Callback for when everything is done=0A=
		function done( status, nativeStatusText, responses, headers ) {=0A=
			var isSuccess, success, error, response, modified,=0A=
				statusText =3D nativeStatusText;=0A=
=0A=
			// Called once=0A=
			if ( state =3D=3D=3D 2 ) {=0A=
				return;=0A=
			}=0A=
=0A=
			// State is "done" now=0A=
			state =3D 2;=0A=
=0A=
			// Clear timeout if it exists=0A=
			if ( timeoutTimer ) {=0A=
				clearTimeout( timeoutTimer );=0A=
			}=0A=
=0A=
			// Dereference transport for early garbage collection=0A=
			// (no matter how long the jqXHR object will be used)=0A=
			transport =3D undefined;=0A=
=0A=
			// Cache response headers=0A=
			responseHeadersString =3D headers || "";=0A=
=0A=
			// Set readyState=0A=
			jqXHR.readyState =3D status > 0 ? 4 : 0;=0A=
=0A=
			// Determine if successful=0A=
			isSuccess =3D status >=3D 200 && status < 300 || status =3D=3D=3D 304;=0A=
=0A=
			// Get response data=0A=
			if ( responses ) {=0A=
				response =3D ajaxHandleResponses( s, jqXHR, responses );=0A=
			}=0A=
=0A=
			// Convert no matter what (that way responseXXX fields are always set)=0A=
			response =3D ajaxConvert( s, response, jqXHR, isSuccess );=0A=
=0A=
			// If successful, handle type chaining=0A=
			if ( isSuccess ) {=0A=
=0A=
				// Set the If-Modified-Since and/or If-None-Match header, if in =
ifModified mode.=0A=
				if ( s.ifModified ) {=0A=
					modified =3D jqXHR.getResponseHeader("Last-Modified");=0A=
					if ( modified ) {=0A=
						jQuery.lastModified[ cacheURL ] =3D modified;=0A=
					}=0A=
					modified =3D jqXHR.getResponseHeader("etag");=0A=
					if ( modified ) {=0A=
						jQuery.etag[ cacheURL ] =3D modified;=0A=
					}=0A=
				}=0A=
=0A=
				// if no content=0A=
				if ( status =3D=3D=3D 204 || s.type =3D=3D=3D "HEAD" ) {=0A=
					statusText =3D "nocontent";=0A=
=0A=
				// if not modified=0A=
				} else if ( status =3D=3D=3D 304 ) {=0A=
					statusText =3D "notmodified";=0A=
=0A=
				// If we have data, let's convert it=0A=
				} else {=0A=
					statusText =3D response.state;=0A=
					success =3D response.data;=0A=
					error =3D response.error;=0A=
					isSuccess =3D !error;=0A=
				}=0A=
			} else {=0A=
				// We extract error from statusText=0A=
				// then normalize statusText and status for non-aborts=0A=
				error =3D statusText;=0A=
				if ( status || !statusText ) {=0A=
					statusText =3D "error";=0A=
					if ( status < 0 ) {=0A=
						status =3D 0;=0A=
					}=0A=
				}=0A=
			}=0A=
=0A=
			// Set data for the fake xhr object=0A=
			jqXHR.status =3D status;=0A=
			jqXHR.statusText =3D ( nativeStatusText || statusText ) + "";=0A=
=0A=
			// Success/Error=0A=
			if ( isSuccess ) {=0A=
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR =
] );=0A=
			} else {=0A=
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );=0A=
			}=0A=
=0A=
			// Status-dependent callbacks=0A=
			jqXHR.statusCode( statusCode );=0A=
			statusCode =3D undefined;=0A=
=0A=
			if ( fireGlobals ) {=0A=
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",=0A=
					[ jqXHR, s, isSuccess ? success : error ] );=0A=
			}=0A=
=0A=
			// Complete=0A=
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );=0A=
=0A=
			if ( fireGlobals ) {=0A=
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );=0A=
				// Handle the global AJAX counter=0A=
				if ( !( --jQuery.active ) ) {=0A=
					jQuery.event.trigger("ajaxStop");=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		return jqXHR;=0A=
	},=0A=
=0A=
	getJSON: function( url, data, callback ) {=0A=
		return jQuery.get( url, data, callback, "json" );=0A=
	},=0A=
=0A=
	getScript: function( url, callback ) {=0A=
		return jQuery.get( url, undefined, callback, "script" );=0A=
	}=0A=
});=0A=
=0A=
jQuery.each( [ "get", "post" ], function( i, method ) {=0A=
	jQuery[ method ] =3D function( url, data, callback, type ) {=0A=
		// shift arguments if data argument was omitted=0A=
		if ( jQuery.isFunction( data ) ) {=0A=
			type =3D type || callback;=0A=
			callback =3D data;=0A=
			data =3D undefined;=0A=
		}=0A=
=0A=
		return jQuery.ajax({=0A=
			url: url,=0A=
			type: method,=0A=
			dataType: type,=0A=
			data: data,=0A=
			success: callback=0A=
		});=0A=
	};=0A=
});=0A=
=0A=
=0A=
jQuery._evalUrl =3D function( url ) {=0A=
	return jQuery.ajax({=0A=
		url: url,=0A=
		type: "GET",=0A=
		dataType: "script",=0A=
		async: false,=0A=
		global: false,=0A=
		"throws": true=0A=
	});=0A=
};=0A=
=0A=
=0A=
jQuery.fn.extend({=0A=
	wrapAll: function( html ) {=0A=
		if ( jQuery.isFunction( html ) ) {=0A=
			return this.each(function(i) {=0A=
				jQuery(this).wrapAll( html.call(this, i) );=0A=
			});=0A=
		}=0A=
=0A=
		if ( this[0] ) {=0A=
			// The elements to wrap the target around=0A=
			var wrap =3D jQuery( html, this[0].ownerDocument ).eq(0).clone(true);=0A=
=0A=
			if ( this[0].parentNode ) {=0A=
				wrap.insertBefore( this[0] );=0A=
			}=0A=
=0A=
			wrap.map(function() {=0A=
				var elem =3D this;=0A=
=0A=
				while ( elem.firstChild && elem.firstChild.nodeType =3D=3D=3D 1 ) {=0A=
					elem =3D elem.firstChild;=0A=
				}=0A=
=0A=
				return elem;=0A=
			}).append( this );=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	wrapInner: function( html ) {=0A=
		if ( jQuery.isFunction( html ) ) {=0A=
			return this.each(function(i) {=0A=
				jQuery(this).wrapInner( html.call(this, i) );=0A=
			});=0A=
		}=0A=
=0A=
		return this.each(function() {=0A=
			var self =3D jQuery( this ),=0A=
				contents =3D self.contents();=0A=
=0A=
			if ( contents.length ) {=0A=
				contents.wrapAll( html );=0A=
=0A=
			} else {=0A=
				self.append( html );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	wrap: function( html ) {=0A=
		var isFunction =3D jQuery.isFunction( html );=0A=
=0A=
		return this.each(function(i) {=0A=
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );=0A=
		});=0A=
	},=0A=
=0A=
	unwrap: function() {=0A=
		return this.parent().each(function() {=0A=
			if ( !jQuery.nodeName( this, "body" ) ) {=0A=
				jQuery( this ).replaceWith( this.childNodes );=0A=
			}=0A=
		}).end();=0A=
	}=0A=
});=0A=
=0A=
=0A=
jQuery.expr.filters.hidden =3D function( elem ) {=0A=
	// Support: Opera <=3D 12.12=0A=
	// Opera reports offsetWidths and offsetHeights less than zero on some =
elements=0A=
	return elem.offsetWidth <=3D 0 && elem.offsetHeight <=3D 0 ||=0A=
		(!support.reliableHiddenOffsets() &&=0A=
			((elem.style && elem.style.display) || jQuery.css( elem, "display" )) =
=3D=3D=3D "none");=0A=
};=0A=
=0A=
jQuery.expr.filters.visible =3D function( elem ) {=0A=
	return !jQuery.expr.filters.hidden( elem );=0A=
};=0A=
=0A=
=0A=
=0A=
=0A=
var r20 =3D /%20/g,=0A=
	rbracket =3D /\[\]$/,=0A=
	rCRLF =3D /\r?\n/g,=0A=
	rsubmitterTypes =3D /^(?:submit|button|image|reset|file)$/i,=0A=
	rsubmittable =3D /^(?:input|select|textarea|keygen)/i;=0A=
=0A=
function buildParams( prefix, obj, traditional, add ) {=0A=
	var name;=0A=
=0A=
	if ( jQuery.isArray( obj ) ) {=0A=
		// Serialize array item.=0A=
		jQuery.each( obj, function( i, v ) {=0A=
			if ( traditional || rbracket.test( prefix ) ) {=0A=
				// Treat each array item as a scalar.=0A=
				add( prefix, v );=0A=
=0A=
			} else {=0A=
				// Item is non-scalar (array or object), encode its numeric index.=0A=
				buildParams( prefix + "[" + ( typeof v =3D=3D=3D "object" ? i : "" ) =
+ "]", v, traditional, add );=0A=
			}=0A=
		});=0A=
=0A=
	} else if ( !traditional && jQuery.type( obj ) =3D=3D=3D "object" ) {=0A=
		// Serialize object item.=0A=
		for ( name in obj ) {=0A=
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add =
);=0A=
		}=0A=
=0A=
	} else {=0A=
		// Serialize scalar item.=0A=
		add( prefix, obj );=0A=
	}=0A=
}=0A=
=0A=
// Serialize an array of form elements or a set of=0A=
// key/values into a query string=0A=
jQuery.param =3D function( a, traditional ) {=0A=
	var prefix,=0A=
		s =3D [],=0A=
		add =3D function( key, value ) {=0A=
			// If value is a function, invoke it and return its value=0A=
			value =3D jQuery.isFunction( value ) ? value() : ( value =3D=3D null =
? "" : value );=0A=
			s[ s.length ] =3D encodeURIComponent( key ) + "=3D" + =
encodeURIComponent( value );=0A=
		};=0A=
=0A=
	// Set traditional to true for jQuery <=3D 1.3.2 behavior.=0A=
	if ( traditional =3D=3D=3D undefined ) {=0A=
		traditional =3D jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;=0A=
	}=0A=
=0A=
	// If an array was passed in, assume that it is an array of form =
elements.=0A=
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) =
) {=0A=
		// Serialize the form elements=0A=
		jQuery.each( a, function() {=0A=
			add( this.name, this.value );=0A=
		});=0A=
=0A=
	} else {=0A=
		// If traditional, encode the "old" way (the way 1.3.2 or older=0A=
		// did it), otherwise encode params recursively.=0A=
		for ( prefix in a ) {=0A=
			buildParams( prefix, a[ prefix ], traditional, add );=0A=
		}=0A=
	}=0A=
=0A=
	// Return the resulting serialization=0A=
	return s.join( "&" ).replace( r20, "+" );=0A=
};=0A=
=0A=
jQuery.fn.extend({=0A=
	serialize: function() {=0A=
		return jQuery.param( this.serializeArray() );=0A=
	},=0A=
	serializeArray: function() {=0A=
		return this.map(function() {=0A=
			// Can add propHook for "elements" to filter or add form elements=0A=
			var elements =3D jQuery.prop( this, "elements" );=0A=
			return elements ? jQuery.makeArray( elements ) : this;=0A=
		})=0A=
		.filter(function() {=0A=
			var type =3D this.type;=0A=
			// Use .is(":disabled") so that fieldset[disabled] works=0A=
			return this.name && !jQuery( this ).is( ":disabled" ) &&=0A=
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) =
&&=0A=
				( this.checked || !rcheckableType.test( type ) );=0A=
		})=0A=
		.map(function( i, elem ) {=0A=
			var val =3D jQuery( this ).val();=0A=
=0A=
			return val =3D=3D null ?=0A=
				null :=0A=
				jQuery.isArray( val ) ?=0A=
					jQuery.map( val, function( val ) {=0A=
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };=0A=
					}) :=0A=
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };=0A=
		}).get();=0A=
	}=0A=
});=0A=
=0A=
=0A=
// Create the request object=0A=
// (This is still attached to ajaxSettings for backward compatibility)=0A=
jQuery.ajaxSettings.xhr =3D window.ActiveXObject !=3D=3D undefined ?=0A=
	// Support: IE6+=0A=
	function() {=0A=
=0A=
		// XHR cannot access local files, always use ActiveX for that case=0A=
		return !this.isLocal &&=0A=
=0A=
			// Support: IE7-8=0A=
			// oldIE XHR does not support non-RFC2616 methods (#13240)=0A=
			// See =
http://msdn.microsoft.com/en-us/library/ie/ms536648(v=3Dvs.85).aspx=0A=
			// and http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html#sec9=0A=
			// Although this check for six methods instead of eight=0A=
			// since IE also does not support "trace" and "connect"=0A=
			/^(get|post|head|put|delete|options)$/i.test( this.type ) &&=0A=
=0A=
			createStandardXHR() || createActiveXHR();=0A=
	} :=0A=
	// For all other browsers, use the standard XMLHttpRequest object=0A=
	createStandardXHR;=0A=
=0A=
var xhrId =3D 0,=0A=
	xhrCallbacks =3D {},=0A=
	xhrSupported =3D jQuery.ajaxSettings.xhr();=0A=
=0A=
// Support: IE<10=0A=
// Open requests must be manually aborted on unload (#5280)=0A=
// See https://support.microsoft.com/kb/2856746 for more info=0A=
if ( window.attachEvent ) {=0A=
	window.attachEvent( "onunload", function() {=0A=
		for ( var key in xhrCallbacks ) {=0A=
			xhrCallbacks[ key ]( undefined, true );=0A=
		}=0A=
	});=0A=
}=0A=
=0A=
// Determine support properties=0A=
support.cors =3D !!xhrSupported && ( "withCredentials" in xhrSupported );=0A=
xhrSupported =3D support.ajax =3D !!xhrSupported;=0A=
=0A=
// Create transport if the browser can provide an xhr=0A=
if ( xhrSupported ) {=0A=
=0A=
	jQuery.ajaxTransport(function( options ) {=0A=
		// Cross domain only allowed if supported through XMLHttpRequest=0A=
		if ( !options.crossDomain || support.cors ) {=0A=
=0A=
			var callback;=0A=
=0A=
			return {=0A=
				send: function( headers, complete ) {=0A=
					var i,=0A=
						xhr =3D options.xhr(),=0A=
						id =3D ++xhrId;=0A=
=0A=
					// Open the socket=0A=
					xhr.open( options.type, options.url, options.async, =
options.username, options.password );=0A=
=0A=
					// Apply custom fields if provided=0A=
					if ( options.xhrFields ) {=0A=
						for ( i in options.xhrFields ) {=0A=
							xhr[ i ] =3D options.xhrFields[ i ];=0A=
						}=0A=
					}=0A=
=0A=
					// Override mime type if needed=0A=
					if ( options.mimeType && xhr.overrideMimeType ) {=0A=
						xhr.overrideMimeType( options.mimeType );=0A=
					}=0A=
=0A=
					// X-Requested-With header=0A=
					// For cross-domain requests, seeing as conditions for a preflight =
are=0A=
					// akin to a jigsaw puzzle, we simply never set it to be sure.=0A=
					// (it can always be set on a per-request basis or even using =
ajaxSetup)=0A=
					// For same-domain requests, won't change header if already =
provided.=0A=
					if ( !options.crossDomain && !headers["X-Requested-With"] ) {=0A=
						headers["X-Requested-With"] =3D "XMLHttpRequest";=0A=
					}=0A=
=0A=
					// Set headers=0A=
					for ( i in headers ) {=0A=
						// Support: IE<9=0A=
						// IE's ActiveXObject throws a 'Type Mismatch' exception when =
setting=0A=
						// request header to a null-value.=0A=
						//=0A=
						// To keep consistent with other XHR implementations, cast the =
value=0A=
						// to string and ignore `undefined`.=0A=
						if ( headers[ i ] !=3D=3D undefined ) {=0A=
							xhr.setRequestHeader( i, headers[ i ] + "" );=0A=
						}=0A=
					}=0A=
=0A=
					// Do send the request=0A=
					// This may raise an exception which is actually=0A=
					// handled in jQuery.ajax (so no try/catch here)=0A=
					xhr.send( ( options.hasContent && options.data ) || null );=0A=
=0A=
					// Listener=0A=
					callback =3D function( _, isAbort ) {=0A=
						var status, statusText, responses;=0A=
=0A=
						// Was never called and is aborted or complete=0A=
						if ( callback && ( isAbort || xhr.readyState =3D=3D=3D 4 ) ) {=0A=
							// Clean up=0A=
							delete xhrCallbacks[ id ];=0A=
							callback =3D undefined;=0A=
							xhr.onreadystatechange =3D jQuery.noop;=0A=
=0A=
							// Abort manually if needed=0A=
							if ( isAbort ) {=0A=
								if ( xhr.readyState !=3D=3D 4 ) {=0A=
									xhr.abort();=0A=
								}=0A=
							} else {=0A=
								responses =3D {};=0A=
								status =3D xhr.status;=0A=
=0A=
								// Support: IE<10=0A=
								// Accessing binary-data responseText throws an exception=0A=
								// (#11426)=0A=
								if ( typeof xhr.responseText =3D=3D=3D "string" ) {=0A=
									responses.text =3D xhr.responseText;=0A=
								}=0A=
=0A=
								// Firefox throws an exception when accessing=0A=
								// statusText for faulty cross-domain requests=0A=
								try {=0A=
									statusText =3D xhr.statusText;=0A=
								} catch( e ) {=0A=
									// We normalize with Webkit giving an empty statusText=0A=
									statusText =3D "";=0A=
								}=0A=
=0A=
								// Filter status for non standard behaviors=0A=
=0A=
								// If the request is local and we have data: assume a success=0A=
								// (success with no data won't get notified, that's the best we=0A=
								// can do given current implementations)=0A=
								if ( !status && options.isLocal && !options.crossDomain ) {=0A=
									status =3D responses.text ? 200 : 404;=0A=
								// IE - #1450: sometimes returns 1223 when it should be 204=0A=
								} else if ( status =3D=3D=3D 1223 ) {=0A=
									status =3D 204;=0A=
								}=0A=
							}=0A=
						}=0A=
=0A=
						// Call complete if needed=0A=
						if ( responses ) {=0A=
							complete( status, statusText, responses, =
xhr.getAllResponseHeaders() );=0A=
						}=0A=
					};=0A=
=0A=
					if ( !options.async ) {=0A=
						// if we're in sync mode we fire the callback=0A=
						callback();=0A=
					} else if ( xhr.readyState =3D=3D=3D 4 ) {=0A=
						// (IE6 & IE7) if it's in cache and has been=0A=
						// retrieved directly we need to fire the callback=0A=
						setTimeout( callback );=0A=
					} else {=0A=
						// Add to the list of active xhr callbacks=0A=
						xhr.onreadystatechange =3D xhrCallbacks[ id ] =3D callback;=0A=
					}=0A=
				},=0A=
=0A=
				abort: function() {=0A=
					if ( callback ) {=0A=
						callback( undefined, true );=0A=
					}=0A=
				}=0A=
			};=0A=
		}=0A=
	});=0A=
}=0A=
=0A=
// Functions to create xhrs=0A=
function createStandardXHR() {=0A=
	try {=0A=
		return new window.XMLHttpRequest();=0A=
	} catch( e ) {}=0A=
}=0A=
=0A=
function createActiveXHR() {=0A=
	try {=0A=
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );=0A=
	} catch( e ) {}=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
// Install script dataType=0A=
jQuery.ajaxSetup({=0A=
	accepts: {=0A=
		script: "text/javascript, application/javascript, =
application/ecmascript, application/x-ecmascript"=0A=
	},=0A=
	contents: {=0A=
		script: /(?:java|ecma)script/=0A=
	},=0A=
	converters: {=0A=
		"text script": function( text ) {=0A=
			jQuery.globalEval( text );=0A=
			return text;=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
// Handle cache's special case and global=0A=
jQuery.ajaxPrefilter( "script", function( s ) {=0A=
	if ( s.cache =3D=3D=3D undefined ) {=0A=
		s.cache =3D false;=0A=
	}=0A=
	if ( s.crossDomain ) {=0A=
		s.type =3D "GET";=0A=
		s.global =3D false;=0A=
	}=0A=
});=0A=
=0A=
// Bind script tag hack transport=0A=
jQuery.ajaxTransport( "script", function(s) {=0A=
=0A=
	// This transport only deals with cross domain requests=0A=
	if ( s.crossDomain ) {=0A=
=0A=
		var script,=0A=
			head =3D document.head || jQuery("head")[0] || =
document.documentElement;=0A=
=0A=
		return {=0A=
=0A=
			send: function( _, callback ) {=0A=
=0A=
				script =3D document.createElement("script");=0A=
=0A=
				script.async =3D true;=0A=
=0A=
				if ( s.scriptCharset ) {=0A=
					script.charset =3D s.scriptCharset;=0A=
				}=0A=
=0A=
				script.src =3D s.url;=0A=
=0A=
				// Attach handlers for all browsers=0A=
				script.onload =3D script.onreadystatechange =3D function( _, isAbort =
) {=0A=
=0A=
					if ( isAbort || !script.readyState || /loaded|complete/.test( =
script.readyState ) ) {=0A=
=0A=
						// Handle memory leak in IE=0A=
						script.onload =3D script.onreadystatechange =3D null;=0A=
=0A=
						// Remove the script=0A=
						if ( script.parentNode ) {=0A=
							script.parentNode.removeChild( script );=0A=
						}=0A=
=0A=
						// Dereference the script=0A=
						script =3D null;=0A=
=0A=
						// Callback if not abort=0A=
						if ( !isAbort ) {=0A=
							callback( 200, "success" );=0A=
						}=0A=
					}=0A=
				};=0A=
=0A=
				// Circumvent IE6 bugs with base elements (#2709 and #4378) by =
prepending=0A=
				// Use native DOM manipulation to avoid our domManip AJAX trickery=0A=
				head.insertBefore( script, head.firstChild );=0A=
			},=0A=
=0A=
			abort: function() {=0A=
				if ( script ) {=0A=
					script.onload( undefined, true );=0A=
				}=0A=
			}=0A=
		};=0A=
	}=0A=
});=0A=
=0A=
=0A=
=0A=
=0A=
var oldCallbacks =3D [],=0A=
	rjsonp =3D /(=3D)\?(?=3D&|$)|\?\?/;=0A=
=0A=
// Default jsonp settings=0A=
jQuery.ajaxSetup({=0A=
	jsonp: "callback",=0A=
	jsonpCallback: function() {=0A=
		var callback =3D oldCallbacks.pop() || ( jQuery.expando + "_" + ( =
nonce++ ) );=0A=
		this[ callback ] =3D true;=0A=
		return callback;=0A=
	}=0A=
});=0A=
=0A=
// Detect, normalize options and install callbacks for jsonp requests=0A=
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR =
) {=0A=
=0A=
	var callbackName, overwritten, responseContainer,=0A=
		jsonProp =3D s.jsonp !=3D=3D false && ( rjsonp.test( s.url ) ?=0A=
			"url" :=0A=
			typeof s.data =3D=3D=3D "string" && !( s.contentType || "" =
).indexOf("application/x-www-form-urlencoded") && rjsonp.test( s.data ) =
&& "data"=0A=
		);=0A=
=0A=
	// Handle iff the expected data type is "jsonp" or we have a parameter =
to set=0A=
	if ( jsonProp || s.dataTypes[ 0 ] =3D=3D=3D "jsonp" ) {=0A=
=0A=
		// Get callback name, remembering preexisting value associated with it=0A=
		callbackName =3D s.jsonpCallback =3D jQuery.isFunction( =
s.jsonpCallback ) ?=0A=
			s.jsonpCallback() :=0A=
			s.jsonpCallback;=0A=
=0A=
		// Insert callback into url or form data=0A=
		if ( jsonProp ) {=0A=
			s[ jsonProp ] =3D s[ jsonProp ].replace( rjsonp, "$1" + callbackName =
);=0A=
		} else if ( s.jsonp !=3D=3D false ) {=0A=
			s.url +=3D ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=3D" + =
callbackName;=0A=
		}=0A=
=0A=
		// Use data converter to retrieve json after script execution=0A=
		s.converters["script json"] =3D function() {=0A=
			if ( !responseContainer ) {=0A=
				jQuery.error( callbackName + " was not called" );=0A=
			}=0A=
			return responseContainer[ 0 ];=0A=
		};=0A=
=0A=
		// force json dataType=0A=
		s.dataTypes[ 0 ] =3D "json";=0A=
=0A=
		// Install callback=0A=
		overwritten =3D window[ callbackName ];=0A=
		window[ callbackName ] =3D function() {=0A=
			responseContainer =3D arguments;=0A=
		};=0A=
=0A=
		// Clean-up function (fires after converters)=0A=
		jqXHR.always(function() {=0A=
			// Restore preexisting value=0A=
			window[ callbackName ] =3D overwritten;=0A=
=0A=
			// Save back as free=0A=
			if ( s[ callbackName ] ) {=0A=
				// make sure that re-using the options doesn't screw things around=0A=
				s.jsonpCallback =3D originalSettings.jsonpCallback;=0A=
=0A=
				// save the callback name for future use=0A=
				oldCallbacks.push( callbackName );=0A=
			}=0A=
=0A=
			// Call if it was a function and we have a response=0A=
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {=0A=
				overwritten( responseContainer[ 0 ] );=0A=
			}=0A=
=0A=
			responseContainer =3D overwritten =3D undefined;=0A=
		});=0A=
=0A=
		// Delegate to script=0A=
		return "script";=0A=
	}=0A=
});=0A=
=0A=
=0A=
=0A=
=0A=
// data: string of html=0A=
// context (optional): If specified, the fragment will be created in =
this context, defaults to document=0A=
// keepScripts (optional): If true, will include scripts passed in the =
html string=0A=
jQuery.parseHTML =3D function( data, context, keepScripts ) {=0A=
	if ( !data || typeof data !=3D=3D "string" ) {=0A=
		return null;=0A=
	}=0A=
	if ( typeof context =3D=3D=3D "boolean" ) {=0A=
		keepScripts =3D context;=0A=
		context =3D false;=0A=
	}=0A=
	context =3D context || document;=0A=
=0A=
	var parsed =3D rsingleTag.exec( data ),=0A=
		scripts =3D !keepScripts && [];=0A=
=0A=
	// Single tag=0A=
	if ( parsed ) {=0A=
		return [ context.createElement( parsed[1] ) ];=0A=
	}=0A=
=0A=
	parsed =3D jQuery.buildFragment( [ data ], context, scripts );=0A=
=0A=
	if ( scripts && scripts.length ) {=0A=
		jQuery( scripts ).remove();=0A=
	}=0A=
=0A=
	return jQuery.merge( [], parsed.childNodes );=0A=
};=0A=
=0A=
=0A=
// Keep a copy of the old load method=0A=
var _load =3D jQuery.fn.load;=0A=
=0A=
/**=0A=
 * Load a url into a page=0A=
 */=0A=
jQuery.fn.load =3D function( url, params, callback ) {=0A=
	if ( typeof url !=3D=3D "string" && _load ) {=0A=
		return _load.apply( this, arguments );=0A=
	}=0A=
=0A=
	var selector, response, type,=0A=
		self =3D this,=0A=
		off =3D url.indexOf(" ");=0A=
=0A=
	if ( off >=3D 0 ) {=0A=
		selector =3D jQuery.trim( url.slice( off, url.length ) );=0A=
		url =3D url.slice( 0, off );=0A=
	}=0A=
=0A=
	// If it's a function=0A=
	if ( jQuery.isFunction( params ) ) {=0A=
=0A=
		// We assume that it's the callback=0A=
		callback =3D params;=0A=
		params =3D undefined;=0A=
=0A=
	// Otherwise, build a param string=0A=
	} else if ( params && typeof params =3D=3D=3D "object" ) {=0A=
		type =3D "POST";=0A=
	}=0A=
=0A=
	// If we have elements to modify, make the request=0A=
	if ( self.length > 0 ) {=0A=
		jQuery.ajax({=0A=
			url: url,=0A=
=0A=
			// if "type" variable is undefined, then "GET" method will be used=0A=
			type: type,=0A=
			dataType: "html",=0A=
			data: params=0A=
		}).done(function( responseText ) {=0A=
=0A=
			// Save response for use in complete callback=0A=
			response =3D arguments;=0A=
=0A=
			self.html( selector ?=0A=
=0A=
				// If a selector was specified, locate the right elements in a dummy =
div=0A=
				// Exclude scripts to avoid IE 'Permission Denied' errors=0A=
				jQuery("<div>").append( jQuery.parseHTML( responseText ) ).find( =
selector ) :=0A=
=0A=
				// Otherwise use the full result=0A=
				responseText );=0A=
=0A=
		}).complete( callback && function( jqXHR, status ) {=0A=
			self.each( callback, response || [ jqXHR.responseText, status, jqXHR =
] );=0A=
		});=0A=
	}=0A=
=0A=
	return this;=0A=
};=0A=
=0A=
=0A=
=0A=
=0A=
// Attach a bunch of functions for handling common AJAX events=0A=
jQuery.each( [ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", =
"ajaxSuccess", "ajaxSend" ], function( i, type ) {=0A=
	jQuery.fn[ type ] =3D function( fn ) {=0A=
		return this.on( type, fn );=0A=
	};=0A=
});=0A=
=0A=
=0A=
=0A=
=0A=
jQuery.expr.filters.animated =3D function( elem ) {=0A=
	return jQuery.grep(jQuery.timers, function( fn ) {=0A=
		return elem =3D=3D=3D fn.elem;=0A=
	}).length;=0A=
};=0A=
=0A=
=0A=
=0A=
=0A=
=0A=
var docElem =3D window.document.documentElement;=0A=
=0A=
/**=0A=
 * Gets a window from an element=0A=
 */=0A=
function getWindow( elem ) {=0A=
	return jQuery.isWindow( elem ) ?=0A=
		elem :=0A=
		elem.nodeType =3D=3D=3D 9 ?=0A=
			elem.defaultView || elem.parentWindow :=0A=
			false;=0A=
}=0A=
=0A=
jQuery.offset =3D {=0A=
	setOffset: function( elem, options, i ) {=0A=
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, =
calculatePosition,=0A=
			position =3D jQuery.css( elem, "position" ),=0A=
			curElem =3D jQuery( elem ),=0A=
			props =3D {};=0A=
=0A=
		// set position first, in-case top/left are set even on static elem=0A=
		if ( position =3D=3D=3D "static" ) {=0A=
			elem.style.position =3D "relative";=0A=
		}=0A=
=0A=
		curOffset =3D curElem.offset();=0A=
		curCSSTop =3D jQuery.css( elem, "top" );=0A=
		curCSSLeft =3D jQuery.css( elem, "left" );=0A=
		calculatePosition =3D ( position =3D=3D=3D "absolute" || position =
=3D=3D=3D "fixed" ) &&=0A=
			jQuery.inArray("auto", [ curCSSTop, curCSSLeft ] ) > -1;=0A=
=0A=
		// need to be able to calculate position if either top or left is auto =
and position is either absolute or fixed=0A=
		if ( calculatePosition ) {=0A=
			curPosition =3D curElem.position();=0A=
			curTop =3D curPosition.top;=0A=
			curLeft =3D curPosition.left;=0A=
		} else {=0A=
			curTop =3D parseFloat( curCSSTop ) || 0;=0A=
			curLeft =3D parseFloat( curCSSLeft ) || 0;=0A=
		}=0A=
=0A=
		if ( jQuery.isFunction( options ) ) {=0A=
			options =3D options.call( elem, i, curOffset );=0A=
		}=0A=
=0A=
		if ( options.top !=3D null ) {=0A=
			props.top =3D ( options.top - curOffset.top ) + curTop;=0A=
		}=0A=
		if ( options.left !=3D null ) {=0A=
			props.left =3D ( options.left - curOffset.left ) + curLeft;=0A=
		}=0A=
=0A=
		if ( "using" in options ) {=0A=
			options.using.call( elem, props );=0A=
		} else {=0A=
			curElem.css( props );=0A=
		}=0A=
	}=0A=
};=0A=
=0A=
jQuery.fn.extend({=0A=
	offset: function( options ) {=0A=
		if ( arguments.length ) {=0A=
			return options =3D=3D=3D undefined ?=0A=
				this :=0A=
				this.each(function( i ) {=0A=
					jQuery.offset.setOffset( this, options, i );=0A=
				});=0A=
		}=0A=
=0A=
		var docElem, win,=0A=
			box =3D { top: 0, left: 0 },=0A=
			elem =3D this[ 0 ],=0A=
			doc =3D elem && elem.ownerDocument;=0A=
=0A=
		if ( !doc ) {=0A=
			return;=0A=
		}=0A=
=0A=
		docElem =3D doc.documentElement;=0A=
=0A=
		// Make sure it's not a disconnected DOM node=0A=
		if ( !jQuery.contains( docElem, elem ) ) {=0A=
			return box;=0A=
		}=0A=
=0A=
		// If we don't have gBCR, just use 0,0 rather than error=0A=
		// BlackBerry 5, iOS 3 (original iPhone)=0A=
		if ( typeof elem.getBoundingClientRect !=3D=3D strundefined ) {=0A=
			box =3D elem.getBoundingClientRect();=0A=
		}=0A=
		win =3D getWindow( doc );=0A=
		return {=0A=
			top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( =
docElem.clientTop  || 0 ),=0A=
			left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( =
docElem.clientLeft || 0 )=0A=
		};=0A=
	},=0A=
=0A=
	position: function() {=0A=
		if ( !this[ 0 ] ) {=0A=
			return;=0A=
		}=0A=
=0A=
		var offsetParent, offset,=0A=
			parentOffset =3D { top: 0, left: 0 },=0A=
			elem =3D this[ 0 ];=0A=
=0A=
		// fixed elements are offset from window (parentOffset =3D {top:0, =
left: 0}, because it is its only offset parent=0A=
		if ( jQuery.css( elem, "position" ) =3D=3D=3D "fixed" ) {=0A=
			// we assume that getBoundingClientRect is available when computed =
position is fixed=0A=
			offset =3D elem.getBoundingClientRect();=0A=
		} else {=0A=
			// Get *real* offsetParent=0A=
			offsetParent =3D this.offsetParent();=0A=
=0A=
			// Get correct offsets=0A=
			offset =3D this.offset();=0A=
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {=0A=
				parentOffset =3D offsetParent.offset();=0A=
			}=0A=
=0A=
			// Add offsetParent borders=0A=
			parentOffset.top  +=3D jQuery.css( offsetParent[ 0 ], =
"borderTopWidth", true );=0A=
			parentOffset.left +=3D jQuery.css( offsetParent[ 0 ], =
"borderLeftWidth", true );=0A=
		}=0A=
=0A=
		// Subtract parent offsets and element margins=0A=
		// note: when an element has margin: auto the offsetLeft and marginLeft=0A=
		// are the same in Safari causing offset.left to incorrectly be 0=0A=
		return {=0A=
			top:  offset.top  - parentOffset.top - jQuery.css( elem, "marginTop", =
true ),=0A=
			left: offset.left - parentOffset.left - jQuery.css( elem, =
"marginLeft", true)=0A=
		};=0A=
	},=0A=
=0A=
	offsetParent: function() {=0A=
		return this.map(function() {=0A=
			var offsetParent =3D this.offsetParent || docElem;=0A=
=0A=
			while ( offsetParent && ( !jQuery.nodeName( offsetParent, "html" ) && =
jQuery.css( offsetParent, "position" ) =3D=3D=3D "static" ) ) {=0A=
				offsetParent =3D offsetParent.offsetParent;=0A=
			}=0A=
			return offsetParent || docElem;=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
// Create scrollLeft and scrollTop methods=0A=
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, =
function( method, prop ) {=0A=
	var top =3D /Y/.test( prop );=0A=
=0A=
	jQuery.fn[ method ] =3D function( val ) {=0A=
		return access( this, function( elem, method, val ) {=0A=
			var win =3D getWindow( elem );=0A=
=0A=
			if ( val =3D=3D=3D undefined ) {=0A=
				return win ? (prop in win) ? win[ prop ] :=0A=
					win.document.documentElement[ method ] :=0A=
					elem[ method ];=0A=
			}=0A=
=0A=
			if ( win ) {=0A=
				win.scrollTo(=0A=
					!top ? val : jQuery( win ).scrollLeft(),=0A=
					top ? val : jQuery( win ).scrollTop()=0A=
				);=0A=
=0A=
			} else {=0A=
				elem[ method ] =3D val;=0A=
			}=0A=
		}, method, val, arguments.length, null );=0A=
	};=0A=
});=0A=
=0A=
// Add the top/left cssHooks using jQuery.fn.position=0A=
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=3D29084=0A=
// getComputedStyle returns percent when specified for =
top/left/bottom/right=0A=
// rather than make the css module depend on the offset module, we just =
check for it here=0A=
jQuery.each( [ "top", "left" ], function( i, prop ) {=0A=
	jQuery.cssHooks[ prop ] =3D addGetHookIf( support.pixelPosition,=0A=
		function( elem, computed ) {=0A=
			if ( computed ) {=0A=
				computed =3D curCSS( elem, prop );=0A=
				// if curCSS returns percentage, fallback to offset=0A=
				return rnumnonpx.test( computed ) ?=0A=
					jQuery( elem ).position()[ prop ] + "px" :=0A=
					computed;=0A=
			}=0A=
		}=0A=
	);=0A=
});=0A=
=0A=
=0A=
// Create innerHeight, innerWidth, height, width, outerHeight and =
outerWidth methods=0A=
jQuery.each( { Height: "height", Width: "width" }, function( name, type =
) {=0A=
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + =
name }, function( defaultExtra, funcName ) {=0A=
		// margin is only for outerHeight, outerWidth=0A=
		jQuery.fn[ funcName ] =3D function( margin, value ) {=0A=
			var chainable =3D arguments.length && ( defaultExtra || typeof margin =
!=3D=3D "boolean" ),=0A=
				extra =3D defaultExtra || ( margin =3D=3D=3D true || value =3D=3D=3D =
true ? "margin" : "border" );=0A=
=0A=
			return access( this, function( elem, type, value ) {=0A=
				var doc;=0A=
=0A=
				if ( jQuery.isWindow( elem ) ) {=0A=
					// As of 5/8/2012 this will yield incorrect results for Mobile =
Safari, but there=0A=
					// isn't a whole lot we can do. See pull request at this URL for =
discussion:=0A=
					// https://github.com/jquery/jquery/pull/764=0A=
					return elem.document.documentElement[ "client" + name ];=0A=
				}=0A=
=0A=
				// Get document width or height=0A=
				if ( elem.nodeType =3D=3D=3D 9 ) {=0A=
					doc =3D elem.documentElement;=0A=
=0A=
					// Either scroll[Width/Height] or offset[Width/Height] or =
client[Width/Height], whichever is greatest=0A=
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is =
currently no good, small way to fix it.=0A=
					return Math.max(=0A=
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],=0A=
						elem.body[ "offset" + name ], doc[ "offset" + name ],=0A=
						doc[ "client" + name ]=0A=
					);=0A=
				}=0A=
=0A=
				return value =3D=3D=3D undefined ?=0A=
					// Get width or height on the element, requesting but not forcing =
parseFloat=0A=
					jQuery.css( elem, type, extra ) :=0A=
=0A=
					// Set width or height on the element=0A=
					jQuery.style( elem, type, value, extra );=0A=
			}, type, chainable ? margin : undefined, chainable, null );=0A=
		};=0A=
	});=0A=
});=0A=
=0A=
=0A=
// The number of elements contained in the matched element set=0A=
jQuery.fn.size =3D function() {=0A=
	return this.length;=0A=
};=0A=
=0A=
jQuery.fn.andSelf =3D jQuery.fn.addBack;=0A=
=0A=
=0A=
=0A=
=0A=
// Register as a named AMD module, since jQuery can be concatenated with =
other=0A=
// files that may use define, but not via a proper concatenation script =
that=0A=
// understands anonymous AMD modules. A named AMD is safest and most =
robust=0A=
// way to register. Lowercase jquery is used because AMD module names are=0A=
// derived from file names, and jQuery is normally delivered in a =
lowercase=0A=
// file name. Do this after creating the global so that if an AMD module =
wants=0A=
// to call noConflict to hide this version of jQuery, it will work.=0A=
=0A=
// Note that for maximum portability, libraries that are not jQuery =
should=0A=
// declare themselves as anonymous modules, and avoid setting a global =
if an=0A=
// AMD loader is present. jQuery is a special case. For more =
information, see=0A=
// =
https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wik=
i-anon=0A=
=0A=
if ( typeof define =3D=3D=3D "function" && define.amd ) {=0A=
	define( "jquery", [], function() {=0A=
		return jQuery;=0A=
	});=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
var=0A=
	// Map over jQuery in case of overwrite=0A=
	_jQuery =3D window.jQuery,=0A=
=0A=
	// Map over the $ in case of overwrite=0A=
	_$ =3D window.$;=0A=
=0A=
jQuery.noConflict =3D function( deep ) {=0A=
	if ( window.$ =3D=3D=3D jQuery ) {=0A=
		window.$ =3D _$;=0A=
	}=0A=
=0A=
	if ( deep && window.jQuery =3D=3D=3D jQuery ) {=0A=
		window.jQuery =3D _jQuery;=0A=
	}=0A=
=0A=
	return jQuery;=0A=
};=0A=
=0A=
// Expose jQuery and $ identifiers, even in=0A=
// AMD (#7102#comment:10, https://github.com/jquery/jquery/pull/557)=0A=
// and CommonJS for browser emulators (#13566)=0A=
if ( typeof noGlobal =3D=3D=3D strundefined ) {=0A=
	window.jQuery =3D window.$ =3D jQuery;=0A=
}=0A=
=0A=
=0A=
=0A=
=0A=
return jQuery;=0A=
=0A=
}));=0A=

------=_NextPart_000_0000_01D14A12.98FB2E40
Content-Type: application/octet-stream
Content-Transfer-Encoding: quoted-printable
Content-Location: =?gb2312?B?ZmlsZTovLy9GOi9teXByb2dyYW0vztK1xMG3z7C0+sLrL2pxdWVyeS11aS4=?=
	=?gb2312?B?anM=?=

/*! jQuery UI - v1.11.1 - 2014-09-07=0A=
* http://jqueryui.com=0A=
* Includes: core.js, widget.js, mouse.js, position.js, draggable.js, =
droppable.js, resizable.js, selectable.js, sortable.js, accordion.js, =
autocomplete.js, button.js, datepicker.js, dialog.js, menu.js, =
progressbar.js, selectmenu.js, slider.js, spinner.js, tabs.js, =
tooltip.js, effect.js, effect-blind.js, effect-bounce.js, =
effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, =
effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, =
effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, =
effect-transfer.js=0A=
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT =
*/=0A=
=0A=
(function( factory ) {=0A=
	if ( typeof define =3D=3D=3D "function" && define.amd ) {=0A=
=0A=
		// AMD. Register as an anonymous module.=0A=
		define([ "jquery" ], factory );=0A=
	} else {=0A=
=0A=
		// Browser globals=0A=
		factory( jQuery );=0A=
	}=0A=
}(function( $ ) {=0A=
/*!=0A=
 * jQuery UI Core 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/category/ui-core/=0A=
 */=0A=
=0A=
=0A=
// $.ui might exist from components with no dependencies, e.g., =
$.ui.position=0A=
$.ui =3D $.ui || {};=0A=
=0A=
$.extend( $.ui, {=0A=
	version: "1.11.1",=0A=
=0A=
	keyCode: {=0A=
		BACKSPACE: 8,=0A=
		COMMA: 188,=0A=
		DELETE: 46,=0A=
		DOWN: 40,=0A=
		END: 35,=0A=
		ENTER: 13,=0A=
		ESCAPE: 27,=0A=
		HOME: 36,=0A=
		LEFT: 37,=0A=
		PAGE_DOWN: 34,=0A=
		PAGE_UP: 33,=0A=
		PERIOD: 190,=0A=
		RIGHT: 39,=0A=
		SPACE: 32,=0A=
		TAB: 9,=0A=
		UP: 38=0A=
	}=0A=
});=0A=
=0A=
// plugins=0A=
$.fn.extend({=0A=
	scrollParent: function( includeHidden ) {=0A=
		var position =3D this.css( "position" ),=0A=
			excludeStaticParent =3D position =3D=3D=3D "absolute",=0A=
			overflowRegex =3D includeHidden ? /(auto|scroll|hidden)/ : =
/(auto|scroll)/,=0A=
			scrollParent =3D this.parents().filter( function() {=0A=
				var parent =3D $( this );=0A=
				if ( excludeStaticParent && parent.css( "position" ) =3D=3D=3D =
"static" ) {=0A=
					return false;=0A=
				}=0A=
				return overflowRegex.test( parent.css( "overflow" ) + parent.css( =
"overflow-y" ) + parent.css( "overflow-x" ) );=0A=
			}).eq( 0 );=0A=
=0A=
		return position =3D=3D=3D "fixed" || !scrollParent.length ? $( this[ 0 =
].ownerDocument || document ) : scrollParent;=0A=
	},=0A=
=0A=
	uniqueId: (function() {=0A=
		var uuid =3D 0;=0A=
=0A=
		return function() {=0A=
			return this.each(function() {=0A=
				if ( !this.id ) {=0A=
					this.id =3D "ui-id-" + ( ++uuid );=0A=
				}=0A=
			});=0A=
		};=0A=
	})(),=0A=
=0A=
	removeUniqueId: function() {=0A=
		return this.each(function() {=0A=
			if ( /^ui-id-\d+$/.test( this.id ) ) {=0A=
				$( this ).removeAttr( "id" );=0A=
			}=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
// selectors=0A=
function focusable( element, isTabIndexNotNaN ) {=0A=
	var map, mapName, img,=0A=
		nodeName =3D element.nodeName.toLowerCase();=0A=
	if ( "area" =3D=3D=3D nodeName ) {=0A=
		map =3D element.parentNode;=0A=
		mapName =3D map.name;=0A=
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !=3D=3D =
"map" ) {=0A=
			return false;=0A=
		}=0A=
		img =3D $( "img[usemap=3D'#" + mapName + "']" )[ 0 ];=0A=
		return !!img && visible( img );=0A=
	}=0A=
	return ( /input|select|textarea|button|object/.test( nodeName ) ?=0A=
		!element.disabled :=0A=
		"a" =3D=3D=3D nodeName ?=0A=
			element.href || isTabIndexNotNaN :=0A=
			isTabIndexNotNaN) &&=0A=
		// the element and all of its ancestors must be visible=0A=
		visible( element );=0A=
}=0A=
=0A=
function visible( element ) {=0A=
	return $.expr.filters.visible( element ) &&=0A=
		!$( element ).parents().addBack().filter(function() {=0A=
			return $.css( this, "visibility" ) =3D=3D=3D "hidden";=0A=
		}).length;=0A=
}=0A=
=0A=
$.extend( $.expr[ ":" ], {=0A=
	data: $.expr.createPseudo ?=0A=
		$.expr.createPseudo(function( dataName ) {=0A=
			return function( elem ) {=0A=
				return !!$.data( elem, dataName );=0A=
			};=0A=
		}) :=0A=
		// support: jQuery <1.8=0A=
		function( elem, i, match ) {=0A=
			return !!$.data( elem, match[ 3 ] );=0A=
		},=0A=
=0A=
	focusable: function( element ) {=0A=
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );=0A=
	},=0A=
=0A=
	tabbable: function( element ) {=0A=
		var tabIndex =3D $.attr( element, "tabindex" ),=0A=
			isTabIndexNaN =3D isNaN( tabIndex );=0A=
		return ( isTabIndexNaN || tabIndex >=3D 0 ) && focusable( element, =
!isTabIndexNaN );=0A=
	}=0A=
});=0A=
=0A=
// support: jQuery <1.8=0A=
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {=0A=
	$.each( [ "Width", "Height" ], function( i, name ) {=0A=
		var side =3D name =3D=3D=3D "Width" ? [ "Left", "Right" ] : [ "Top", =
"Bottom" ],=0A=
			type =3D name.toLowerCase(),=0A=
			orig =3D {=0A=
				innerWidth: $.fn.innerWidth,=0A=
				innerHeight: $.fn.innerHeight,=0A=
				outerWidth: $.fn.outerWidth,=0A=
				outerHeight: $.fn.outerHeight=0A=
			};=0A=
=0A=
		function reduce( elem, size, border, margin ) {=0A=
			$.each( side, function() {=0A=
				size -=3D parseFloat( $.css( elem, "padding" + this ) ) || 0;=0A=
				if ( border ) {=0A=
					size -=3D parseFloat( $.css( elem, "border" + this + "Width" ) ) || =
0;=0A=
				}=0A=
				if ( margin ) {=0A=
					size -=3D parseFloat( $.css( elem, "margin" + this ) ) || 0;=0A=
				}=0A=
			});=0A=
			return size;=0A=
		}=0A=
=0A=
		$.fn[ "inner" + name ] =3D function( size ) {=0A=
			if ( size =3D=3D=3D undefined ) {=0A=
				return orig[ "inner" + name ].call( this );=0A=
			}=0A=
=0A=
			return this.each(function() {=0A=
				$( this ).css( type, reduce( this, size ) + "px" );=0A=
			});=0A=
		};=0A=
=0A=
		$.fn[ "outer" + name] =3D function( size, margin ) {=0A=
			if ( typeof size !=3D=3D "number" ) {=0A=
				return orig[ "outer" + name ].call( this, size );=0A=
			}=0A=
=0A=
			return this.each(function() {=0A=
				$( this).css( type, reduce( this, size, true, margin ) + "px" );=0A=
			});=0A=
		};=0A=
	});=0A=
}=0A=
=0A=
// support: jQuery <1.8=0A=
if ( !$.fn.addBack ) {=0A=
	$.fn.addBack =3D function( selector ) {=0A=
		return this.add( selector =3D=3D null ?=0A=
			this.prevObject : this.prevObject.filter( selector )=0A=
		);=0A=
	};=0A=
}=0A=
=0A=
// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)=0A=
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {=0A=
	$.fn.removeData =3D (function( removeData ) {=0A=
		return function( key ) {=0A=
			if ( arguments.length ) {=0A=
				return removeData.call( this, $.camelCase( key ) );=0A=
			} else {=0A=
				return removeData.call( this );=0A=
			}=0A=
		};=0A=
	})( $.fn.removeData );=0A=
}=0A=
=0A=
// deprecated=0A=
$.ui.ie =3D !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );=0A=
=0A=
$.fn.extend({=0A=
	focus: (function( orig ) {=0A=
		return function( delay, fn ) {=0A=
			return typeof delay =3D=3D=3D "number" ?=0A=
				this.each(function() {=0A=
					var elem =3D this;=0A=
					setTimeout(function() {=0A=
						$( elem ).focus();=0A=
						if ( fn ) {=0A=
							fn.call( elem );=0A=
						}=0A=
					}, delay );=0A=
				}) :=0A=
				orig.apply( this, arguments );=0A=
		};=0A=
	})( $.fn.focus ),=0A=
=0A=
	disableSelection: (function() {=0A=
		var eventType =3D "onselectstart" in document.createElement( "div" ) ?=0A=
			"selectstart" :=0A=
			"mousedown";=0A=
=0A=
		return function() {=0A=
			return this.bind( eventType + ".ui-disableSelection", function( event =
) {=0A=
				event.preventDefault();=0A=
			});=0A=
		};=0A=
	})(),=0A=
=0A=
	enableSelection: function() {=0A=
		return this.unbind( ".ui-disableSelection" );=0A=
	},=0A=
=0A=
	zIndex: function( zIndex ) {=0A=
		if ( zIndex !=3D=3D undefined ) {=0A=
			return this.css( "zIndex", zIndex );=0A=
		}=0A=
=0A=
		if ( this.length ) {=0A=
			var elem =3D $( this[ 0 ] ), position, value;=0A=
			while ( elem.length && elem[ 0 ] !=3D=3D document ) {=0A=
				// Ignore z-index if position is set to a value where z-index is =
ignored by the browser=0A=
				// This makes behavior of this function consistent across browsers=0A=
				// WebKit always returns auto if the element is positioned=0A=
				position =3D elem.css( "position" );=0A=
				if ( position =3D=3D=3D "absolute" || position =3D=3D=3D "relative" =
|| position =3D=3D=3D "fixed" ) {=0A=
					// IE returns 0 when zIndex is not specified=0A=
					// other browsers return a string=0A=
					// we ignore the case of nested elements with an explicit value of 0=0A=
					// <div style=3D"z-index: -10;"><div style=3D"z-index: =
0;"></div></div>=0A=
					value =3D parseInt( elem.css( "zIndex" ), 10 );=0A=
					if ( !isNaN( value ) && value !=3D=3D 0 ) {=0A=
						return value;=0A=
					}=0A=
				}=0A=
				elem =3D elem.parent();=0A=
			}=0A=
		}=0A=
=0A=
		return 0;=0A=
	}=0A=
});=0A=
=0A=
// $.ui.plugin is deprecated. Use $.widget() extensions instead.=0A=
$.ui.plugin =3D {=0A=
	add: function( module, option, set ) {=0A=
		var i,=0A=
			proto =3D $.ui[ module ].prototype;=0A=
		for ( i in set ) {=0A=
			proto.plugins[ i ] =3D proto.plugins[ i ] || [];=0A=
			proto.plugins[ i ].push( [ option, set[ i ] ] );=0A=
		}=0A=
	},=0A=
	call: function( instance, name, args, allowDisconnected ) {=0A=
		var i,=0A=
			set =3D instance.plugins[ name ];=0A=
=0A=
		if ( !set ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || =
instance.element[ 0 ].parentNode.nodeType =3D=3D=3D 11 ) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		for ( i =3D 0; i < set.length; i++ ) {=0A=
			if ( instance.options[ set[ i ][ 0 ] ] ) {=0A=
				set[ i ][ 1 ].apply( instance.element, args );=0A=
			}=0A=
		}=0A=
	}=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Widget 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/jQuery.widget/=0A=
 */=0A=
=0A=
=0A=
var widget_uuid =3D 0,=0A=
	widget_slice =3D Array.prototype.slice;=0A=
=0A=
$.cleanData =3D (function( orig ) {=0A=
	return function( elems ) {=0A=
		var events, elem, i;=0A=
		for ( i =3D 0; (elem =3D elems[i]) !=3D null; i++ ) {=0A=
			try {=0A=
=0A=
				// Only trigger remove when necessary to save time=0A=
				events =3D $._data( elem, "events" );=0A=
				if ( events && events.remove ) {=0A=
					$( elem ).triggerHandler( "remove" );=0A=
				}=0A=
=0A=
			// http://bugs.jquery.com/ticket/8235=0A=
			} catch( e ) {}=0A=
		}=0A=
		orig( elems );=0A=
	};=0A=
})( $.cleanData );=0A=
=0A=
$.widget =3D function( name, base, prototype ) {=0A=
	var fullName, existingConstructor, constructor, basePrototype,=0A=
		// proxiedPrototype allows the provided prototype to remain unmodified=0A=
		// so that it can be used as a mixin for multiple widgets (#8876)=0A=
		proxiedPrototype =3D {},=0A=
		namespace =3D name.split( "." )[ 0 ];=0A=
=0A=
	name =3D name.split( "." )[ 1 ];=0A=
	fullName =3D namespace + "-" + name;=0A=
=0A=
	if ( !prototype ) {=0A=
		prototype =3D base;=0A=
		base =3D $.Widget;=0A=
	}=0A=
=0A=
	// create selector for plugin=0A=
	$.expr[ ":" ][ fullName.toLowerCase() ] =3D function( elem ) {=0A=
		return !!$.data( elem, fullName );=0A=
	};=0A=
=0A=
	$[ namespace ] =3D $[ namespace ] || {};=0A=
	existingConstructor =3D $[ namespace ][ name ];=0A=
	constructor =3D $[ namespace ][ name ] =3D function( options, element ) =
{=0A=
		// allow instantiation without "new" keyword=0A=
		if ( !this._createWidget ) {=0A=
			return new constructor( options, element );=0A=
		}=0A=
=0A=
		// allow instantiation without initializing for simple inheritance=0A=
		// must use "new" keyword (the code above always passes args)=0A=
		if ( arguments.length ) {=0A=
			this._createWidget( options, element );=0A=
		}=0A=
	};=0A=
	// extend with the existing constructor to carry over any static =
properties=0A=
	$.extend( constructor, existingConstructor, {=0A=
		version: prototype.version,=0A=
		// copy the object used to create the prototype in case we need to=0A=
		// redefine the widget later=0A=
		_proto: $.extend( {}, prototype ),=0A=
		// track widgets that inherit from this widget in case this widget is=0A=
		// redefined after a widget inherits from it=0A=
		_childConstructors: []=0A=
	});=0A=
=0A=
	basePrototype =3D new base();=0A=
	// we need to make the options hash a property directly on the new =
instance=0A=
	// otherwise we'll modify the options hash on the prototype that we're=0A=
	// inheriting from=0A=
	basePrototype.options =3D $.widget.extend( {}, basePrototype.options );=0A=
	$.each( prototype, function( prop, value ) {=0A=
		if ( !$.isFunction( value ) ) {=0A=
			proxiedPrototype[ prop ] =3D value;=0A=
			return;=0A=
		}=0A=
		proxiedPrototype[ prop ] =3D (function() {=0A=
			var _super =3D function() {=0A=
					return base.prototype[ prop ].apply( this, arguments );=0A=
				},=0A=
				_superApply =3D function( args ) {=0A=
					return base.prototype[ prop ].apply( this, args );=0A=
				};=0A=
			return function() {=0A=
				var __super =3D this._super,=0A=
					__superApply =3D this._superApply,=0A=
					returnValue;=0A=
=0A=
				this._super =3D _super;=0A=
				this._superApply =3D _superApply;=0A=
=0A=
				returnValue =3D value.apply( this, arguments );=0A=
=0A=
				this._super =3D __super;=0A=
				this._superApply =3D __superApply;=0A=
=0A=
				return returnValue;=0A=
			};=0A=
		})();=0A=
	});=0A=
	constructor.prototype =3D $.widget.extend( basePrototype, {=0A=
		// TODO: remove support for widgetEventPrefix=0A=
		// always use the name + a colon as the prefix, e.g., draggable:start=0A=
		// don't prefix for widgets that aren't DOM-based=0A=
		widgetEventPrefix: existingConstructor ? =
(basePrototype.widgetEventPrefix || name) : name=0A=
	}, proxiedPrototype, {=0A=
		constructor: constructor,=0A=
		namespace: namespace,=0A=
		widgetName: name,=0A=
		widgetFullName: fullName=0A=
	});=0A=
=0A=
	// If this widget is being redefined then we need to find all widgets =
that=0A=
	// are inheriting from it and redefine all of them so that they inherit =
from=0A=
	// the new version of this widget. We're essentially trying to replace =
one=0A=
	// level in the prototype chain.=0A=
	if ( existingConstructor ) {=0A=
		$.each( existingConstructor._childConstructors, function( i, child ) {=0A=
			var childPrototype =3D child.prototype;=0A=
=0A=
			// redefine the child widget using the same prototype that was=0A=
			// originally used, but inherit from the new version of the base=0A=
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, =
constructor, child._proto );=0A=
		});=0A=
		// remove the list of existing child constructors from the old =
constructor=0A=
		// so the old child constructors can be garbage collected=0A=
		delete existingConstructor._childConstructors;=0A=
	} else {=0A=
		base._childConstructors.push( constructor );=0A=
	}=0A=
=0A=
	$.widget.bridge( name, constructor );=0A=
=0A=
	return constructor;=0A=
};=0A=
=0A=
$.widget.extend =3D function( target ) {=0A=
	var input =3D widget_slice.call( arguments, 1 ),=0A=
		inputIndex =3D 0,=0A=
		inputLength =3D input.length,=0A=
		key,=0A=
		value;=0A=
	for ( ; inputIndex < inputLength; inputIndex++ ) {=0A=
		for ( key in input[ inputIndex ] ) {=0A=
			value =3D input[ inputIndex ][ key ];=0A=
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !=3D=3D =
undefined ) {=0A=
				// Clone objects=0A=
				if ( $.isPlainObject( value ) ) {=0A=
					target[ key ] =3D $.isPlainObject( target[ key ] ) ?=0A=
						$.widget.extend( {}, target[ key ], value ) :=0A=
						// Don't extend strings, arrays, etc. with objects=0A=
						$.widget.extend( {}, value );=0A=
				// Copy everything else by reference=0A=
				} else {=0A=
					target[ key ] =3D value;=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
	return target;=0A=
};=0A=
=0A=
$.widget.bridge =3D function( name, object ) {=0A=
	var fullName =3D object.prototype.widgetFullName || name;=0A=
	$.fn[ name ] =3D function( options ) {=0A=
		var isMethodCall =3D typeof options =3D=3D=3D "string",=0A=
			args =3D widget_slice.call( arguments, 1 ),=0A=
			returnValue =3D this;=0A=
=0A=
		// allow multiple hashes to be passed on init=0A=
		options =3D !isMethodCall && args.length ?=0A=
			$.widget.extend.apply( null, [ options ].concat(args) ) :=0A=
			options;=0A=
=0A=
		if ( isMethodCall ) {=0A=
			this.each(function() {=0A=
				var methodValue,=0A=
					instance =3D $.data( this, fullName );=0A=
				if ( options =3D=3D=3D "instance" ) {=0A=
					returnValue =3D instance;=0A=
					return false;=0A=
				}=0A=
				if ( !instance ) {=0A=
					return $.error( "cannot call methods on " + name + " prior to =
initialization; " +=0A=
						"attempted to call method '" + options + "'" );=0A=
				}=0A=
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) =
=3D=3D=3D "_" ) {=0A=
					return $.error( "no such method '" + options + "' for " + name + " =
widget instance" );=0A=
				}=0A=
				methodValue =3D instance[ options ].apply( instance, args );=0A=
				if ( methodValue !=3D=3D instance && methodValue !=3D=3D undefined ) =
{=0A=
					returnValue =3D methodValue && methodValue.jquery ?=0A=
						returnValue.pushStack( methodValue.get() ) :=0A=
						methodValue;=0A=
					return false;=0A=
				}=0A=
			});=0A=
		} else {=0A=
			this.each(function() {=0A=
				var instance =3D $.data( this, fullName );=0A=
				if ( instance ) {=0A=
					instance.option( options || {} );=0A=
					if ( instance._init ) {=0A=
						instance._init();=0A=
					}=0A=
				} else {=0A=
					$.data( this, fullName, new object( options, this ) );=0A=
				}=0A=
			});=0A=
		}=0A=
=0A=
		return returnValue;=0A=
	};=0A=
};=0A=
=0A=
$.Widget =3D function( /* options, element */ ) {};=0A=
$.Widget._childConstructors =3D [];=0A=
=0A=
$.Widget.prototype =3D {=0A=
	widgetName: "widget",=0A=
	widgetEventPrefix: "",=0A=
	defaultElement: "<div>",=0A=
	options: {=0A=
		disabled: false,=0A=
=0A=
		// callbacks=0A=
		create: null=0A=
	},=0A=
	_createWidget: function( options, element ) {=0A=
		element =3D $( element || this.defaultElement || this )[ 0 ];=0A=
		this.element =3D $( element );=0A=
		this.uuid =3D widget_uuid++;=0A=
		this.eventNamespace =3D "." + this.widgetName + this.uuid;=0A=
		this.options =3D $.widget.extend( {},=0A=
			this.options,=0A=
			this._getCreateOptions(),=0A=
			options );=0A=
=0A=
		this.bindings =3D $();=0A=
		this.hoverable =3D $();=0A=
		this.focusable =3D $();=0A=
=0A=
		if ( element !=3D=3D this ) {=0A=
			$.data( element, this.widgetFullName, this );=0A=
			this._on( true, this.element, {=0A=
				remove: function( event ) {=0A=
					if ( event.target =3D=3D=3D element ) {=0A=
						this.destroy();=0A=
					}=0A=
				}=0A=
			});=0A=
			this.document =3D $( element.style ?=0A=
				// element within the document=0A=
				element.ownerDocument :=0A=
				// element is window or document=0A=
				element.document || element );=0A=
			this.window =3D $( this.document[0].defaultView || =
this.document[0].parentWindow );=0A=
		}=0A=
=0A=
		this._create();=0A=
		this._trigger( "create", null, this._getCreateEventData() );=0A=
		this._init();=0A=
	},=0A=
	_getCreateOptions: $.noop,=0A=
	_getCreateEventData: $.noop,=0A=
	_create: $.noop,=0A=
	_init: $.noop,=0A=
=0A=
	destroy: function() {=0A=
		this._destroy();=0A=
		// we can probably remove the unbind calls in 2.0=0A=
		// all event bindings should go through this._on()=0A=
		this.element=0A=
			.unbind( this.eventNamespace )=0A=
			.removeData( this.widgetFullName )=0A=
			// support: jquery <1.6.3=0A=
			// http://bugs.jquery.com/ticket/9413=0A=
			.removeData( $.camelCase( this.widgetFullName ) );=0A=
		this.widget()=0A=
			.unbind( this.eventNamespace )=0A=
			.removeAttr( "aria-disabled" )=0A=
			.removeClass(=0A=
				this.widgetFullName + "-disabled " +=0A=
				"ui-state-disabled" );=0A=
=0A=
		// clean up events and states=0A=
		this.bindings.unbind( this.eventNamespace );=0A=
		this.hoverable.removeClass( "ui-state-hover" );=0A=
		this.focusable.removeClass( "ui-state-focus" );=0A=
	},=0A=
	_destroy: $.noop,=0A=
=0A=
	widget: function() {=0A=
		return this.element;=0A=
	},=0A=
=0A=
	option: function( key, value ) {=0A=
		var options =3D key,=0A=
			parts,=0A=
			curOption,=0A=
			i;=0A=
=0A=
		if ( arguments.length =3D=3D=3D 0 ) {=0A=
			// don't return a reference to the internal hash=0A=
			return $.widget.extend( {}, this.options );=0A=
		}=0A=
=0A=
		if ( typeof key =3D=3D=3D "string" ) {=0A=
			// handle nested keys, e.g., "foo.bar" =3D> { foo: { bar: ___ } }=0A=
			options =3D {};=0A=
			parts =3D key.split( "." );=0A=
			key =3D parts.shift();=0A=
			if ( parts.length ) {=0A=
				curOption =3D options[ key ] =3D $.widget.extend( {}, this.options[ =
key ] );=0A=
				for ( i =3D 0; i < parts.length - 1; i++ ) {=0A=
					curOption[ parts[ i ] ] =3D curOption[ parts[ i ] ] || {};=0A=
					curOption =3D curOption[ parts[ i ] ];=0A=
				}=0A=
				key =3D parts.pop();=0A=
				if ( arguments.length =3D=3D=3D 1 ) {=0A=
					return curOption[ key ] =3D=3D=3D undefined ? null : curOption[ key =
];=0A=
				}=0A=
				curOption[ key ] =3D value;=0A=
			} else {=0A=
				if ( arguments.length =3D=3D=3D 1 ) {=0A=
					return this.options[ key ] =3D=3D=3D undefined ? null : =
this.options[ key ];=0A=
				}=0A=
				options[ key ] =3D value;=0A=
			}=0A=
		}=0A=
=0A=
		this._setOptions( options );=0A=
=0A=
		return this;=0A=
	},=0A=
	_setOptions: function( options ) {=0A=
		var key;=0A=
=0A=
		for ( key in options ) {=0A=
			this._setOption( key, options[ key ] );=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
	_setOption: function( key, value ) {=0A=
		this.options[ key ] =3D value;=0A=
=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			this.widget()=0A=
				.toggleClass( this.widgetFullName + "-disabled", !!value );=0A=
=0A=
			// If the widget is becoming disabled, then nothing is interactive=0A=
			if ( value ) {=0A=
				this.hoverable.removeClass( "ui-state-hover" );=0A=
				this.focusable.removeClass( "ui-state-focus" );=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	enable: function() {=0A=
		return this._setOptions({ disabled: false });=0A=
	},=0A=
	disable: function() {=0A=
		return this._setOptions({ disabled: true });=0A=
	},=0A=
=0A=
	_on: function( suppressDisabledCheck, element, handlers ) {=0A=
		var delegateElement,=0A=
			instance =3D this;=0A=
=0A=
		// no suppressDisabledCheck flag, shuffle arguments=0A=
		if ( typeof suppressDisabledCheck !=3D=3D "boolean" ) {=0A=
			handlers =3D element;=0A=
			element =3D suppressDisabledCheck;=0A=
			suppressDisabledCheck =3D false;=0A=
		}=0A=
=0A=
		// no element argument, shuffle and use this.element=0A=
		if ( !handlers ) {=0A=
			handlers =3D element;=0A=
			element =3D this.element;=0A=
			delegateElement =3D this.widget();=0A=
		} else {=0A=
			element =3D delegateElement =3D $( element );=0A=
			this.bindings =3D this.bindings.add( element );=0A=
		}=0A=
=0A=
		$.each( handlers, function( event, handler ) {=0A=
			function handlerProxy() {=0A=
				// allow widgets to customize the disabled handling=0A=
				// - disabled as an array instead of boolean=0A=
				// - disabled class as method for disabling individual parts=0A=
				if ( !suppressDisabledCheck &&=0A=
						( instance.options.disabled =3D=3D=3D true ||=0A=
							$( this ).hasClass( "ui-state-disabled" ) ) ) {=0A=
					return;=0A=
				}=0A=
				return ( typeof handler =3D=3D=3D "string" ? instance[ handler ] : =
handler )=0A=
					.apply( instance, arguments );=0A=
			}=0A=
=0A=
			// copy the guid so direct unbinding works=0A=
			if ( typeof handler !=3D=3D "string" ) {=0A=
				handlerProxy.guid =3D handler.guid =3D=0A=
					handler.guid || handlerProxy.guid || $.guid++;=0A=
			}=0A=
=0A=
			var match =3D event.match( /^([\w:-]*)\s*(.*)$/ ),=0A=
				eventName =3D match[1] + instance.eventNamespace,=0A=
				selector =3D match[2];=0A=
			if ( selector ) {=0A=
				delegateElement.delegate( selector, eventName, handlerProxy );=0A=
			} else {=0A=
				element.bind( eventName, handlerProxy );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	_off: function( element, eventName ) {=0A=
		eventName =3D (eventName || "").split( " " ).join( this.eventNamespace =
+ " " ) + this.eventNamespace;=0A=
		element.unbind( eventName ).undelegate( eventName );=0A=
	},=0A=
=0A=
	_delay: function( handler, delay ) {=0A=
		function handlerProxy() {=0A=
			return ( typeof handler =3D=3D=3D "string" ? instance[ handler ] : =
handler )=0A=
				.apply( instance, arguments );=0A=
		}=0A=
		var instance =3D this;=0A=
		return setTimeout( handlerProxy, delay || 0 );=0A=
	},=0A=
=0A=
	_hoverable: function( element ) {=0A=
		this.hoverable =3D this.hoverable.add( element );=0A=
		this._on( element, {=0A=
			mouseenter: function( event ) {=0A=
				$( event.currentTarget ).addClass( "ui-state-hover" );=0A=
			},=0A=
			mouseleave: function( event ) {=0A=
				$( event.currentTarget ).removeClass( "ui-state-hover" );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	_focusable: function( element ) {=0A=
		this.focusable =3D this.focusable.add( element );=0A=
		this._on( element, {=0A=
			focusin: function( event ) {=0A=
				$( event.currentTarget ).addClass( "ui-state-focus" );=0A=
			},=0A=
			focusout: function( event ) {=0A=
				$( event.currentTarget ).removeClass( "ui-state-focus" );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	_trigger: function( type, event, data ) {=0A=
		var prop, orig,=0A=
			callback =3D this.options[ type ];=0A=
=0A=
		data =3D data || {};=0A=
		event =3D $.Event( event );=0A=
		event.type =3D ( type =3D=3D=3D this.widgetEventPrefix ?=0A=
			type :=0A=
			this.widgetEventPrefix + type ).toLowerCase();=0A=
		// the original event may come from any element=0A=
		// so we need to reset the target on the new event=0A=
		event.target =3D this.element[ 0 ];=0A=
=0A=
		// copy original event properties over to the new event=0A=
		orig =3D event.originalEvent;=0A=
		if ( orig ) {=0A=
			for ( prop in orig ) {=0A=
				if ( !( prop in event ) ) {=0A=
					event[ prop ] =3D orig[ prop ];=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		this.element.trigger( event, data );=0A=
		return !( $.isFunction( callback ) &&=0A=
			callback.apply( this.element[0], [ event ].concat( data ) ) =3D=3D=3D =
false ||=0A=
			event.isDefaultPrevented() );=0A=
	}=0A=
};=0A=
=0A=
$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, =
defaultEffect ) {=0A=
	$.Widget.prototype[ "_" + method ] =3D function( element, options, =
callback ) {=0A=
		if ( typeof options =3D=3D=3D "string" ) {=0A=
			options =3D { effect: options };=0A=
		}=0A=
		var hasOptions,=0A=
			effectName =3D !options ?=0A=
				method :=0A=
				options =3D=3D=3D true || typeof options =3D=3D=3D "number" ?=0A=
					defaultEffect :=0A=
					options.effect || defaultEffect;=0A=
		options =3D options || {};=0A=
		if ( typeof options =3D=3D=3D "number" ) {=0A=
			options =3D { duration: options };=0A=
		}=0A=
		hasOptions =3D !$.isEmptyObject( options );=0A=
		options.complete =3D callback;=0A=
		if ( options.delay ) {=0A=
			element.delay( options.delay );=0A=
		}=0A=
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {=0A=
			element[ method ]( options );=0A=
		} else if ( effectName !=3D=3D method && element[ effectName ] ) {=0A=
			element[ effectName ]( options.duration, options.easing, callback );=0A=
		} else {=0A=
			element.queue(function( next ) {=0A=
				$( this )[ method ]();=0A=
				if ( callback ) {=0A=
					callback.call( element[ 0 ] );=0A=
				}=0A=
				next();=0A=
			});=0A=
		}=0A=
	};=0A=
});=0A=
=0A=
var widget =3D $.widget;=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Mouse 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/mouse/=0A=
 */=0A=
=0A=
=0A=
var mouseHandled =3D false;=0A=
$( document ).mouseup( function() {=0A=
	mouseHandled =3D false;=0A=
});=0A=
=0A=
var mouse =3D $.widget("ui.mouse", {=0A=
	version: "1.11.1",=0A=
	options: {=0A=
		cancel: "input,textarea,button,select,option",=0A=
		distance: 1,=0A=
		delay: 0=0A=
	},=0A=
	_mouseInit: function() {=0A=
		var that =3D this;=0A=
=0A=
		this.element=0A=
			.bind("mousedown." + this.widgetName, function(event) {=0A=
				return that._mouseDown(event);=0A=
			})=0A=
			.bind("click." + this.widgetName, function(event) {=0A=
				if (true =3D=3D=3D $.data(event.target, that.widgetName + =
".preventClickEvent")) {=0A=
					$.removeData(event.target, that.widgetName + ".preventClickEvent");=0A=
					event.stopImmediatePropagation();=0A=
					return false;=0A=
				}=0A=
			});=0A=
=0A=
		this.started =3D false;=0A=
	},=0A=
=0A=
	// TODO: make sure destroying one instance of mouse doesn't mess with=0A=
	// other instances of mouse=0A=
	_mouseDestroy: function() {=0A=
		this.element.unbind("." + this.widgetName);=0A=
		if ( this._mouseMoveDelegate ) {=0A=
			this.document=0A=
				.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)=0A=
				.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);=0A=
		}=0A=
	},=0A=
=0A=
	_mouseDown: function(event) {=0A=
		// don't let more than one widget handle mouseStart=0A=
		if ( mouseHandled ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// we may have missed mouseup (out of window)=0A=
		(this._mouseStarted && this._mouseUp(event));=0A=
=0A=
		this._mouseDownEvent =3D event;=0A=
=0A=
		var that =3D this,=0A=
			btnIsLeft =3D (event.which =3D=3D=3D 1),=0A=
			// event.target.nodeName works around a bug in IE 8 with=0A=
			// disabled inputs (#7620)=0A=
			elIsCancel =3D (typeof this.options.cancel =3D=3D=3D "string" && =
event.target.nodeName ? =
$(event.target).closest(this.options.cancel).length : false);=0A=
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {=0A=
			return true;=0A=
		}=0A=
=0A=
		this.mouseDelayMet =3D !this.options.delay;=0A=
		if (!this.mouseDelayMet) {=0A=
			this._mouseDelayTimer =3D setTimeout(function() {=0A=
				that.mouseDelayMet =3D true;=0A=
			}, this.options.delay);=0A=
		}=0A=
=0A=
		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {=0A=
			this._mouseStarted =3D (this._mouseStart(event) !=3D=3D false);=0A=
			if (!this._mouseStarted) {=0A=
				event.preventDefault();=0A=
				return true;=0A=
			}=0A=
		}=0A=
=0A=
		// Click event may never have fired (Gecko & Opera)=0A=
		if (true =3D=3D=3D $.data(event.target, this.widgetName + =
".preventClickEvent")) {=0A=
			$.removeData(event.target, this.widgetName + ".preventClickEvent");=0A=
		}=0A=
=0A=
		// these delegates are required to keep context=0A=
		this._mouseMoveDelegate =3D function(event) {=0A=
			return that._mouseMove(event);=0A=
		};=0A=
		this._mouseUpDelegate =3D function(event) {=0A=
			return that._mouseUp(event);=0A=
		};=0A=
=0A=
		this.document=0A=
			.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )=0A=
			.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );=0A=
=0A=
		event.preventDefault();=0A=
=0A=
		mouseHandled =3D true;=0A=
		return true;=0A=
	},=0A=
=0A=
	_mouseMove: function(event) {=0A=
		// IE mouseup check - mouseup happened when mouse was out of window=0A=
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) =
&& !event.button) {=0A=
			return this._mouseUp(event);=0A=
=0A=
		// Iframe mouseup check - mouseup occurred in another document=0A=
		} else if ( !event.which ) {=0A=
			return this._mouseUp( event );=0A=
		}=0A=
=0A=
		if (this._mouseStarted) {=0A=
			this._mouseDrag(event);=0A=
			return event.preventDefault();=0A=
		}=0A=
=0A=
		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {=0A=
			this._mouseStarted =3D=0A=
				(this._mouseStart(this._mouseDownEvent, event) !=3D=3D false);=0A=
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));=0A=
		}=0A=
=0A=
		return !this._mouseStarted;=0A=
	},=0A=
=0A=
	_mouseUp: function(event) {=0A=
		this.document=0A=
			.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )=0A=
			.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );=0A=
=0A=
		if (this._mouseStarted) {=0A=
			this._mouseStarted =3D false;=0A=
=0A=
			if (event.target =3D=3D=3D this._mouseDownEvent.target) {=0A=
				$.data(event.target, this.widgetName + ".preventClickEvent", true);=0A=
			}=0A=
=0A=
			this._mouseStop(event);=0A=
		}=0A=
=0A=
		mouseHandled =3D false;=0A=
		return false;=0A=
	},=0A=
=0A=
	_mouseDistanceMet: function(event) {=0A=
		return (Math.max(=0A=
				Math.abs(this._mouseDownEvent.pageX - event.pageX),=0A=
				Math.abs(this._mouseDownEvent.pageY - event.pageY)=0A=
			) >=3D this.options.distance=0A=
		);=0A=
	},=0A=
=0A=
	_mouseDelayMet: function(/* event */) {=0A=
		return this.mouseDelayMet;=0A=
	},=0A=
=0A=
	// These are placeholder methods, to be overriden by extending plugin=0A=
	_mouseStart: function(/* event */) {},=0A=
	_mouseDrag: function(/* event */) {},=0A=
	_mouseStop: function(/* event */) {},=0A=
	_mouseCapture: function(/* event */) { return true; }=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Position 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/position/=0A=
 */=0A=
=0A=
(function() {=0A=
=0A=
$.ui =3D $.ui || {};=0A=
=0A=
var cachedScrollbarWidth, supportsOffsetFractions,=0A=
	max =3D Math.max,=0A=
	abs =3D Math.abs,=0A=
	round =3D Math.round,=0A=
	rhorizontal =3D /left|center|right/,=0A=
	rvertical =3D /top|center|bottom/,=0A=
	roffset =3D /[\+\-]\d+(\.[\d]+)?%?/,=0A=
	rposition =3D /^\w+/,=0A=
	rpercent =3D /%$/,=0A=
	_position =3D $.fn.position;=0A=
=0A=
function getOffsets( offsets, width, height ) {=0A=
	return [=0A=
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / =
100 : 1 ),=0A=
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height =
/ 100 : 1 )=0A=
	];=0A=
}=0A=
=0A=
function parseCss( element, property ) {=0A=
	return parseInt( $.css( element, property ), 10 ) || 0;=0A=
}=0A=
=0A=
function getDimensions( elem ) {=0A=
	var raw =3D elem[0];=0A=
	if ( raw.nodeType =3D=3D=3D 9 ) {=0A=
		return {=0A=
			width: elem.width(),=0A=
			height: elem.height(),=0A=
			offset: { top: 0, left: 0 }=0A=
		};=0A=
	}=0A=
	if ( $.isWindow( raw ) ) {=0A=
		return {=0A=
			width: elem.width(),=0A=
			height: elem.height(),=0A=
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }=0A=
		};=0A=
	}=0A=
	if ( raw.preventDefault ) {=0A=
		return {=0A=
			width: 0,=0A=
			height: 0,=0A=
			offset: { top: raw.pageY, left: raw.pageX }=0A=
		};=0A=
	}=0A=
	return {=0A=
		width: elem.outerWidth(),=0A=
		height: elem.outerHeight(),=0A=
		offset: elem.offset()=0A=
	};=0A=
}=0A=
=0A=
$.position =3D {=0A=
	scrollbarWidth: function() {=0A=
		if ( cachedScrollbarWidth !=3D=3D undefined ) {=0A=
			return cachedScrollbarWidth;=0A=
		}=0A=
		var w1, w2,=0A=
			div =3D $( "<div =
style=3D'display:block;position:absolute;width:50px;height:50px;overflow:=
hidden;'><div style=3D'height:100px;width:auto;'></div></div>" ),=0A=
			innerDiv =3D div.children()[0];=0A=
=0A=
		$( "body" ).append( div );=0A=
		w1 =3D innerDiv.offsetWidth;=0A=
		div.css( "overflow", "scroll" );=0A=
=0A=
		w2 =3D innerDiv.offsetWidth;=0A=
=0A=
		if ( w1 =3D=3D=3D w2 ) {=0A=
			w2 =3D div[0].clientWidth;=0A=
		}=0A=
=0A=
		div.remove();=0A=
=0A=
		return (cachedScrollbarWidth =3D w1 - w2);=0A=
	},=0A=
	getScrollInfo: function( within ) {=0A=
		var overflowX =3D within.isWindow || within.isDocument ? "" :=0A=
				within.element.css( "overflow-x" ),=0A=
			overflowY =3D within.isWindow || within.isDocument ? "" :=0A=
				within.element.css( "overflow-y" ),=0A=
			hasOverflowX =3D overflowX =3D=3D=3D "scroll" ||=0A=
				( overflowX =3D=3D=3D "auto" && within.width < =
within.element[0].scrollWidth ),=0A=
			hasOverflowY =3D overflowY =3D=3D=3D "scroll" ||=0A=
				( overflowY =3D=3D=3D "auto" && within.height < =
within.element[0].scrollHeight );=0A=
		return {=0A=
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,=0A=
			height: hasOverflowX ? $.position.scrollbarWidth() : 0=0A=
		};=0A=
	},=0A=
	getWithinInfo: function( element ) {=0A=
		var withinElement =3D $( element || window ),=0A=
			isWindow =3D $.isWindow( withinElement[0] ),=0A=
			isDocument =3D !!withinElement[ 0 ] && withinElement[ 0 ].nodeType =
=3D=3D=3D 9;=0A=
		return {=0A=
			element: withinElement,=0A=
			isWindow: isWindow,=0A=
			isDocument: isDocument,=0A=
			offset: withinElement.offset() || { left: 0, top: 0 },=0A=
			scrollLeft: withinElement.scrollLeft(),=0A=
			scrollTop: withinElement.scrollTop(),=0A=
=0A=
			// support: jQuery 1.6.x=0A=
			// jQuery 1.6 doesn't support .outerWidth/Height() on documents or =
windows=0A=
			width: isWindow || isDocument ? withinElement.width() : =
withinElement.outerWidth(),=0A=
			height: isWindow || isDocument ? withinElement.height() : =
withinElement.outerHeight()=0A=
		};=0A=
	}=0A=
};=0A=
=0A=
$.fn.position =3D function( options ) {=0A=
	if ( !options || !options.of ) {=0A=
		return _position.apply( this, arguments );=0A=
	}=0A=
=0A=
	// make a copy, we don't want to modify arguments=0A=
	options =3D $.extend( {}, options );=0A=
=0A=
	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, =
dimensions,=0A=
		target =3D $( options.of ),=0A=
		within =3D $.position.getWithinInfo( options.within ),=0A=
		scrollInfo =3D $.position.getScrollInfo( within ),=0A=
		collision =3D ( options.collision || "flip" ).split( " " ),=0A=
		offsets =3D {};=0A=
=0A=
	dimensions =3D getDimensions( target );=0A=
	if ( target[0].preventDefault ) {=0A=
		// force left top to allow flipping=0A=
		options.at =3D "left top";=0A=
	}=0A=
	targetWidth =3D dimensions.width;=0A=
	targetHeight =3D dimensions.height;=0A=
	targetOffset =3D dimensions.offset;=0A=
	// clone to reuse original targetOffset later=0A=
	basePosition =3D $.extend( {}, targetOffset );=0A=
=0A=
	// force my and at to have valid horizontal and vertical positions=0A=
	// if a value is missing or invalid, it will be converted to center=0A=
	$.each( [ "my", "at" ], function() {=0A=
		var pos =3D ( options[ this ] || "" ).split( " " ),=0A=
			horizontalOffset,=0A=
			verticalOffset;=0A=
=0A=
		if ( pos.length =3D=3D=3D 1) {=0A=
			pos =3D rhorizontal.test( pos[ 0 ] ) ?=0A=
				pos.concat( [ "center" ] ) :=0A=
				rvertical.test( pos[ 0 ] ) ?=0A=
					[ "center" ].concat( pos ) :=0A=
					[ "center", "center" ];=0A=
		}=0A=
		pos[ 0 ] =3D rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";=0A=
		pos[ 1 ] =3D rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";=0A=
=0A=
		// calculate offsets=0A=
		horizontalOffset =3D roffset.exec( pos[ 0 ] );=0A=
		verticalOffset =3D roffset.exec( pos[ 1 ] );=0A=
		offsets[ this ] =3D [=0A=
			horizontalOffset ? horizontalOffset[ 0 ] : 0,=0A=
			verticalOffset ? verticalOffset[ 0 ] : 0=0A=
		];=0A=
=0A=
		// reduce to just the positions without the offsets=0A=
		options[ this ] =3D [=0A=
			rposition.exec( pos[ 0 ] )[ 0 ],=0A=
			rposition.exec( pos[ 1 ] )[ 0 ]=0A=
		];=0A=
	});=0A=
=0A=
	// normalize collision option=0A=
	if ( collision.length =3D=3D=3D 1 ) {=0A=
		collision[ 1 ] =3D collision[ 0 ];=0A=
	}=0A=
=0A=
	if ( options.at[ 0 ] =3D=3D=3D "right" ) {=0A=
		basePosition.left +=3D targetWidth;=0A=
	} else if ( options.at[ 0 ] =3D=3D=3D "center" ) {=0A=
		basePosition.left +=3D targetWidth / 2;=0A=
	}=0A=
=0A=
	if ( options.at[ 1 ] =3D=3D=3D "bottom" ) {=0A=
		basePosition.top +=3D targetHeight;=0A=
	} else if ( options.at[ 1 ] =3D=3D=3D "center" ) {=0A=
		basePosition.top +=3D targetHeight / 2;=0A=
	}=0A=
=0A=
	atOffset =3D getOffsets( offsets.at, targetWidth, targetHeight );=0A=
	basePosition.left +=3D atOffset[ 0 ];=0A=
	basePosition.top +=3D atOffset[ 1 ];=0A=
=0A=
	return this.each(function() {=0A=
		var collisionPosition, using,=0A=
			elem =3D $( this ),=0A=
			elemWidth =3D elem.outerWidth(),=0A=
			elemHeight =3D elem.outerHeight(),=0A=
			marginLeft =3D parseCss( this, "marginLeft" ),=0A=
			marginTop =3D parseCss( this, "marginTop" ),=0A=
			collisionWidth =3D elemWidth + marginLeft + parseCss( this, =
"marginRight" ) + scrollInfo.width,=0A=
			collisionHeight =3D elemHeight + marginTop + parseCss( this, =
"marginBottom" ) + scrollInfo.height,=0A=
			position =3D $.extend( {}, basePosition ),=0A=
			myOffset =3D getOffsets( offsets.my, elem.outerWidth(), =
elem.outerHeight() );=0A=
=0A=
		if ( options.my[ 0 ] =3D=3D=3D "right" ) {=0A=
			position.left -=3D elemWidth;=0A=
		} else if ( options.my[ 0 ] =3D=3D=3D "center" ) {=0A=
			position.left -=3D elemWidth / 2;=0A=
		}=0A=
=0A=
		if ( options.my[ 1 ] =3D=3D=3D "bottom" ) {=0A=
			position.top -=3D elemHeight;=0A=
		} else if ( options.my[ 1 ] =3D=3D=3D "center" ) {=0A=
			position.top -=3D elemHeight / 2;=0A=
		}=0A=
=0A=
		position.left +=3D myOffset[ 0 ];=0A=
		position.top +=3D myOffset[ 1 ];=0A=
=0A=
		// if the browser doesn't support fractions, then round for consistent =
results=0A=
		if ( !supportsOffsetFractions ) {=0A=
			position.left =3D round( position.left );=0A=
			position.top =3D round( position.top );=0A=
		}=0A=
=0A=
		collisionPosition =3D {=0A=
			marginLeft: marginLeft,=0A=
			marginTop: marginTop=0A=
		};=0A=
=0A=
		$.each( [ "left", "top" ], function( i, dir ) {=0A=
			if ( $.ui.position[ collision[ i ] ] ) {=0A=
				$.ui.position[ collision[ i ] ][ dir ]( position, {=0A=
					targetWidth: targetWidth,=0A=
					targetHeight: targetHeight,=0A=
					elemWidth: elemWidth,=0A=
					elemHeight: elemHeight,=0A=
					collisionPosition: collisionPosition,=0A=
					collisionWidth: collisionWidth,=0A=
					collisionHeight: collisionHeight,=0A=
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ =
1 ] ],=0A=
					my: options.my,=0A=
					at: options.at,=0A=
					within: within,=0A=
					elem: elem=0A=
				});=0A=
			}=0A=
		});=0A=
=0A=
		if ( options.using ) {=0A=
			// adds feedback as second argument to using callback, if present=0A=
			using =3D function( props ) {=0A=
				var left =3D targetOffset.left - position.left,=0A=
					right =3D left + targetWidth - elemWidth,=0A=
					top =3D targetOffset.top - position.top,=0A=
					bottom =3D top + targetHeight - elemHeight,=0A=
					feedback =3D {=0A=
						target: {=0A=
							element: target,=0A=
							left: targetOffset.left,=0A=
							top: targetOffset.top,=0A=
							width: targetWidth,=0A=
							height: targetHeight=0A=
						},=0A=
						element: {=0A=
							element: elem,=0A=
							left: position.left,=0A=
							top: position.top,=0A=
							width: elemWidth,=0A=
							height: elemHeight=0A=
						},=0A=
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",=0A=
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"=0A=
					};=0A=
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {=0A=
					feedback.horizontal =3D "center";=0A=
				}=0A=
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight =
) {=0A=
					feedback.vertical =3D "middle";=0A=
				}=0A=
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom =
) ) ) {=0A=
					feedback.important =3D "horizontal";=0A=
				} else {=0A=
					feedback.important =3D "vertical";=0A=
				}=0A=
				options.using.call( this, props, feedback );=0A=
			};=0A=
		}=0A=
=0A=
		elem.offset( $.extend( position, { using: using } ) );=0A=
	});=0A=
};=0A=
=0A=
$.ui.position =3D {=0A=
	fit: {=0A=
		left: function( position, data ) {=0A=
			var within =3D data.within,=0A=
				withinOffset =3D within.isWindow ? within.scrollLeft : =
within.offset.left,=0A=
				outerWidth =3D within.width,=0A=
				collisionPosLeft =3D position.left - =
data.collisionPosition.marginLeft,=0A=
				overLeft =3D withinOffset - collisionPosLeft,=0A=
				overRight =3D collisionPosLeft + data.collisionWidth - outerWidth - =
withinOffset,=0A=
				newOverRight;=0A=
=0A=
			// element is wider than within=0A=
			if ( data.collisionWidth > outerWidth ) {=0A=
				// element is initially over the left side of within=0A=
				if ( overLeft > 0 && overRight <=3D 0 ) {=0A=
					newOverRight =3D position.left + overLeft + data.collisionWidth - =
outerWidth - withinOffset;=0A=
					position.left +=3D overLeft - newOverRight;=0A=
				// element is initially over right side of within=0A=
				} else if ( overRight > 0 && overLeft <=3D 0 ) {=0A=
					position.left =3D withinOffset;=0A=
				// element is initially over both left and right sides of within=0A=
				} else {=0A=
					if ( overLeft > overRight ) {=0A=
						position.left =3D withinOffset + outerWidth - data.collisionWidth;=0A=
					} else {=0A=
						position.left =3D withinOffset;=0A=
					}=0A=
				}=0A=
			// too far left -> align with left edge=0A=
			} else if ( overLeft > 0 ) {=0A=
				position.left +=3D overLeft;=0A=
			// too far right -> align with right edge=0A=
			} else if ( overRight > 0 ) {=0A=
				position.left -=3D overRight;=0A=
			// adjust based on position and margin=0A=
			} else {=0A=
				position.left =3D max( position.left - collisionPosLeft, =
position.left );=0A=
			}=0A=
		},=0A=
		top: function( position, data ) {=0A=
			var within =3D data.within,=0A=
				withinOffset =3D within.isWindow ? within.scrollTop : =
within.offset.top,=0A=
				outerHeight =3D data.within.height,=0A=
				collisionPosTop =3D position.top - data.collisionPosition.marginTop,=0A=
				overTop =3D withinOffset - collisionPosTop,=0A=
				overBottom =3D collisionPosTop + data.collisionHeight - outerHeight =
- withinOffset,=0A=
				newOverBottom;=0A=
=0A=
			// element is taller than within=0A=
			if ( data.collisionHeight > outerHeight ) {=0A=
				// element is initially over the top of within=0A=
				if ( overTop > 0 && overBottom <=3D 0 ) {=0A=
					newOverBottom =3D position.top + overTop + data.collisionHeight - =
outerHeight - withinOffset;=0A=
					position.top +=3D overTop - newOverBottom;=0A=
				// element is initially over bottom of within=0A=
				} else if ( overBottom > 0 && overTop <=3D 0 ) {=0A=
					position.top =3D withinOffset;=0A=
				// element is initially over both top and bottom of within=0A=
				} else {=0A=
					if ( overTop > overBottom ) {=0A=
						position.top =3D withinOffset + outerHeight - data.collisionHeight;=0A=
					} else {=0A=
						position.top =3D withinOffset;=0A=
					}=0A=
				}=0A=
			// too far up -> align with top=0A=
			} else if ( overTop > 0 ) {=0A=
				position.top +=3D overTop;=0A=
			// too far down -> align with bottom edge=0A=
			} else if ( overBottom > 0 ) {=0A=
				position.top -=3D overBottom;=0A=
			// adjust based on position and margin=0A=
			} else {=0A=
				position.top =3D max( position.top - collisionPosTop, position.top );=0A=
			}=0A=
		}=0A=
	},=0A=
	flip: {=0A=
		left: function( position, data ) {=0A=
			var within =3D data.within,=0A=
				withinOffset =3D within.offset.left + within.scrollLeft,=0A=
				outerWidth =3D within.width,=0A=
				offsetLeft =3D within.isWindow ? within.scrollLeft : =
within.offset.left,=0A=
				collisionPosLeft =3D position.left - =
data.collisionPosition.marginLeft,=0A=
				overLeft =3D collisionPosLeft - offsetLeft,=0A=
				overRight =3D collisionPosLeft + data.collisionWidth - outerWidth - =
offsetLeft,=0A=
				myOffset =3D data.my[ 0 ] =3D=3D=3D "left" ?=0A=
					-data.elemWidth :=0A=
					data.my[ 0 ] =3D=3D=3D "right" ?=0A=
						data.elemWidth :=0A=
						0,=0A=
				atOffset =3D data.at[ 0 ] =3D=3D=3D "left" ?=0A=
					data.targetWidth :=0A=
					data.at[ 0 ] =3D=3D=3D "right" ?=0A=
						-data.targetWidth :=0A=
						0,=0A=
				offset =3D -2 * data.offset[ 0 ],=0A=
				newOverRight,=0A=
				newOverLeft;=0A=
=0A=
			if ( overLeft < 0 ) {=0A=
				newOverRight =3D position.left + myOffset + atOffset + offset + =
data.collisionWidth - outerWidth - withinOffset;=0A=
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {=0A=
					position.left +=3D myOffset + atOffset + offset;=0A=
				}=0A=
			} else if ( overRight > 0 ) {=0A=
				newOverLeft =3D position.left - data.collisionPosition.marginLeft + =
myOffset + atOffset + offset - offsetLeft;=0A=
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {=0A=
					position.left +=3D myOffset + atOffset + offset;=0A=
				}=0A=
			}=0A=
		},=0A=
		top: function( position, data ) {=0A=
			var within =3D data.within,=0A=
				withinOffset =3D within.offset.top + within.scrollTop,=0A=
				outerHeight =3D within.height,=0A=
				offsetTop =3D within.isWindow ? within.scrollTop : within.offset.top,=0A=
				collisionPosTop =3D position.top - data.collisionPosition.marginTop,=0A=
				overTop =3D collisionPosTop - offsetTop,=0A=
				overBottom =3D collisionPosTop + data.collisionHeight - outerHeight =
- offsetTop,=0A=
				top =3D data.my[ 1 ] =3D=3D=3D "top",=0A=
				myOffset =3D top ?=0A=
					-data.elemHeight :=0A=
					data.my[ 1 ] =3D=3D=3D "bottom" ?=0A=
						data.elemHeight :=0A=
						0,=0A=
				atOffset =3D data.at[ 1 ] =3D=3D=3D "top" ?=0A=
					data.targetHeight :=0A=
					data.at[ 1 ] =3D=3D=3D "bottom" ?=0A=
						-data.targetHeight :=0A=
						0,=0A=
				offset =3D -2 * data.offset[ 1 ],=0A=
				newOverTop,=0A=
				newOverBottom;=0A=
			if ( overTop < 0 ) {=0A=
				newOverBottom =3D position.top + myOffset + atOffset + offset + =
data.collisionHeight - outerHeight - withinOffset;=0A=
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( =
newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {=0A=
					position.top +=3D myOffset + atOffset + offset;=0A=
				}=0A=
			} else if ( overBottom > 0 ) {=0A=
				newOverTop =3D position.top - data.collisionPosition.marginTop + =
myOffset + atOffset + offset - offsetTop;=0A=
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && =
( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {=0A=
					position.top +=3D myOffset + atOffset + offset;=0A=
				}=0A=
			}=0A=
		}=0A=
	},=0A=
	flipfit: {=0A=
		left: function() {=0A=
			$.ui.position.flip.left.apply( this, arguments );=0A=
			$.ui.position.fit.left.apply( this, arguments );=0A=
		},=0A=
		top: function() {=0A=
			$.ui.position.flip.top.apply( this, arguments );=0A=
			$.ui.position.fit.top.apply( this, arguments );=0A=
		}=0A=
	}=0A=
};=0A=
=0A=
// fraction support test=0A=
(function() {=0A=
	var testElement, testElementParent, testElementStyle, offsetLeft, i,=0A=
		body =3D document.getElementsByTagName( "body" )[ 0 ],=0A=
		div =3D document.createElement( "div" );=0A=
=0A=
	//Create a "fake body" for testing based on method used in =
jQuery.support=0A=
	testElement =3D document.createElement( body ? "div" : "body" );=0A=
	testElementStyle =3D {=0A=
		visibility: "hidden",=0A=
		width: 0,=0A=
		height: 0,=0A=
		border: 0,=0A=
		margin: 0,=0A=
		background: "none"=0A=
	};=0A=
	if ( body ) {=0A=
		$.extend( testElementStyle, {=0A=
			position: "absolute",=0A=
			left: "-1000px",=0A=
			top: "-1000px"=0A=
		});=0A=
	}=0A=
	for ( i in testElementStyle ) {=0A=
		testElement.style[ i ] =3D testElementStyle[ i ];=0A=
	}=0A=
	testElement.appendChild( div );=0A=
	testElementParent =3D body || document.documentElement;=0A=
	testElementParent.insertBefore( testElement, =
testElementParent.firstChild );=0A=
=0A=
	div.style.cssText =3D "position: absolute; left: 10.7432222px;";=0A=
=0A=
	offsetLeft =3D $( div ).offset().left;=0A=
	supportsOffsetFractions =3D offsetLeft > 10 && offsetLeft < 11;=0A=
=0A=
	testElement.innerHTML =3D "";=0A=
	testElementParent.removeChild( testElement );=0A=
})();=0A=
=0A=
})();=0A=
=0A=
var position =3D $.ui.position;=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Draggable 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/draggable/=0A=
 */=0A=
=0A=
=0A=
$.widget("ui.draggable", $.ui.mouse, {=0A=
	version: "1.11.1",=0A=
	widgetEventPrefix: "drag",=0A=
	options: {=0A=
		addClasses: true,=0A=
		appendTo: "parent",=0A=
		axis: false,=0A=
		connectToSortable: false,=0A=
		containment: false,=0A=
		cursor: "auto",=0A=
		cursorAt: false,=0A=
		grid: false,=0A=
		handle: false,=0A=
		helper: "original",=0A=
		iframeFix: false,=0A=
		opacity: false,=0A=
		refreshPositions: false,=0A=
		revert: false,=0A=
		revertDuration: 500,=0A=
		scope: "default",=0A=
		scroll: true,=0A=
		scrollSensitivity: 20,=0A=
		scrollSpeed: 20,=0A=
		snap: false,=0A=
		snapMode: "both",=0A=
		snapTolerance: 20,=0A=
		stack: false,=0A=
		zIndex: false,=0A=
=0A=
		// callbacks=0A=
		drag: null,=0A=
		start: null,=0A=
		stop: null=0A=
	},=0A=
	_create: function() {=0A=
=0A=
		if (this.options.helper =3D=3D=3D "original" && =
!(/^(?:r|a|f)/).test(this.element.css("position"))) {=0A=
			this.element[0].style.position =3D "relative";=0A=
		}=0A=
		if (this.options.addClasses){=0A=
			this.element.addClass("ui-draggable");=0A=
		}=0A=
		if (this.options.disabled){=0A=
			this.element.addClass("ui-draggable-disabled");=0A=
		}=0A=
		this._setHandleClassName();=0A=
=0A=
		this._mouseInit();=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		this._super( key, value );=0A=
		if ( key =3D=3D=3D "handle" ) {=0A=
			this._removeHandleClassName();=0A=
			this._setHandleClassName();=0A=
		}=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {=0A=
			this.destroyOnClear =3D true;=0A=
			return;=0A=
		}=0A=
		this.element.removeClass( "ui-draggable ui-draggable-dragging =
ui-draggable-disabled" );=0A=
		this._removeHandleClassName();=0A=
		this._mouseDestroy();=0A=
	},=0A=
=0A=
	_mouseCapture: function(event) {=0A=
=0A=
		var document =3D this.document[ 0 ],=0A=
			o =3D this.options;=0A=
=0A=
		// support: IE9=0A=
		// IE9 throws an "Unspecified error" accessing document.activeElement =
from an <iframe>=0A=
		try {=0A=
			// Support: IE9+=0A=
			// If the <body> is blurred, IE will switch windows, see #9520=0A=
			if ( document.activeElement && =
document.activeElement.nodeName.toLowerCase() !=3D=3D "body" ) {=0A=
				// Blur any element that currently has focus, see #4261=0A=
				$( document.activeElement ).blur();=0A=
			}=0A=
		} catch ( error ) {}=0A=
=0A=
		// among others, prevent a drag on a resizable-handle=0A=
		if (this.helper || o.disabled || =
$(event.target).closest(".ui-resizable-handle").length > 0) {=0A=
			return false;=0A=
		}=0A=
=0A=
		//Quit if we're not on a valid handle=0A=
		this.handle =3D this._getHandle(event);=0A=
		if (!this.handle) {=0A=
			return false;=0A=
		}=0A=
=0A=
		$(o.iframeFix =3D=3D=3D true ? "iframe" : o.iframeFix).each(function() =
{=0A=
			$("<div class=3D'ui-draggable-iframeFix' style=3D'background: =
#fff;'></div>")=0A=
			.css({=0A=
				width: this.offsetWidth + "px", height: this.offsetHeight + "px",=0A=
				position: "absolute", opacity: "0.001", zIndex: 1000=0A=
			})=0A=
			.css($(this).offset())=0A=
			.appendTo("body");=0A=
		});=0A=
=0A=
		return true;=0A=
=0A=
	},=0A=
=0A=
	_mouseStart: function(event) {=0A=
=0A=
		var o =3D this.options;=0A=
=0A=
		//Create and append the visible helper=0A=
		this.helper =3D this._createHelper(event);=0A=
=0A=
		this.helper.addClass("ui-draggable-dragging");=0A=
=0A=
		//Cache the helper size=0A=
		this._cacheHelperProportions();=0A=
=0A=
		//If ddmanager is used for droppables, set the global draggable=0A=
		if ($.ui.ddmanager) {=0A=
			$.ui.ddmanager.current =3D this;=0A=
		}=0A=
=0A=
		/*=0A=
		 * - Position generation -=0A=
		 * This block generates everything position related - it's the core of =
draggables.=0A=
		 */=0A=
=0A=
		//Cache the margins of the original element=0A=
		this._cacheMargins();=0A=
=0A=
		//Store the helper's css position=0A=
		this.cssPosition =3D this.helper.css( "position" );=0A=
		this.scrollParent =3D this.helper.scrollParent( true );=0A=
		this.offsetParent =3D this.helper.offsetParent();=0A=
		this.offsetParentCssPosition =3D this.offsetParent.css( "position" );=0A=
=0A=
		//The element's absolute position on the page minus margins=0A=
		this.offset =3D this.positionAbs =3D this.element.offset();=0A=
		this.offset =3D {=0A=
			top: this.offset.top - this.margins.top,=0A=
			left: this.offset.left - this.margins.left=0A=
		};=0A=
=0A=
		//Reset scroll cache=0A=
		this.offset.scroll =3D false;=0A=
=0A=
		$.extend(this.offset, {=0A=
			click: { //Where the click happened, relative to the element=0A=
				left: event.pageX - this.offset.left,=0A=
				top: event.pageY - this.offset.top=0A=
			},=0A=
			parent: this._getParentOffset(),=0A=
			relative: this._getRelativeOffset() //This is a relative to absolute =
position minus the actual position calculation - only used for relative =
positioned helper=0A=
		});=0A=
=0A=
		//Generate the original position=0A=
		this.originalPosition =3D this.position =3D this._generatePosition( =
event, false );=0A=
		this.originalPageX =3D event.pageX;=0A=
		this.originalPageY =3D event.pageY;=0A=
=0A=
		//Adjust the mouse offset relative to the helper if "cursorAt" is =
supplied=0A=
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));=0A=
=0A=
		//Set a containment if given in the options=0A=
		this._setContainment();=0A=
=0A=
		//Trigger event + callbacks=0A=
		if (this._trigger("start", event) =3D=3D=3D false) {=0A=
			this._clear();=0A=
			return false;=0A=
		}=0A=
=0A=
		//Recache the helper size=0A=
		this._cacheHelperProportions();=0A=
=0A=
		//Prepare the droppable offsets=0A=
		if ($.ui.ddmanager && !o.dropBehaviour) {=0A=
			$.ui.ddmanager.prepareOffsets(this, event);=0A=
		}=0A=
=0A=
		this._mouseDrag(event, true); //Execute the drag once - this causes =
the helper not to be visible before getting its correct position=0A=
=0A=
		//If the ddmanager is used for droppables, inform the manager that =
dragging has started (see #5003)=0A=
		if ( $.ui.ddmanager ) {=0A=
			$.ui.ddmanager.dragStart(this, event);=0A=
		}=0A=
=0A=
		return true;=0A=
	},=0A=
=0A=
	_mouseDrag: function(event, noPropagation) {=0A=
		// reset any necessary cached properties (see #5009)=0A=
		if ( this.offsetParentCssPosition =3D=3D=3D "fixed" ) {=0A=
			this.offset.parent =3D this._getParentOffset();=0A=
		}=0A=
=0A=
		//Compute the helpers position=0A=
		this.position =3D this._generatePosition( event, true );=0A=
		this.positionAbs =3D this._convertPositionTo("absolute");=0A=
=0A=
		//Call plugins and callbacks and use the resulting position if =
something is returned=0A=
		if (!noPropagation) {=0A=
			var ui =3D this._uiHash();=0A=
			if (this._trigger("drag", event, ui) =3D=3D=3D false) {=0A=
				this._mouseUp({});=0A=
				return false;=0A=
			}=0A=
			this.position =3D ui.position;=0A=
		}=0A=
=0A=
		this.helper[ 0 ].style.left =3D this.position.left + "px";=0A=
		this.helper[ 0 ].style.top =3D this.position.top + "px";=0A=
=0A=
		if ($.ui.ddmanager) {=0A=
			$.ui.ddmanager.drag(this, event);=0A=
		}=0A=
=0A=
		return false;=0A=
	},=0A=
=0A=
	_mouseStop: function(event) {=0A=
=0A=
		//If we are using droppables, inform the manager about the drop=0A=
		var that =3D this,=0A=
			dropped =3D false;=0A=
		if ($.ui.ddmanager && !this.options.dropBehaviour) {=0A=
			dropped =3D $.ui.ddmanager.drop(this, event);=0A=
		}=0A=
=0A=
		//if a drop comes from outside (a sortable)=0A=
		if (this.dropped) {=0A=
			dropped =3D this.dropped;=0A=
			this.dropped =3D false;=0A=
		}=0A=
=0A=
		if ((this.options.revert =3D=3D=3D "invalid" && !dropped) || =
(this.options.revert =3D=3D=3D "valid" && dropped) || =
this.options.revert =3D=3D=3D true || ($.isFunction(this.options.revert) =
&& this.options.revert.call(this.element, dropped))) {=0A=
			$(this.helper).animate(this.originalPosition, =
parseInt(this.options.revertDuration, 10), function() {=0A=
				if (that._trigger("stop", event) !=3D=3D false) {=0A=
					that._clear();=0A=
				}=0A=
			});=0A=
		} else {=0A=
			if (this._trigger("stop", event) !=3D=3D false) {=0A=
				this._clear();=0A=
			}=0A=
		}=0A=
=0A=
		return false;=0A=
	},=0A=
=0A=
	_mouseUp: function(event) {=0A=
		//Remove frame helpers=0A=
		$("div.ui-draggable-iframeFix").each(function() {=0A=
			this.parentNode.removeChild(this);=0A=
		});=0A=
=0A=
		//If the ddmanager is used for droppables, inform the manager that =
dragging has stopped (see #5003)=0A=
		if ( $.ui.ddmanager ) {=0A=
			$.ui.ddmanager.dragStop(this, event);=0A=
		}=0A=
=0A=
		// The interaction is over; whether or not the click resulted in a =
drag, focus the element=0A=
		this.element.focus();=0A=
=0A=
		return $.ui.mouse.prototype._mouseUp.call(this, event);=0A=
	},=0A=
=0A=
	cancel: function() {=0A=
=0A=
		if (this.helper.is(".ui-draggable-dragging")) {=0A=
			this._mouseUp({});=0A=
		} else {=0A=
			this._clear();=0A=
		}=0A=
=0A=
		return this;=0A=
=0A=
	},=0A=
=0A=
	_getHandle: function(event) {=0A=
		return this.options.handle ?=0A=
			!!$( event.target ).closest( this.element.find( this.options.handle ) =
).length :=0A=
			true;=0A=
	},=0A=
=0A=
	_setHandleClassName: function() {=0A=
		this.handleElement =3D this.options.handle ?=0A=
			this.element.find( this.options.handle ) : this.element;=0A=
		this.handleElement.addClass( "ui-draggable-handle" );=0A=
	},=0A=
=0A=
	_removeHandleClassName: function() {=0A=
		this.handleElement.removeClass( "ui-draggable-handle" );=0A=
	},=0A=
=0A=
	_createHelper: function(event) {=0A=
=0A=
		var o =3D this.options,=0A=
			helper =3D $.isFunction(o.helper) ? $(o.helper.apply(this.element[ 0 =
], [ event ])) : (o.helper =3D=3D=3D "clone" ? =
this.element.clone().removeAttr("id") : this.element);=0A=
=0A=
		if (!helper.parents("body").length) {=0A=
			helper.appendTo((o.appendTo =3D=3D=3D "parent" ? =
this.element[0].parentNode : o.appendTo));=0A=
		}=0A=
=0A=
		if (helper[0] !=3D=3D this.element[0] && =
!(/(fixed|absolute)/).test(helper.css("position"))) {=0A=
			helper.css("position", "absolute");=0A=
		}=0A=
=0A=
		return helper;=0A=
=0A=
	},=0A=
=0A=
	_adjustOffsetFromHelper: function(obj) {=0A=
		if (typeof obj =3D=3D=3D "string") {=0A=
			obj =3D obj.split(" ");=0A=
		}=0A=
		if ($.isArray(obj)) {=0A=
			obj =3D { left: +obj[0], top: +obj[1] || 0 };=0A=
		}=0A=
		if ("left" in obj) {=0A=
			this.offset.click.left =3D obj.left + this.margins.left;=0A=
		}=0A=
		if ("right" in obj) {=0A=
			this.offset.click.left =3D this.helperProportions.width - obj.right + =
this.margins.left;=0A=
		}=0A=
		if ("top" in obj) {=0A=
			this.offset.click.top =3D obj.top + this.margins.top;=0A=
		}=0A=
		if ("bottom" in obj) {=0A=
			this.offset.click.top =3D this.helperProportions.height - obj.bottom =
+ this.margins.top;=0A=
		}=0A=
	},=0A=
=0A=
	_isRootNode: function( element ) {=0A=
		return ( /(html|body)/i ).test( element.tagName ) || element =3D=3D=3D =
this.document[ 0 ];=0A=
	},=0A=
=0A=
	_getParentOffset: function() {=0A=
=0A=
		//Get the offsetParent and cache its position=0A=
		var po =3D this.offsetParent.offset(),=0A=
			document =3D this.document[ 0 ];=0A=
=0A=
		// This is a special case where we need to modify a offset calculated =
on start, since the following happened:=0A=
		// 1. The position of the helper is absolute, so it's position is =
calculated based on the next positioned parent=0A=
		// 2. The actual offset parent is a child of the scroll parent, and =
the scroll parent isn't the document, which means that=0A=
		//    the scroll is included in the initial calculation of the offset =
of the parent, and never recalculated upon drag=0A=
		if (this.cssPosition =3D=3D=3D "absolute" && this.scrollParent[0] =
!=3D=3D document && $.contains(this.scrollParent[0], =
this.offsetParent[0])) {=0A=
			po.left +=3D this.scrollParent.scrollLeft();=0A=
			po.top +=3D this.scrollParent.scrollTop();=0A=
		}=0A=
=0A=
		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {=0A=
			po =3D { top: 0, left: 0 };=0A=
		}=0A=
=0A=
		return {=0A=
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) =
|| 0),=0A=
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), =
10) || 0)=0A=
		};=0A=
=0A=
	},=0A=
=0A=
	_getRelativeOffset: function() {=0A=
		if ( this.cssPosition !=3D=3D "relative" ) {=0A=
			return { top: 0, left: 0 };=0A=
		}=0A=
=0A=
		var p =3D this.element.position(),=0A=
			scrollIsRootNode =3D this._isRootNode( this.scrollParent[ 0 ] );=0A=
=0A=
		return {=0A=
			top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( =
!scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),=0A=
			left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( =
!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )=0A=
		};=0A=
=0A=
	},=0A=
=0A=
	_cacheMargins: function() {=0A=
		this.margins =3D {=0A=
			left: (parseInt(this.element.css("marginLeft"), 10) || 0),=0A=
			top: (parseInt(this.element.css("marginTop"), 10) || 0),=0A=
			right: (parseInt(this.element.css("marginRight"), 10) || 0),=0A=
			bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)=0A=
		};=0A=
	},=0A=
=0A=
	_cacheHelperProportions: function() {=0A=
		this.helperProportions =3D {=0A=
			width: this.helper.outerWidth(),=0A=
			height: this.helper.outerHeight()=0A=
		};=0A=
	},=0A=
=0A=
	_setContainment: function() {=0A=
=0A=
		var over, c, ce,=0A=
			o =3D this.options,=0A=
			document =3D this.document[ 0 ];=0A=
=0A=
		this.relativeContainer =3D null;=0A=
=0A=
		if ( !o.containment ) {=0A=
			this.containment =3D null;=0A=
			return;=0A=
		}=0A=
=0A=
		if ( o.containment =3D=3D=3D "window" ) {=0A=
			this.containment =3D [=0A=
				$( window ).scrollLeft() - this.offset.relative.left - =
this.offset.parent.left,=0A=
				$( window ).scrollTop() - this.offset.relative.top - =
this.offset.parent.top,=0A=
				$( window ).scrollLeft() + $( window ).width() - =
this.helperProportions.width - this.margins.left,=0A=
				$( window ).scrollTop() + ( $( window ).height() || =
document.body.parentNode.scrollHeight ) - this.helperProportions.height =
- this.margins.top=0A=
			];=0A=
			return;=0A=
		}=0A=
=0A=
		if ( o.containment =3D=3D=3D "document") {=0A=
			this.containment =3D [=0A=
				0,=0A=
				0,=0A=
				$( document ).width() - this.helperProportions.width - =
this.margins.left,=0A=
				( $( document ).height() || document.body.parentNode.scrollHeight ) =
- this.helperProportions.height - this.margins.top=0A=
			];=0A=
			return;=0A=
		}=0A=
=0A=
		if ( o.containment.constructor =3D=3D=3D Array ) {=0A=
			this.containment =3D o.containment;=0A=
			return;=0A=
		}=0A=
=0A=
		if ( o.containment =3D=3D=3D "parent" ) {=0A=
			o.containment =3D this.helper[ 0 ].parentNode;=0A=
		}=0A=
=0A=
		c =3D $( o.containment );=0A=
		ce =3D c[ 0 ];=0A=
=0A=
		if ( !ce ) {=0A=
			return;=0A=
		}=0A=
=0A=
		over =3D c.css( "overflow" ) !=3D=3D "hidden";=0A=
=0A=
		this.containment =3D [=0A=
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( =
c.css( "paddingLeft" ), 10 ) || 0 ),=0A=
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( =
c.css( "paddingTop" ), 10 ) || 0 ),=0A=
			( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth =
) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( =
c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - =
this.margins.left - this.margins.right,=0A=
			( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : =
ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 =
) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - =
this.helperProportions.height - this.margins.top  - this.margins.bottom=0A=
		];=0A=
		this.relativeContainer =3D c;=0A=
	},=0A=
=0A=
	_convertPositionTo: function(d, pos) {=0A=
=0A=
		if (!pos) {=0A=
			pos =3D this.position;=0A=
		}=0A=
=0A=
		var mod =3D d =3D=3D=3D "absolute" ? 1 : -1,=0A=
			scrollIsRootNode =3D this._isRootNode( this.scrollParent[ 0 ] );=0A=
=0A=
		return {=0A=
			top: (=0A=
				pos.top	+																// The absolute mouse position=0A=
				this.offset.relative.top * mod +										// Only for relative =
positioned nodes: Relative offset from element to offset parent=0A=
				this.offset.parent.top * mod -										// The offsetParent's offset =
without borders (offset + border)=0A=
				( ( this.cssPosition =3D=3D=3D "fixed" ? -this.offset.scroll.top : ( =
scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)=0A=
			),=0A=
			left: (=0A=
				pos.left +																// The absolute mouse position=0A=
				this.offset.relative.left * mod +										// Only for relative =
positioned nodes: Relative offset from element to offset parent=0A=
				this.offset.parent.left * mod	-										// The offsetParent's =
offset without borders (offset + border)=0A=
				( ( this.cssPosition =3D=3D=3D "fixed" ? -this.offset.scroll.left : =
( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)=0A=
			)=0A=
		};=0A=
=0A=
	},=0A=
=0A=
	_generatePosition: function( event, constrainPosition ) {=0A=
=0A=
		var containment, co, top, left,=0A=
			o =3D this.options,=0A=
			scrollIsRootNode =3D this._isRootNode( this.scrollParent[ 0 ] ),=0A=
			pageX =3D event.pageX,=0A=
			pageY =3D event.pageY;=0A=
=0A=
		// Cache the scroll=0A=
		if ( !scrollIsRootNode || !this.offset.scroll ) {=0A=
			this.offset.scroll =3D {=0A=
				top: this.scrollParent.scrollTop(),=0A=
				left: this.scrollParent.scrollLeft()=0A=
			};=0A=
		}=0A=
=0A=
		/*=0A=
		 * - Position constraining -=0A=
		 * Constrain the position to a mix of grid, containment.=0A=
		 */=0A=
=0A=
		// If we are not dragging yet, we won't check for options=0A=
		if ( constrainPosition ) {=0A=
			if ( this.containment ) {=0A=
				if ( this.relativeContainer ){=0A=
					co =3D this.relativeContainer.offset();=0A=
					containment =3D [=0A=
						this.containment[ 0 ] + co.left,=0A=
						this.containment[ 1 ] + co.top,=0A=
						this.containment[ 2 ] + co.left,=0A=
						this.containment[ 3 ] + co.top=0A=
					];=0A=
				} else {=0A=
					containment =3D this.containment;=0A=
				}=0A=
=0A=
				if (event.pageX - this.offset.click.left < containment[0]) {=0A=
					pageX =3D containment[0] + this.offset.click.left;=0A=
				}=0A=
				if (event.pageY - this.offset.click.top < containment[1]) {=0A=
					pageY =3D containment[1] + this.offset.click.top;=0A=
				}=0A=
				if (event.pageX - this.offset.click.left > containment[2]) {=0A=
					pageX =3D containment[2] + this.offset.click.left;=0A=
				}=0A=
				if (event.pageY - this.offset.click.top > containment[3]) {=0A=
					pageY =3D containment[3] + this.offset.click.top;=0A=
				}=0A=
			}=0A=
=0A=
			if (o.grid) {=0A=
				//Check for grid elements set to 0 to prevent divide by 0 error =
causing invalid argument errors in IE (see ticket #6950)=0A=
				top =3D o.grid[1] ? this.originalPageY + Math.round((pageY - =
this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;=0A=
				pageY =3D containment ? ((top - this.offset.click.top >=3D =
containment[1] || top - this.offset.click.top > containment[3]) ? top : =
((top - this.offset.click.top >=3D containment[1]) ? top - o.grid[1] : =
top + o.grid[1])) : top;=0A=
=0A=
				left =3D o.grid[0] ? this.originalPageX + Math.round((pageX - =
this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;=0A=
				pageX =3D containment ? ((left - this.offset.click.left >=3D =
containment[0] || left - this.offset.click.left > containment[2]) ? left =
: ((left - this.offset.click.left >=3D containment[0]) ? left - =
o.grid[0] : left + o.grid[0])) : left;=0A=
			}=0A=
=0A=
			if ( o.axis =3D=3D=3D "y" ) {=0A=
				pageX =3D this.originalPageX;=0A=
			}=0A=
=0A=
			if ( o.axis =3D=3D=3D "x" ) {=0A=
				pageY =3D this.originalPageY;=0A=
			}=0A=
		}=0A=
=0A=
		return {=0A=
			top: (=0A=
				pageY -																	// The absolute mouse position=0A=
				this.offset.click.top	-												// Click offset (relative to the =
element)=0A=
				this.offset.relative.top -												// Only for relative =
positioned nodes: Relative offset from element to offset parent=0A=
				this.offset.parent.top +												// The offsetParent's offset =
without borders (offset + border)=0A=
				( this.cssPosition =3D=3D=3D "fixed" ? -this.offset.scroll.top : ( =
scrollIsRootNode ? 0 : this.offset.scroll.top ) )=0A=
			),=0A=
			left: (=0A=
				pageX -																	// The absolute mouse position=0A=
				this.offset.click.left -												// Click offset (relative to the =
element)=0A=
				this.offset.relative.left -												// Only for relative =
positioned nodes: Relative offset from element to offset parent=0A=
				this.offset.parent.left +												// The offsetParent's offset =
without borders (offset + border)=0A=
				( this.cssPosition =3D=3D=3D "fixed" ? -this.offset.scroll.left : ( =
scrollIsRootNode ? 0 : this.offset.scroll.left ) )=0A=
			)=0A=
		};=0A=
=0A=
	},=0A=
=0A=
	_clear: function() {=0A=
		this.helper.removeClass("ui-draggable-dragging");=0A=
		if (this.helper[0] !=3D=3D this.element[0] && =
!this.cancelHelperRemoval) {=0A=
			this.helper.remove();=0A=
		}=0A=
		this.helper =3D null;=0A=
		this.cancelHelperRemoval =3D false;=0A=
		if ( this.destroyOnClear ) {=0A=
			this.destroy();=0A=
		}=0A=
	},=0A=
=0A=
	// From now on bulk stuff - mainly helpers=0A=
=0A=
	_trigger: function(type, event, ui) {=0A=
		ui =3D ui || this._uiHash();=0A=
		$.ui.plugin.call( this, type, [ event, ui, this ], true );=0A=
		//The absolute position has to be recalculated after plugins=0A=
		if (type =3D=3D=3D "drag") {=0A=
			this.positionAbs =3D this._convertPositionTo("absolute");=0A=
		}=0A=
		return $.Widget.prototype._trigger.call(this, type, event, ui);=0A=
	},=0A=
=0A=
	plugins: {},=0A=
=0A=
	_uiHash: function() {=0A=
		return {=0A=
			helper: this.helper,=0A=
			position: this.position,=0A=
			originalPosition: this.originalPosition,=0A=
			offset: this.positionAbs=0A=
		};=0A=
	}=0A=
=0A=
});=0A=
=0A=
$.ui.plugin.add("draggable", "connectToSortable", {=0A=
	start: function( event, ui, inst ) {=0A=
=0A=
		var o =3D inst.options,=0A=
			uiSortable =3D $.extend({}, ui, { item: inst.element });=0A=
		inst.sortables =3D [];=0A=
		$(o.connectToSortable).each(function() {=0A=
			var sortable =3D $( this ).sortable( "instance" );=0A=
			if (sortable && !sortable.options.disabled) {=0A=
				inst.sortables.push({=0A=
					instance: sortable,=0A=
					shouldRevert: sortable.options.revert=0A=
				});=0A=
				sortable.refreshPositions();	// Call the sortable's refreshPositions =
at drag start to refresh the containerCache since the sortable container =
cache is used in drag and needs to be up to date (this will ensure it's =
initialised as well as being kept in step with any changes that might =
have happened on the page).=0A=
				sortable._trigger("activate", event, uiSortable);=0A=
			}=0A=
		});=0A=
=0A=
	},=0A=
	stop: function( event, ui, inst ) {=0A=
=0A=
		//If we are still over the sortable, we fake the stop event of the =
sortable, but also remove helper=0A=
		var uiSortable =3D $.extend( {}, ui, {=0A=
			item: inst.element=0A=
		});=0A=
=0A=
		$.each(inst.sortables, function() {=0A=
			if (this.instance.isOver) {=0A=
=0A=
				this.instance.isOver =3D 0;=0A=
=0A=
				inst.cancelHelperRemoval =3D true; //Don't remove the helper in the =
draggable instance=0A=
				this.instance.cancelHelperRemoval =3D false; //Remove it in the =
sortable instance (so sortable plugins like revert still work)=0A=
=0A=
				//The sortable revert is supported, and we have to set a temporary =
dropped variable on the draggable to support revert: "valid/invalid"=0A=
				if (this.shouldRevert) {=0A=
					this.instance.options.revert =3D this.shouldRevert;=0A=
				}=0A=
=0A=
				//Trigger the stop of the sortable=0A=
				this.instance._mouseStop(event);=0A=
=0A=
				this.instance.options.helper =3D this.instance.options._helper;=0A=
=0A=
				//If the helper has been the original item, restore properties in =
the sortable=0A=
				if (inst.options.helper =3D=3D=3D "original") {=0A=
					this.instance.currentItem.css({ top: "auto", left: "auto" });=0A=
				}=0A=
=0A=
			} else {=0A=
				this.instance.cancelHelperRemoval =3D false; //Remove the helper in =
the sortable instance=0A=
				this.instance._trigger("deactivate", event, uiSortable);=0A=
			}=0A=
=0A=
		});=0A=
=0A=
	},=0A=
	drag: function( event, ui, inst ) {=0A=
=0A=
		var that =3D this;=0A=
=0A=
		$.each(inst.sortables, function() {=0A=
=0A=
			var innermostIntersecting =3D false,=0A=
				thisSortable =3D this;=0A=
=0A=
			//Copy over some variables to allow calling the sortable's native =
_intersectsWith=0A=
			this.instance.positionAbs =3D inst.positionAbs;=0A=
			this.instance.helperProportions =3D inst.helperProportions;=0A=
			this.instance.offset.click =3D inst.offset.click;=0A=
=0A=
			if (this.instance._intersectsWith(this.instance.containerCache)) {=0A=
				innermostIntersecting =3D true;=0A=
				$.each(inst.sortables, function() {=0A=
					this.instance.positionAbs =3D inst.positionAbs;=0A=
					this.instance.helperProportions =3D inst.helperProportions;=0A=
					this.instance.offset.click =3D inst.offset.click;=0A=
					if (this !=3D=3D thisSortable &&=0A=
						this.instance._intersectsWith(this.instance.containerCache) &&=0A=
						$.contains(thisSortable.instance.element[0], =
this.instance.element[0])=0A=
					) {=0A=
						innermostIntersecting =3D false;=0A=
					}=0A=
					return innermostIntersecting;=0A=
				});=0A=
			}=0A=
=0A=
			if (innermostIntersecting) {=0A=
				//If it intersects, we use a little isOver variable and set it once, =
so our move-in stuff gets fired only once=0A=
				if (!this.instance.isOver) {=0A=
=0A=
					this.instance.isOver =3D 1;=0A=
					//Now we fake the start of dragging for the sortable instance,=0A=
					//by cloning the list group item, appending it to the sortable and =
using it as inst.currentItem=0A=
					//We can then fire the start event of the sortable with our passed =
browser event, and our own helper (so it doesn't create a new one)=0A=
					this.instance.currentItem =3D =
$(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui=
-sortable-item", true);=0A=
					this.instance.options._helper =3D this.instance.options.helper; =
//Store helper option to later restore it=0A=
					this.instance.options.helper =3D function() { return ui.helper[0]; =
};=0A=
=0A=
					event.target =3D this.instance.currentItem[0];=0A=
					this.instance._mouseCapture(event, true);=0A=
					this.instance._mouseStart(event, true, true);=0A=
=0A=
					//Because the browser event is way off the new appended portlet, we =
modify a couple of variables to reflect the changes=0A=
					this.instance.offset.click.top =3D inst.offset.click.top;=0A=
					this.instance.offset.click.left =3D inst.offset.click.left;=0A=
					this.instance.offset.parent.left -=3D inst.offset.parent.left - =
this.instance.offset.parent.left;=0A=
					this.instance.offset.parent.top -=3D inst.offset.parent.top - =
this.instance.offset.parent.top;=0A=
=0A=
					inst._trigger("toSortable", event);=0A=
					inst.dropped =3D this.instance.element; //draggable revert needs =
that=0A=
					//hack so receive/update callbacks work (mostly)=0A=
					inst.currentItem =3D inst.element;=0A=
					this.instance.fromOutside =3D inst;=0A=
=0A=
				}=0A=
=0A=
				//Provided we did all the previous steps, we can fire the drag event =
of the sortable on every draggable drag, when it intersects with the =
sortable=0A=
				if (this.instance.currentItem) {=0A=
					this.instance._mouseDrag(event);=0A=
				}=0A=
=0A=
			} else {=0A=
=0A=
				//If it doesn't intersect with the sortable, and it intersected =
before,=0A=
				//we fake the drag stop of the sortable, but make sure it doesn't =
remove the helper by using cancelHelperRemoval=0A=
				if (this.instance.isOver) {=0A=
=0A=
					this.instance.isOver =3D 0;=0A=
					this.instance.cancelHelperRemoval =3D true;=0A=
=0A=
					//Prevent reverting on this forced stop=0A=
					this.instance.options.revert =3D false;=0A=
=0A=
					// The out event needs to be triggered independently=0A=
					this.instance._trigger("out", event, =
this.instance._uiHash(this.instance));=0A=
=0A=
					this.instance._mouseStop(event, true);=0A=
					this.instance.options.helper =3D this.instance.options._helper;=0A=
=0A=
					//Now we remove our currentItem, the list group clone again, and =
the placeholder, and animate the helper back to it's original size=0A=
					this.instance.currentItem.remove();=0A=
					if (this.instance.placeholder) {=0A=
						this.instance.placeholder.remove();=0A=
					}=0A=
=0A=
					inst._trigger("fromSortable", event);=0A=
					inst.dropped =3D false; //draggable revert needs that=0A=
				}=0A=
=0A=
			}=0A=
=0A=
		});=0A=
=0A=
	}=0A=
});=0A=
=0A=
$.ui.plugin.add("draggable", "cursor", {=0A=
	start: function( event, ui, instance ) {=0A=
		var t =3D $( "body" ),=0A=
			o =3D instance.options;=0A=
=0A=
		if (t.css("cursor")) {=0A=
			o._cursor =3D t.css("cursor");=0A=
		}=0A=
		t.css("cursor", o.cursor);=0A=
	},=0A=
	stop: function( event, ui, instance ) {=0A=
		var o =3D instance.options;=0A=
		if (o._cursor) {=0A=
			$("body").css("cursor", o._cursor);=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
$.ui.plugin.add("draggable", "opacity", {=0A=
	start: function( event, ui, instance ) {=0A=
		var t =3D $( ui.helper ),=0A=
			o =3D instance.options;=0A=
		if (t.css("opacity")) {=0A=
			o._opacity =3D t.css("opacity");=0A=
		}=0A=
		t.css("opacity", o.opacity);=0A=
	},=0A=
	stop: function( event, ui, instance ) {=0A=
		var o =3D instance.options;=0A=
		if (o._opacity) {=0A=
			$(ui.helper).css("opacity", o._opacity);=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
$.ui.plugin.add("draggable", "scroll", {=0A=
	start: function( event, ui, i ) {=0A=
		if ( !i.scrollParentNotHidden ) {=0A=
			i.scrollParentNotHidden =3D i.helper.scrollParent( false );=0A=
		}=0A=
=0A=
		if ( i.scrollParentNotHidden[ 0 ] !=3D=3D i.document[ 0 ] && =
i.scrollParentNotHidden[ 0 ].tagName !=3D=3D "HTML" ) {=0A=
			i.overflowOffset =3D i.scrollParentNotHidden.offset();=0A=
		}=0A=
	},=0A=
	drag: function( event, ui, i  ) {=0A=
=0A=
		var o =3D i.options,=0A=
			scrolled =3D false,=0A=
			scrollParent =3D i.scrollParentNotHidden[ 0 ],=0A=
			document =3D i.document[ 0 ];=0A=
=0A=
		if ( scrollParent !=3D=3D document && scrollParent.tagName !=3D=3D =
"HTML" ) {=0A=
			if ( !o.axis || o.axis !=3D=3D "x" ) {=0A=
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - =
event.pageY < o.scrollSensitivity ) {=0A=
					scrollParent.scrollTop =3D scrolled =3D scrollParent.scrollTop + =
o.scrollSpeed;=0A=
				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity =
) {=0A=
					scrollParent.scrollTop =3D scrolled =3D scrollParent.scrollTop - =
o.scrollSpeed;=0A=
				}=0A=
			}=0A=
=0A=
			if ( !o.axis || o.axis !=3D=3D "y" ) {=0A=
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - =
event.pageX < o.scrollSensitivity ) {=0A=
					scrollParent.scrollLeft =3D scrolled =3D scrollParent.scrollLeft + =
o.scrollSpeed;=0A=
				} else if ( event.pageX - i.overflowOffset.left < =
o.scrollSensitivity ) {=0A=
					scrollParent.scrollLeft =3D scrolled =3D scrollParent.scrollLeft - =
o.scrollSpeed;=0A=
				}=0A=
			}=0A=
=0A=
		} else {=0A=
=0A=
			if (!o.axis || o.axis !=3D=3D "x") {=0A=
				if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {=0A=
					scrolled =3D $(document).scrollTop($(document).scrollTop() - =
o.scrollSpeed);=0A=
				} else if ($(window).height() - (event.pageY - =
$(document).scrollTop()) < o.scrollSensitivity) {=0A=
					scrolled =3D $(document).scrollTop($(document).scrollTop() + =
o.scrollSpeed);=0A=
				}=0A=
			}=0A=
=0A=
			if (!o.axis || o.axis !=3D=3D "y") {=0A=
				if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {=0A=
					scrolled =3D $(document).scrollLeft($(document).scrollLeft() - =
o.scrollSpeed);=0A=
				} else if ($(window).width() - (event.pageX - =
$(document).scrollLeft()) < o.scrollSensitivity) {=0A=
					scrolled =3D $(document).scrollLeft($(document).scrollLeft() + =
o.scrollSpeed);=0A=
				}=0A=
			}=0A=
=0A=
		}=0A=
=0A=
		if (scrolled !=3D=3D false && $.ui.ddmanager && !o.dropBehaviour) {=0A=
			$.ui.ddmanager.prepareOffsets(i, event);=0A=
		}=0A=
=0A=
	}=0A=
});=0A=
=0A=
$.ui.plugin.add("draggable", "snap", {=0A=
	start: function( event, ui, i ) {=0A=
=0A=
		var o =3D i.options;=0A=
=0A=
		i.snapElements =3D [];=0A=
=0A=
		$(o.snap.constructor !=3D=3D String ? ( o.snap.items || =
":data(ui-draggable)" ) : o.snap).each(function() {=0A=
			var $t =3D $(this),=0A=
				$o =3D $t.offset();=0A=
			if (this !=3D=3D i.element[0]) {=0A=
				i.snapElements.push({=0A=
					item: this,=0A=
					width: $t.outerWidth(), height: $t.outerHeight(),=0A=
					top: $o.top, left: $o.left=0A=
				});=0A=
			}=0A=
		});=0A=
=0A=
	},=0A=
	drag: function( event, ui, inst ) {=0A=
=0A=
		var ts, bs, ls, rs, l, r, t, b, i, first,=0A=
			o =3D inst.options,=0A=
			d =3D o.snapTolerance,=0A=
			x1 =3D ui.offset.left, x2 =3D x1 + inst.helperProportions.width,=0A=
			y1 =3D ui.offset.top, y2 =3D y1 + inst.helperProportions.height;=0A=
=0A=
		for (i =3D inst.snapElements.length - 1; i >=3D 0; i--){=0A=
=0A=
			l =3D inst.snapElements[i].left;=0A=
			r =3D l + inst.snapElements[i].width;=0A=
			t =3D inst.snapElements[i].top;=0A=
			b =3D t + inst.snapElements[i].height;=0A=
=0A=
			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || =
!$.contains( inst.snapElements[ i ].item.ownerDocument, =
inst.snapElements[ i ].item ) ) {=0A=
				if (inst.snapElements[i].snapping) {=0A=
					(inst.options.snap.release && =
inst.options.snap.release.call(inst.element, event, =
$.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));=0A=
				}=0A=
				inst.snapElements[i].snapping =3D false;=0A=
				continue;=0A=
			}=0A=
=0A=
			if (o.snapMode !=3D=3D "inner") {=0A=
				ts =3D Math.abs(t - y2) <=3D d;=0A=
				bs =3D Math.abs(b - y1) <=3D d;=0A=
				ls =3D Math.abs(l - x2) <=3D d;=0A=
				rs =3D Math.abs(r - x1) <=3D d;=0A=
				if (ts) {=0A=
					ui.position.top =3D inst._convertPositionTo("relative", { top: t - =
inst.helperProportions.height, left: 0 }).top - inst.margins.top;=0A=
				}=0A=
				if (bs) {=0A=
					ui.position.top =3D inst._convertPositionTo("relative", { top: b, =
left: 0 }).top - inst.margins.top;=0A=
				}=0A=
				if (ls) {=0A=
					ui.position.left =3D inst._convertPositionTo("relative", { top: 0, =
left: l - inst.helperProportions.width }).left - inst.margins.left;=0A=
				}=0A=
				if (rs) {=0A=
					ui.position.left =3D inst._convertPositionTo("relative", { top: 0, =
left: r }).left - inst.margins.left;=0A=
				}=0A=
			}=0A=
=0A=
			first =3D (ts || bs || ls || rs);=0A=
=0A=
			if (o.snapMode !=3D=3D "outer") {=0A=
				ts =3D Math.abs(t - y1) <=3D d;=0A=
				bs =3D Math.abs(b - y2) <=3D d;=0A=
				ls =3D Math.abs(l - x1) <=3D d;=0A=
				rs =3D Math.abs(r - x2) <=3D d;=0A=
				if (ts) {=0A=
					ui.position.top =3D inst._convertPositionTo("relative", { top: t, =
left: 0 }).top - inst.margins.top;=0A=
				}=0A=
				if (bs) {=0A=
					ui.position.top =3D inst._convertPositionTo("relative", { top: b - =
inst.helperProportions.height, left: 0 }).top - inst.margins.top;=0A=
				}=0A=
				if (ls) {=0A=
					ui.position.left =3D inst._convertPositionTo("relative", { top: 0, =
left: l }).left - inst.margins.left;=0A=
				}=0A=
				if (rs) {=0A=
					ui.position.left =3D inst._convertPositionTo("relative", { top: 0, =
left: r - inst.helperProportions.width }).left - inst.margins.left;=0A=
				}=0A=
			}=0A=
=0A=
			if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || =
first)) {=0A=
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, =
event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item =
})));=0A=
			}=0A=
			inst.snapElements[i].snapping =3D (ts || bs || ls || rs || first);=0A=
=0A=
		}=0A=
=0A=
	}=0A=
});=0A=
=0A=
$.ui.plugin.add("draggable", "stack", {=0A=
	start: function( event, ui, instance ) {=0A=
		var min,=0A=
			o =3D instance.options,=0A=
			group =3D $.makeArray($(o.stack)).sort(function(a, b) {=0A=
				return (parseInt($(a).css("zIndex"), 10) || 0) - =
(parseInt($(b).css("zIndex"), 10) || 0);=0A=
			});=0A=
=0A=
		if (!group.length) { return; }=0A=
=0A=
		min =3D parseInt($(group[0]).css("zIndex"), 10) || 0;=0A=
		$(group).each(function(i) {=0A=
			$(this).css("zIndex", min + i);=0A=
		});=0A=
		this.css("zIndex", (min + group.length));=0A=
	}=0A=
});=0A=
=0A=
$.ui.plugin.add("draggable", "zIndex", {=0A=
	start: function( event, ui, instance ) {=0A=
		var t =3D $( ui.helper ),=0A=
			o =3D instance.options;=0A=
=0A=
		if (t.css("zIndex")) {=0A=
			o._zIndex =3D t.css("zIndex");=0A=
		}=0A=
		t.css("zIndex", o.zIndex);=0A=
	},=0A=
	stop: function( event, ui, instance ) {=0A=
		var o =3D instance.options;=0A=
=0A=
		if (o._zIndex) {=0A=
			$(ui.helper).css("zIndex", o._zIndex);=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
var draggable =3D $.ui.draggable;=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Droppable 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/droppable/=0A=
 */=0A=
=0A=
=0A=
$.widget( "ui.droppable", {=0A=
	version: "1.11.1",=0A=
	widgetEventPrefix: "drop",=0A=
	options: {=0A=
		accept: "*",=0A=
		activeClass: false,=0A=
		addClasses: true,=0A=
		greedy: false,=0A=
		hoverClass: false,=0A=
		scope: "default",=0A=
		tolerance: "intersect",=0A=
=0A=
		// callbacks=0A=
		activate: null,=0A=
		deactivate: null,=0A=
		drop: null,=0A=
		out: null,=0A=
		over: null=0A=
	},=0A=
	_create: function() {=0A=
=0A=
		var proportions,=0A=
			o =3D this.options,=0A=
			accept =3D o.accept;=0A=
=0A=
		this.isover =3D false;=0A=
		this.isout =3D true;=0A=
=0A=
		this.accept =3D $.isFunction( accept ) ? accept : function( d ) {=0A=
			return d.is( accept );=0A=
		};=0A=
=0A=
		this.proportions =3D function( /* valueToWrite */ ) {=0A=
			if ( arguments.length ) {=0A=
				// Store the droppable's proportions=0A=
				proportions =3D arguments[ 0 ];=0A=
			} else {=0A=
				// Retrieve or derive the droppable's proportions=0A=
				return proportions ?=0A=
					proportions :=0A=
					proportions =3D {=0A=
						width: this.element[ 0 ].offsetWidth,=0A=
						height: this.element[ 0 ].offsetHeight=0A=
					};=0A=
			}=0A=
		};=0A=
=0A=
		this._addToManager( o.scope );=0A=
=0A=
		o.addClasses && this.element.addClass( "ui-droppable" );=0A=
=0A=
	},=0A=
=0A=
	_addToManager: function( scope ) {=0A=
		// Add the reference and positions to the manager=0A=
		$.ui.ddmanager.droppables[ scope ] =3D $.ui.ddmanager.droppables[ =
scope ] || [];=0A=
		$.ui.ddmanager.droppables[ scope ].push( this );=0A=
	},=0A=
=0A=
	_splice: function( drop ) {=0A=
		var i =3D 0;=0A=
		for ( ; i < drop.length; i++ ) {=0A=
			if ( drop[ i ] =3D=3D=3D this ) {=0A=
				drop.splice( i, 1 );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		var drop =3D $.ui.ddmanager.droppables[ this.options.scope ];=0A=
=0A=
		this._splice( drop );=0A=
=0A=
		this.element.removeClass( "ui-droppable ui-droppable-disabled" );=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
=0A=
		if ( key =3D=3D=3D "accept" ) {=0A=
			this.accept =3D $.isFunction( value ) ? value : function( d ) {=0A=
				return d.is( value );=0A=
			};=0A=
		} else if ( key =3D=3D=3D "scope" ) {=0A=
			var drop =3D $.ui.ddmanager.droppables[ this.options.scope ];=0A=
=0A=
			this._splice( drop );=0A=
			this._addToManager( value );=0A=
		}=0A=
=0A=
		this._super( key, value );=0A=
	},=0A=
=0A=
	_activate: function( event ) {=0A=
		var draggable =3D $.ui.ddmanager.current;=0A=
		if ( this.options.activeClass ) {=0A=
			this.element.addClass( this.options.activeClass );=0A=
		}=0A=
		if ( draggable ){=0A=
			this._trigger( "activate", event, this.ui( draggable ) );=0A=
		}=0A=
	},=0A=
=0A=
	_deactivate: function( event ) {=0A=
		var draggable =3D $.ui.ddmanager.current;=0A=
		if ( this.options.activeClass ) {=0A=
			this.element.removeClass( this.options.activeClass );=0A=
		}=0A=
		if ( draggable ){=0A=
			this._trigger( "deactivate", event, this.ui( draggable ) );=0A=
		}=0A=
	},=0A=
=0A=
	_over: function( event ) {=0A=
=0A=
		var draggable =3D $.ui.ddmanager.current;=0A=
=0A=
		// Bail if draggable and droppable are same element=0A=
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] =
=3D=3D=3D this.element[ 0 ] ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || =
draggable.element ) ) ) {=0A=
			if ( this.options.hoverClass ) {=0A=
				this.element.addClass( this.options.hoverClass );=0A=
			}=0A=
			this._trigger( "over", event, this.ui( draggable ) );=0A=
		}=0A=
=0A=
	},=0A=
=0A=
	_out: function( event ) {=0A=
=0A=
		var draggable =3D $.ui.ddmanager.current;=0A=
=0A=
		// Bail if draggable and droppable are same element=0A=
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] =
=3D=3D=3D this.element[ 0 ] ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || =
draggable.element ) ) ) {=0A=
			if ( this.options.hoverClass ) {=0A=
				this.element.removeClass( this.options.hoverClass );=0A=
			}=0A=
			this._trigger( "out", event, this.ui( draggable ) );=0A=
		}=0A=
=0A=
	},=0A=
=0A=
	_drop: function( event, custom ) {=0A=
=0A=
		var draggable =3D custom || $.ui.ddmanager.current,=0A=
			childrenIntersection =3D false;=0A=
=0A=
		// Bail if draggable and droppable are same element=0A=
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] =
=3D=3D=3D this.element[ 0 ] ) {=0A=
			return false;=0A=
		}=0A=
=0A=
		this.element.find( ":data(ui-droppable)" ).not( =
".ui-draggable-dragging" ).each(function() {=0A=
			var inst =3D $( this ).droppable( "instance" );=0A=
			if (=0A=
				inst.options.greedy &&=0A=
				!inst.options.disabled &&=0A=
				inst.options.scope =3D=3D=3D draggable.options.scope &&=0A=
				inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || =
draggable.element ) ) &&=0A=
				$.ui.intersect( draggable, $.extend( inst, { offset: =
inst.element.offset() } ), inst.options.tolerance, event )=0A=
			) { childrenIntersection =3D true; return false; }=0A=
		});=0A=
		if ( childrenIntersection ) {=0A=
			return false;=0A=
		}=0A=
=0A=
		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || =
draggable.element ) ) ) {=0A=
			if ( this.options.activeClass ) {=0A=
				this.element.removeClass( this.options.activeClass );=0A=
			}=0A=
			if ( this.options.hoverClass ) {=0A=
				this.element.removeClass( this.options.hoverClass );=0A=
			}=0A=
			this._trigger( "drop", event, this.ui( draggable ) );=0A=
			return this.element;=0A=
		}=0A=
=0A=
		return false;=0A=
=0A=
	},=0A=
=0A=
	ui: function( c ) {=0A=
		return {=0A=
			draggable: ( c.currentItem || c.element ),=0A=
			helper: c.helper,=0A=
			position: c.position,=0A=
			offset: c.positionAbs=0A=
		};=0A=
	}=0A=
=0A=
});=0A=
=0A=
$.ui.intersect =3D (function() {=0A=
	function isOverAxis( x, reference, size ) {=0A=
		return ( x >=3D reference ) && ( x < ( reference + size ) );=0A=
	}=0A=
=0A=
	return function( draggable, droppable, toleranceMode, event ) {=0A=
=0A=
		if ( !droppable.offset ) {=0A=
			return false;=0A=
		}=0A=
=0A=
		var x1 =3D ( draggable.positionAbs || draggable.position.absolute =
).left,=0A=
			y1 =3D ( draggable.positionAbs || draggable.position.absolute ).top,=0A=
			x2 =3D x1 + draggable.helperProportions.width,=0A=
			y2 =3D y1 + draggable.helperProportions.height,=0A=
			l =3D droppable.offset.left,=0A=
			t =3D droppable.offset.top,=0A=
			r =3D l + droppable.proportions().width,=0A=
			b =3D t + droppable.proportions().height;=0A=
=0A=
		switch ( toleranceMode ) {=0A=
		case "fit":=0A=
			return ( l <=3D x1 && x2 <=3D r && t <=3D y1 && y2 <=3D b );=0A=
		case "intersect":=0A=
			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // =
Right Half=0A=
				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half=0A=
				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half=0A=
				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half=0A=
		case "pointer":=0A=
			return isOverAxis( event.pageY, t, droppable.proportions().height ) =
&& isOverAxis( event.pageX, l, droppable.proportions().width );=0A=
		case "touch":=0A=
			return (=0A=
				( y1 >=3D t && y1 <=3D b ) || // Top edge touching=0A=
				( y2 >=3D t && y2 <=3D b ) || // Bottom edge touching=0A=
				( y1 < t && y2 > b ) // Surrounded vertically=0A=
			) && (=0A=
				( x1 >=3D l && x1 <=3D r ) || // Left edge touching=0A=
				( x2 >=3D l && x2 <=3D r ) || // Right edge touching=0A=
				( x1 < l && x2 > r ) // Surrounded horizontally=0A=
			);=0A=
		default:=0A=
			return false;=0A=
		}=0A=
	};=0A=
})();=0A=
=0A=
/*=0A=
	This manager tracks offsets of draggables and droppables=0A=
*/=0A=
$.ui.ddmanager =3D {=0A=
	current: null,=0A=
	droppables: { "default": [] },=0A=
	prepareOffsets: function( t, event ) {=0A=
=0A=
		var i, j,=0A=
			m =3D $.ui.ddmanager.droppables[ t.options.scope ] || [],=0A=
			type =3D event ? event.type : null, // workaround for #2317=0A=
			list =3D ( t.currentItem || t.element ).find( ":data(ui-droppable)" =
).addBack();=0A=
=0A=
		droppablesLoop: for ( i =3D 0; i < m.length; i++ ) {=0A=
=0A=
			// No disabled and non-accepted=0A=
			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i =
].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {=0A=
				continue;=0A=
			}=0A=
=0A=
			// Filter out elements in the current dragged item=0A=
			for ( j =3D 0; j < list.length; j++ ) {=0A=
				if ( list[ j ] =3D=3D=3D m[ i ].element[ 0 ] ) {=0A=
					m[ i ].proportions().height =3D 0;=0A=
					continue droppablesLoop;=0A=
				}=0A=
			}=0A=
=0A=
			m[ i ].visible =3D m[ i ].element.css( "display" ) !=3D=3D "none";=0A=
			if ( !m[ i ].visible ) {=0A=
				continue;=0A=
			}=0A=
=0A=
			// Activate the droppable if used directly from draggables=0A=
			if ( type =3D=3D=3D "mousedown" ) {=0A=
				m[ i ]._activate.call( m[ i ], event );=0A=
			}=0A=
=0A=
			m[ i ].offset =3D m[ i ].element.offset();=0A=
			m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: =
m[ i ].element[ 0 ].offsetHeight });=0A=
=0A=
		}=0A=
=0A=
	},=0A=
	drop: function( draggable, event ) {=0A=
=0A=
		var dropped =3D false;=0A=
		// Create a copy of the droppables in case the list changes during the =
drop (#9116)=0A=
		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] =
).slice(), function() {=0A=
=0A=
			if ( !this.options ) {=0A=
				return;=0A=
			}=0A=
			if ( !this.options.disabled && this.visible && $.ui.intersect( =
draggable, this, this.options.tolerance, event ) ) {=0A=
				dropped =3D this._drop.call( this, event ) || dropped;=0A=
			}=0A=
=0A=
			if ( !this.options.disabled && this.visible && this.accept.call( =
this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {=0A=
				this.isout =3D true;=0A=
				this.isover =3D false;=0A=
				this._deactivate.call( this, event );=0A=
			}=0A=
=0A=
		});=0A=
		return dropped;=0A=
=0A=
	},=0A=
	dragStart: function( draggable, event ) {=0A=
		// Listen for scrolling so that if the dragging causes scrolling the =
position of the droppables can be recalculated (see #5003)=0A=
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", =
function() {=0A=
			if ( !draggable.options.refreshPositions ) {=0A=
				$.ui.ddmanager.prepareOffsets( draggable, event );=0A=
			}=0A=
		});=0A=
	},=0A=
	drag: function( draggable, event ) {=0A=
=0A=
		// If you have a highly dynamic page, you might try this option. It =
renders positions every time you move the mouse.=0A=
		if ( draggable.options.refreshPositions ) {=0A=
			$.ui.ddmanager.prepareOffsets( draggable, event );=0A=
		}=0A=
=0A=
		// Run through all droppables and check their positions based on =
specific tolerance options=0A=
		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], =
function() {=0A=
=0A=
			if ( this.options.disabled || this.greedyChild || !this.visible ) {=0A=
				return;=0A=
			}=0A=
=0A=
			var parentInstance, scope, parent,=0A=
				intersects =3D $.ui.intersect( draggable, this, =
this.options.tolerance, event ),=0A=
				c =3D !intersects && this.isover ? "isout" : ( intersects && =
!this.isover ? "isover" : null );=0A=
			if ( !c ) {=0A=
				return;=0A=
			}=0A=
=0A=
			if ( this.options.greedy ) {=0A=
				// find droppable parents with same scope=0A=
				scope =3D this.options.scope;=0A=
				parent =3D this.element.parents( ":data(ui-droppable)" =
).filter(function() {=0A=
					return $( this ).droppable( "instance" ).options.scope =3D=3D=3D =
scope;=0A=
				});=0A=
=0A=
				if ( parent.length ) {=0A=
					parentInstance =3D $( parent[ 0 ] ).droppable( "instance" );=0A=
					parentInstance.greedyChild =3D ( c =3D=3D=3D "isover" );=0A=
				}=0A=
			}=0A=
=0A=
			// we just moved into a greedy child=0A=
			if ( parentInstance && c =3D=3D=3D "isover" ) {=0A=
				parentInstance.isover =3D false;=0A=
				parentInstance.isout =3D true;=0A=
				parentInstance._out.call( parentInstance, event );=0A=
			}=0A=
=0A=
			this[ c ] =3D true;=0A=
			this[c =3D=3D=3D "isout" ? "isover" : "isout"] =3D false;=0A=
			this[c =3D=3D=3D "isover" ? "_over" : "_out"].call( this, event );=0A=
=0A=
			// we just moved out of a greedy child=0A=
			if ( parentInstance && c =3D=3D=3D "isout" ) {=0A=
				parentInstance.isout =3D false;=0A=
				parentInstance.isover =3D true;=0A=
				parentInstance._over.call( parentInstance, event );=0A=
			}=0A=
		});=0A=
=0A=
	},=0A=
	dragStop: function( draggable, event ) {=0A=
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );=0A=
		// Call prepareOffsets one final time since IE does not fire return =
scroll events when overflow was caused by drag (see #5003)=0A=
		if ( !draggable.options.refreshPositions ) {=0A=
			$.ui.ddmanager.prepareOffsets( draggable, event );=0A=
		}=0A=
	}=0A=
};=0A=
=0A=
var droppable =3D $.ui.droppable;=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Resizable 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/resizable/=0A=
 */=0A=
=0A=
=0A=
$.widget("ui.resizable", $.ui.mouse, {=0A=
	version: "1.11.1",=0A=
	widgetEventPrefix: "resize",=0A=
	options: {=0A=
		alsoResize: false,=0A=
		animate: false,=0A=
		animateDuration: "slow",=0A=
		animateEasing: "swing",=0A=
		aspectRatio: false,=0A=
		autoHide: false,=0A=
		containment: false,=0A=
		ghost: false,=0A=
		grid: false,=0A=
		handles: "e,s,se",=0A=
		helper: false,=0A=
		maxHeight: null,=0A=
		maxWidth: null,=0A=
		minHeight: 10,=0A=
		minWidth: 10,=0A=
		// See #7960=0A=
		zIndex: 90,=0A=
=0A=
		// callbacks=0A=
		resize: null,=0A=
		start: null,=0A=
		stop: null=0A=
	},=0A=
=0A=
	_num: function( value ) {=0A=
		return parseInt( value, 10 ) || 0;=0A=
	},=0A=
=0A=
	_isNumber: function( value ) {=0A=
		return !isNaN( parseInt( value, 10 ) );=0A=
	},=0A=
=0A=
	_hasScroll: function( el, a ) {=0A=
=0A=
		if ( $( el ).css( "overflow" ) =3D=3D=3D "hidden") {=0A=
			return false;=0A=
		}=0A=
=0A=
		var scroll =3D ( a && a =3D=3D=3D "left" ) ? "scrollLeft" : =
"scrollTop",=0A=
			has =3D false;=0A=
=0A=
		if ( el[ scroll ] > 0 ) {=0A=
			return true;=0A=
		}=0A=
=0A=
		// TODO: determine which cases actually cause this to happen=0A=
		// if the element doesn't have the scroll set, see if it's possible to=0A=
		// set the scroll=0A=
		el[ scroll ] =3D 1;=0A=
		has =3D ( el[ scroll ] > 0 );=0A=
		el[ scroll ] =3D 0;=0A=
		return has;=0A=
	},=0A=
=0A=
	_create: function() {=0A=
=0A=
		var n, i, handle, axis, hname,=0A=
			that =3D this,=0A=
			o =3D this.options;=0A=
		this.element.addClass("ui-resizable");=0A=
=0A=
		$.extend(this, {=0A=
			_aspectRatio: !!(o.aspectRatio),=0A=
			aspectRatio: o.aspectRatio,=0A=
			originalElement: this.element,=0A=
			_proportionallyResizeElements: [],=0A=
			_helper: o.helper || o.ghost || o.animate ? o.helper || =
"ui-resizable-helper" : null=0A=
		});=0A=
=0A=
		// Wrap the element if it cannot hold child nodes=0A=
		if =
(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/=
i)) {=0A=
=0A=
			this.element.wrap(=0A=
				$("<div class=3D'ui-wrapper' style=3D'overflow: =
hidden;'></div>").css({=0A=
					position: this.element.css("position"),=0A=
					width: this.element.outerWidth(),=0A=
					height: this.element.outerHeight(),=0A=
					top: this.element.css("top"),=0A=
					left: this.element.css("left")=0A=
				})=0A=
			);=0A=
=0A=
			this.element =3D this.element.parent().data(=0A=
				"ui-resizable", this.element.resizable( "instance" )=0A=
			);=0A=
=0A=
			this.elementIsWrapper =3D true;=0A=
=0A=
			this.element.css({=0A=
				marginLeft: this.originalElement.css("marginLeft"),=0A=
				marginTop: this.originalElement.css("marginTop"),=0A=
				marginRight: this.originalElement.css("marginRight"),=0A=
				marginBottom: this.originalElement.css("marginBottom")=0A=
			});=0A=
			this.originalElement.css({=0A=
				marginLeft: 0,=0A=
				marginTop: 0,=0A=
				marginRight: 0,=0A=
				marginBottom: 0=0A=
			});=0A=
			// support: Safari=0A=
			// Prevent Safari textarea resize=0A=
			this.originalResizeStyle =3D this.originalElement.css("resize");=0A=
			this.originalElement.css("resize", "none");=0A=
=0A=
			this._proportionallyResizeElements.push( this.originalElement.css({=0A=
				position: "static",=0A=
				zoom: 1,=0A=
				display: "block"=0A=
			}) );=0A=
=0A=
			// support: IE9=0A=
			// avoid IE jump (hard set the margin)=0A=
			this.originalElement.css({ margin: this.originalElement.css("margin") =
});=0A=
=0A=
			this._proportionallyResize();=0A=
		}=0A=
=0A=
		this.handles =3D o.handles ||=0A=
			( !$(".ui-resizable-handle", this.element).length ?=0A=
				"e,s,se" : {=0A=
					n: ".ui-resizable-n",=0A=
					e: ".ui-resizable-e",=0A=
					s: ".ui-resizable-s",=0A=
					w: ".ui-resizable-w",=0A=
					se: ".ui-resizable-se",=0A=
					sw: ".ui-resizable-sw",=0A=
					ne: ".ui-resizable-ne",=0A=
					nw: ".ui-resizable-nw"=0A=
				} );=0A=
=0A=
		if (this.handles.constructor =3D=3D=3D String) {=0A=
=0A=
			if ( this.handles =3D=3D=3D "all") {=0A=
				this.handles =3D "n,e,s,w,se,sw,ne,nw";=0A=
			}=0A=
=0A=
			n =3D this.handles.split(",");=0A=
			this.handles =3D {};=0A=
=0A=
			for (i =3D 0; i < n.length; i++) {=0A=
=0A=
				handle =3D $.trim(n[i]);=0A=
				hname =3D "ui-resizable-" + handle;=0A=
				axis =3D $("<div class=3D'ui-resizable-handle " + hname + =
"'></div>");=0A=
=0A=
				axis.css({ zIndex: o.zIndex });=0A=
=0A=
				// TODO : What's going on here?=0A=
				if ("se" =3D=3D=3D handle) {=0A=
					axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");=0A=
				}=0A=
=0A=
				this.handles[handle] =3D ".ui-resizable-" + handle;=0A=
				this.element.append(axis);=0A=
			}=0A=
=0A=
		}=0A=
=0A=
		this._renderAxis =3D function(target) {=0A=
=0A=
			var i, axis, padPos, padWrapper;=0A=
=0A=
			target =3D target || this.element;=0A=
=0A=
			for (i in this.handles) {=0A=
=0A=
				if (this.handles[i].constructor =3D=3D=3D String) {=0A=
					this.handles[i] =3D this.element.children( this.handles[ i ] =
).first().show();=0A=
				}=0A=
=0A=
				if (this.elementIsWrapper && =
this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) =
{=0A=
=0A=
					axis =3D $(this.handles[i], this.element);=0A=
=0A=
					padWrapper =3D /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : =
axis.outerWidth();=0A=
=0A=
					padPos =3D [ "padding",=0A=
						/ne|nw|n/.test(i) ? "Top" :=0A=
						/se|sw|s/.test(i) ? "Bottom" :=0A=
						/^e$/.test(i) ? "Right" : "Left" ].join("");=0A=
=0A=
					target.css(padPos, padWrapper);=0A=
=0A=
					this._proportionallyResize();=0A=
=0A=
				}=0A=
=0A=
				// TODO: What's that good for? There's not anything to be executed =
left=0A=
				if (!$(this.handles[i]).length) {=0A=
					continue;=0A=
				}=0A=
			}=0A=
		};=0A=
=0A=
		// TODO: make renderAxis a prototype function=0A=
		this._renderAxis(this.element);=0A=
=0A=
		this._handles =3D $(".ui-resizable-handle", this.element)=0A=
			.disableSelection();=0A=
=0A=
		this._handles.mouseover(function() {=0A=
			if (!that.resizing) {=0A=
				if (this.className) {=0A=
					axis =3D =
this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);=0A=
				}=0A=
				that.axis =3D axis && axis[1] ? axis[1] : "se";=0A=
			}=0A=
		});=0A=
=0A=
		if (o.autoHide) {=0A=
			this._handles.hide();=0A=
			$(this.element)=0A=
				.addClass("ui-resizable-autohide")=0A=
				.mouseenter(function() {=0A=
					if (o.disabled) {=0A=
						return;=0A=
					}=0A=
					$(this).removeClass("ui-resizable-autohide");=0A=
					that._handles.show();=0A=
				})=0A=
				.mouseleave(function() {=0A=
					if (o.disabled) {=0A=
						return;=0A=
					}=0A=
					if (!that.resizing) {=0A=
						$(this).addClass("ui-resizable-autohide");=0A=
						that._handles.hide();=0A=
					}=0A=
				});=0A=
		}=0A=
=0A=
		this._mouseInit();=0A=
=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
=0A=
		this._mouseDestroy();=0A=
=0A=
		var wrapper,=0A=
			_destroy =3D function(exp) {=0A=
				$(exp)=0A=
					.removeClass("ui-resizable ui-resizable-disabled =
ui-resizable-resizing")=0A=
					.removeData("resizable")=0A=
					.removeData("ui-resizable")=0A=
					.unbind(".resizable")=0A=
					.find(".ui-resizable-handle")=0A=
						.remove();=0A=
			};=0A=
=0A=
		// TODO: Unwrap at same DOM position=0A=
		if (this.elementIsWrapper) {=0A=
			_destroy(this.element);=0A=
			wrapper =3D this.element;=0A=
			this.originalElement.css({=0A=
				position: wrapper.css("position"),=0A=
				width: wrapper.outerWidth(),=0A=
				height: wrapper.outerHeight(),=0A=
				top: wrapper.css("top"),=0A=
				left: wrapper.css("left")=0A=
			}).insertAfter( wrapper );=0A=
			wrapper.remove();=0A=
		}=0A=
=0A=
		this.originalElement.css("resize", this.originalResizeStyle);=0A=
		_destroy(this.originalElement);=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	_mouseCapture: function(event) {=0A=
		var i, handle,=0A=
			capture =3D false;=0A=
=0A=
		for (i in this.handles) {=0A=
			handle =3D $(this.handles[i])[0];=0A=
			if (handle =3D=3D=3D event.target || $.contains(handle, =
event.target)) {=0A=
				capture =3D true;=0A=
			}=0A=
		}=0A=
=0A=
		return !this.options.disabled && capture;=0A=
	},=0A=
=0A=
	_mouseStart: function(event) {=0A=
=0A=
		var curleft, curtop, cursor,=0A=
			o =3D this.options,=0A=
			el =3D this.element;=0A=
=0A=
		this.resizing =3D true;=0A=
=0A=
		this._renderProxy();=0A=
=0A=
		curleft =3D this._num(this.helper.css("left"));=0A=
		curtop =3D this._num(this.helper.css("top"));=0A=
=0A=
		if (o.containment) {=0A=
			curleft +=3D $(o.containment).scrollLeft() || 0;=0A=
			curtop +=3D $(o.containment).scrollTop() || 0;=0A=
		}=0A=
=0A=
		this.offset =3D this.helper.offset();=0A=
		this.position =3D { left: curleft, top: curtop };=0A=
=0A=
		this.size =3D this._helper ? {=0A=
				width: this.helper.width(),=0A=
				height: this.helper.height()=0A=
			} : {=0A=
				width: el.width(),=0A=
				height: el.height()=0A=
			};=0A=
=0A=
		this.originalSize =3D this._helper ? {=0A=
				width: el.outerWidth(),=0A=
				height: el.outerHeight()=0A=
			} : {=0A=
				width: el.width(),=0A=
				height: el.height()=0A=
			};=0A=
=0A=
		this.sizeDiff =3D {=0A=
			width: el.outerWidth() - el.width(),=0A=
			height: el.outerHeight() - el.height()=0A=
		};=0A=
=0A=
		this.originalPosition =3D { left: curleft, top: curtop };=0A=
		this.originalMousePosition =3D { left: event.pageX, top: event.pageY };=0A=
=0A=
		this.aspectRatio =3D (typeof o.aspectRatio =3D=3D=3D "number") ?=0A=
			o.aspectRatio :=0A=
			((this.originalSize.width / this.originalSize.height) || 1);=0A=
=0A=
		cursor =3D $(".ui-resizable-" + this.axis).css("cursor");=0A=
		$("body").css("cursor", cursor =3D=3D=3D "auto" ? this.axis + =
"-resize" : cursor);=0A=
=0A=
		el.addClass("ui-resizable-resizing");=0A=
		this._propagate("start", event);=0A=
		return true;=0A=
	},=0A=
=0A=
	_mouseDrag: function(event) {=0A=
=0A=
		var data, props,=0A=
			smp =3D this.originalMousePosition,=0A=
			a =3D this.axis,=0A=
			dx =3D (event.pageX - smp.left) || 0,=0A=
			dy =3D (event.pageY - smp.top) || 0,=0A=
			trigger =3D this._change[a];=0A=
=0A=
		this._updatePrevProperties();=0A=
=0A=
		if (!trigger) {=0A=
			return false;=0A=
		}=0A=
=0A=
		data =3D trigger.apply(this, [ event, dx, dy ]);=0A=
=0A=
		this._updateVirtualBoundaries(event.shiftKey);=0A=
		if (this._aspectRatio || event.shiftKey) {=0A=
			data =3D this._updateRatio(data, event);=0A=
		}=0A=
=0A=
		data =3D this._respectSize(data, event);=0A=
=0A=
		this._updateCache(data);=0A=
=0A=
		this._propagate("resize", event);=0A=
=0A=
		props =3D this._applyChanges();=0A=
=0A=
		if ( !this._helper && this._proportionallyResizeElements.length ) {=0A=
			this._proportionallyResize();=0A=
		}=0A=
=0A=
		if ( !$.isEmptyObject( props ) ) {=0A=
			this._updatePrevProperties();=0A=
			this._trigger( "resize", event, this.ui() );=0A=
			this._applyChanges();=0A=
		}=0A=
=0A=
		return false;=0A=
	},=0A=
=0A=
	_mouseStop: function(event) {=0A=
=0A=
		this.resizing =3D false;=0A=
		var pr, ista, soffseth, soffsetw, s, left, top,=0A=
			o =3D this.options, that =3D this;=0A=
=0A=
		if (this._helper) {=0A=
=0A=
			pr =3D this._proportionallyResizeElements;=0A=
			ista =3D pr.length && (/textarea/i).test(pr[0].nodeName);=0A=
			soffseth =3D ista && this._hasScroll(pr[0], "left") ? 0 : =
that.sizeDiff.height;=0A=
			soffsetw =3D ista ? 0 : that.sizeDiff.width;=0A=
=0A=
			s =3D {=0A=
				width: (that.helper.width()  - soffsetw),=0A=
				height: (that.helper.height() - soffseth)=0A=
			};=0A=
			left =3D (parseInt(that.element.css("left"), 10) +=0A=
				(that.position.left - that.originalPosition.left)) || null;=0A=
			top =3D (parseInt(that.element.css("top"), 10) +=0A=
				(that.position.top - that.originalPosition.top)) || null;=0A=
=0A=
			if (!o.animate) {=0A=
				this.element.css($.extend(s, { top: top, left: left }));=0A=
			}=0A=
=0A=
			that.helper.height(that.size.height);=0A=
			that.helper.width(that.size.width);=0A=
=0A=
			if (this._helper && !o.animate) {=0A=
				this._proportionallyResize();=0A=
			}=0A=
		}=0A=
=0A=
		$("body").css("cursor", "auto");=0A=
=0A=
		this.element.removeClass("ui-resizable-resizing");=0A=
=0A=
		this._propagate("stop", event);=0A=
=0A=
		if (this._helper) {=0A=
			this.helper.remove();=0A=
		}=0A=
=0A=
		return false;=0A=
=0A=
	},=0A=
=0A=
	_updatePrevProperties: function() {=0A=
		this.prevPosition =3D {=0A=
			top: this.position.top,=0A=
			left: this.position.left=0A=
		};=0A=
		this.prevSize =3D {=0A=
			width: this.size.width,=0A=
			height: this.size.height=0A=
		};=0A=
	},=0A=
=0A=
	_applyChanges: function() {=0A=
		var props =3D {};=0A=
=0A=
		if ( this.position.top !=3D=3D this.prevPosition.top ) {=0A=
			props.top =3D this.position.top + "px";=0A=
		}=0A=
		if ( this.position.left !=3D=3D this.prevPosition.left ) {=0A=
			props.left =3D this.position.left + "px";=0A=
		}=0A=
		if ( this.size.width !=3D=3D this.prevSize.width ) {=0A=
			props.width =3D this.size.width + "px";=0A=
		}=0A=
		if ( this.size.height !=3D=3D this.prevSize.height ) {=0A=
			props.height =3D this.size.height + "px";=0A=
		}=0A=
=0A=
		this.helper.css( props );=0A=
=0A=
		return props;=0A=
	},=0A=
=0A=
	_updateVirtualBoundaries: function(forceAspectRatio) {=0A=
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,=0A=
			o =3D this.options;=0A=
=0A=
		b =3D {=0A=
			minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,=0A=
			maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,=0A=
			minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,=0A=
			maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity=0A=
		};=0A=
=0A=
		if (this._aspectRatio || forceAspectRatio) {=0A=
			pMinWidth =3D b.minHeight * this.aspectRatio;=0A=
			pMinHeight =3D b.minWidth / this.aspectRatio;=0A=
			pMaxWidth =3D b.maxHeight * this.aspectRatio;=0A=
			pMaxHeight =3D b.maxWidth / this.aspectRatio;=0A=
=0A=
			if (pMinWidth > b.minWidth) {=0A=
				b.minWidth =3D pMinWidth;=0A=
			}=0A=
			if (pMinHeight > b.minHeight) {=0A=
				b.minHeight =3D pMinHeight;=0A=
			}=0A=
			if (pMaxWidth < b.maxWidth) {=0A=
				b.maxWidth =3D pMaxWidth;=0A=
			}=0A=
			if (pMaxHeight < b.maxHeight) {=0A=
				b.maxHeight =3D pMaxHeight;=0A=
			}=0A=
		}=0A=
		this._vBoundaries =3D b;=0A=
	},=0A=
=0A=
	_updateCache: function(data) {=0A=
		this.offset =3D this.helper.offset();=0A=
		if (this._isNumber(data.left)) {=0A=
			this.position.left =3D data.left;=0A=
		}=0A=
		if (this._isNumber(data.top)) {=0A=
			this.position.top =3D data.top;=0A=
		}=0A=
		if (this._isNumber(data.height)) {=0A=
			this.size.height =3D data.height;=0A=
		}=0A=
		if (this._isNumber(data.width)) {=0A=
			this.size.width =3D data.width;=0A=
		}=0A=
	},=0A=
=0A=
	_updateRatio: function( data ) {=0A=
=0A=
		var cpos =3D this.position,=0A=
			csize =3D this.size,=0A=
			a =3D this.axis;=0A=
=0A=
		if (this._isNumber(data.height)) {=0A=
			data.width =3D (data.height * this.aspectRatio);=0A=
		} else if (this._isNumber(data.width)) {=0A=
			data.height =3D (data.width / this.aspectRatio);=0A=
		}=0A=
=0A=
		if (a =3D=3D=3D "sw") {=0A=
			data.left =3D cpos.left + (csize.width - data.width);=0A=
			data.top =3D null;=0A=
		}=0A=
		if (a =3D=3D=3D "nw") {=0A=
			data.top =3D cpos.top + (csize.height - data.height);=0A=
			data.left =3D cpos.left + (csize.width - data.width);=0A=
		}=0A=
=0A=
		return data;=0A=
	},=0A=
=0A=
	_respectSize: function( data ) {=0A=
=0A=
		var o =3D this._vBoundaries,=0A=
			a =3D this.axis,=0A=
			ismaxw =3D this._isNumber(data.width) && o.maxWidth && (o.maxWidth < =
data.width),=0A=
			ismaxh =3D this._isNumber(data.height) && o.maxHeight && (o.maxHeight =
< data.height),=0A=
			isminw =3D this._isNumber(data.width) && o.minWidth && (o.minWidth > =
data.width),=0A=
			isminh =3D this._isNumber(data.height) && o.minHeight && (o.minHeight =
> data.height),=0A=
			dw =3D this.originalPosition.left + this.originalSize.width,=0A=
			dh =3D this.position.top + this.size.height,=0A=
			cw =3D /sw|nw|w/.test(a), ch =3D /nw|ne|n/.test(a);=0A=
		if (isminw) {=0A=
			data.width =3D o.minWidth;=0A=
		}=0A=
		if (isminh) {=0A=
			data.height =3D o.minHeight;=0A=
		}=0A=
		if (ismaxw) {=0A=
			data.width =3D o.maxWidth;=0A=
		}=0A=
		if (ismaxh) {=0A=
			data.height =3D o.maxHeight;=0A=
		}=0A=
=0A=
		if (isminw && cw) {=0A=
			data.left =3D dw - o.minWidth;=0A=
		}=0A=
		if (ismaxw && cw) {=0A=
			data.left =3D dw - o.maxWidth;=0A=
		}=0A=
		if (isminh && ch) {=0A=
			data.top =3D dh - o.minHeight;=0A=
		}=0A=
		if (ismaxh && ch) {=0A=
			data.top =3D dh - o.maxHeight;=0A=
		}=0A=
=0A=
		// Fixing jump error on top/left - bug #2330=0A=
		if (!data.width && !data.height && !data.left && data.top) {=0A=
			data.top =3D null;=0A=
		} else if (!data.width && !data.height && !data.top && data.left) {=0A=
			data.left =3D null;=0A=
		}=0A=
=0A=
		return data;=0A=
	},=0A=
=0A=
	_getPaddingPlusBorderDimensions: function( element ) {=0A=
		var i =3D 0,=0A=
			widths =3D [],=0A=
			borders =3D [=0A=
				element.css( "borderTopWidth" ),=0A=
				element.css( "borderRightWidth" ),=0A=
				element.css( "borderBottomWidth" ),=0A=
				element.css( "borderLeftWidth" )=0A=
			],=0A=
			paddings =3D [=0A=
				element.css( "paddingTop" ),=0A=
				element.css( "paddingRight" ),=0A=
				element.css( "paddingBottom" ),=0A=
				element.css( "paddingLeft" )=0A=
			];=0A=
=0A=
		for ( ; i < 4; i++ ) {=0A=
			widths[ i ] =3D ( parseInt( borders[ i ], 10 ) || 0 );=0A=
			widths[ i ] +=3D ( parseInt( paddings[ i ], 10 ) || 0 );=0A=
		}=0A=
=0A=
		return {=0A=
			height: widths[ 0 ] + widths[ 2 ],=0A=
			width: widths[ 1 ] + widths[ 3 ]=0A=
		};=0A=
	},=0A=
=0A=
	_proportionallyResize: function() {=0A=
=0A=
		if (!this._proportionallyResizeElements.length) {=0A=
			return;=0A=
		}=0A=
=0A=
		var prel,=0A=
			i =3D 0,=0A=
			element =3D this.helper || this.element;=0A=
=0A=
		for ( ; i < this._proportionallyResizeElements.length; i++) {=0A=
=0A=
			prel =3D this._proportionallyResizeElements[i];=0A=
=0A=
			// TODO: Seems like a bug to cache this.outerDimensions=0A=
			// considering that we are in a loop.=0A=
			if (!this.outerDimensions) {=0A=
				this.outerDimensions =3D this._getPaddingPlusBorderDimensions( prel =
);=0A=
			}=0A=
=0A=
			prel.css({=0A=
				height: (element.height() - this.outerDimensions.height) || 0,=0A=
				width: (element.width() - this.outerDimensions.width) || 0=0A=
			});=0A=
=0A=
		}=0A=
=0A=
	},=0A=
=0A=
	_renderProxy: function() {=0A=
=0A=
		var el =3D this.element, o =3D this.options;=0A=
		this.elementOffset =3D el.offset();=0A=
=0A=
		if (this._helper) {=0A=
=0A=
			this.helper =3D this.helper || $("<div =
style=3D'overflow:hidden;'></div>");=0A=
=0A=
			this.helper.addClass(this._helper).css({=0A=
				width: this.element.outerWidth() - 1,=0A=
				height: this.element.outerHeight() - 1,=0A=
				position: "absolute",=0A=
				left: this.elementOffset.left + "px",=0A=
				top: this.elementOffset.top + "px",=0A=
				zIndex: ++o.zIndex //TODO: Don't modify option=0A=
			});=0A=
=0A=
			this.helper=0A=
				.appendTo("body")=0A=
				.disableSelection();=0A=
=0A=
		} else {=0A=
			this.helper =3D this.element;=0A=
		}=0A=
=0A=
	},=0A=
=0A=
	_change: {=0A=
		e: function(event, dx) {=0A=
			return { width: this.originalSize.width + dx };=0A=
		},=0A=
		w: function(event, dx) {=0A=
			var cs =3D this.originalSize, sp =3D this.originalPosition;=0A=
			return { left: sp.left + dx, width: cs.width - dx };=0A=
		},=0A=
		n: function(event, dx, dy) {=0A=
			var cs =3D this.originalSize, sp =3D this.originalPosition;=0A=
			return { top: sp.top + dy, height: cs.height - dy };=0A=
		},=0A=
		s: function(event, dx, dy) {=0A=
			return { height: this.originalSize.height + dy };=0A=
		},=0A=
		se: function(event, dx, dy) {=0A=
			return $.extend(this._change.s.apply(this, arguments),=0A=
				this._change.e.apply(this, [ event, dx, dy ]));=0A=
		},=0A=
		sw: function(event, dx, dy) {=0A=
			return $.extend(this._change.s.apply(this, arguments),=0A=
				this._change.w.apply(this, [ event, dx, dy ]));=0A=
		},=0A=
		ne: function(event, dx, dy) {=0A=
			return $.extend(this._change.n.apply(this, arguments),=0A=
				this._change.e.apply(this, [ event, dx, dy ]));=0A=
		},=0A=
		nw: function(event, dx, dy) {=0A=
			return $.extend(this._change.n.apply(this, arguments),=0A=
				this._change.w.apply(this, [ event, dx, dy ]));=0A=
		}=0A=
	},=0A=
=0A=
	_propagate: function(n, event) {=0A=
		$.ui.plugin.call(this, n, [ event, this.ui() ]);=0A=
		(n !=3D=3D "resize" && this._trigger(n, event, this.ui()));=0A=
	},=0A=
=0A=
	plugins: {},=0A=
=0A=
	ui: function() {=0A=
		return {=0A=
			originalElement: this.originalElement,=0A=
			element: this.element,=0A=
			helper: this.helper,=0A=
			position: this.position,=0A=
			size: this.size,=0A=
			originalSize: this.originalSize,=0A=
			originalPosition: this.originalPosition=0A=
		};=0A=
	}=0A=
=0A=
});=0A=
=0A=
/*=0A=
 * Resizable Extensions=0A=
 */=0A=
=0A=
$.ui.plugin.add("resizable", "animate", {=0A=
=0A=
	stop: function( event ) {=0A=
		var that =3D $(this).resizable( "instance" ),=0A=
			o =3D that.options,=0A=
			pr =3D that._proportionallyResizeElements,=0A=
			ista =3D pr.length && (/textarea/i).test(pr[0].nodeName),=0A=
			soffseth =3D ista && that._hasScroll(pr[0], "left") ? 0 : =
that.sizeDiff.height,=0A=
			soffsetw =3D ista ? 0 : that.sizeDiff.width,=0A=
			style =3D { width: (that.size.width - soffsetw), height: =
(that.size.height - soffseth) },=0A=
			left =3D (parseInt(that.element.css("left"), 10) +=0A=
				(that.position.left - that.originalPosition.left)) || null,=0A=
			top =3D (parseInt(that.element.css("top"), 10) +=0A=
				(that.position.top - that.originalPosition.top)) || null;=0A=
=0A=
		that.element.animate(=0A=
			$.extend(style, top && left ? { top: top, left: left } : {}), {=0A=
				duration: o.animateDuration,=0A=
				easing: o.animateEasing,=0A=
				step: function() {=0A=
=0A=
					var data =3D {=0A=
						width: parseInt(that.element.css("width"), 10),=0A=
						height: parseInt(that.element.css("height"), 10),=0A=
						top: parseInt(that.element.css("top"), 10),=0A=
						left: parseInt(that.element.css("left"), 10)=0A=
					};=0A=
=0A=
					if (pr && pr.length) {=0A=
						$(pr[0]).css({ width: data.width, height: data.height });=0A=
					}=0A=
=0A=
					// propagating resize, and updating values for each animation step=0A=
					that._updateCache(data);=0A=
					that._propagate("resize", event);=0A=
=0A=
				}=0A=
			}=0A=
		);=0A=
	}=0A=
=0A=
});=0A=
=0A=
$.ui.plugin.add( "resizable", "containment", {=0A=
=0A=
	start: function() {=0A=
		var element, p, co, ch, cw, width, height,=0A=
			that =3D $( this ).resizable( "instance" ),=0A=
			o =3D that.options,=0A=
			el =3D that.element,=0A=
			oc =3D o.containment,=0A=
			ce =3D ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? =
el.parent().get( 0 ) : oc;=0A=
=0A=
		if ( !ce ) {=0A=
			return;=0A=
		}=0A=
=0A=
		that.containerElement =3D $( ce );=0A=
=0A=
		if ( /document/.test( oc ) || oc =3D=3D=3D document ) {=0A=
			that.containerOffset =3D {=0A=
				left: 0,=0A=
				top: 0=0A=
			};=0A=
			that.containerPosition =3D {=0A=
				left: 0,=0A=
				top: 0=0A=
			};=0A=
=0A=
			that.parentData =3D {=0A=
				element: $( document ),=0A=
				left: 0,=0A=
				top: 0,=0A=
				width: $( document ).width(),=0A=
				height: $( document ).height() || =
document.body.parentNode.scrollHeight=0A=
			};=0A=
		} else {=0A=
			element =3D $( ce );=0A=
			p =3D [];=0A=
			$([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {=0A=
				p[ i ] =3D that._num( element.css( "padding" + name ) );=0A=
			});=0A=
=0A=
			that.containerOffset =3D element.offset();=0A=
			that.containerPosition =3D element.position();=0A=
			that.containerSize =3D {=0A=
				height: ( element.innerHeight() - p[ 3 ] ),=0A=
				width: ( element.innerWidth() - p[ 1 ] )=0A=
			};=0A=
=0A=
			co =3D that.containerOffset;=0A=
			ch =3D that.containerSize.height;=0A=
			cw =3D that.containerSize.width;=0A=
			width =3D ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );=0A=
			height =3D ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;=0A=
=0A=
			that.parentData =3D {=0A=
				element: ce,=0A=
				left: co.left,=0A=
				top: co.top,=0A=
				width: width,=0A=
				height: height=0A=
			};=0A=
		}=0A=
	},=0A=
=0A=
	resize: function( event ) {=0A=
		var woset, hoset, isParent, isOffsetRelative,=0A=
			that =3D $( this ).resizable( "instance" ),=0A=
			o =3D that.options,=0A=
			co =3D that.containerOffset,=0A=
			cp =3D that.position,=0A=
			pRatio =3D that._aspectRatio || event.shiftKey,=0A=
			cop =3D {=0A=
				top: 0,=0A=
				left: 0=0A=
			},=0A=
			ce =3D that.containerElement,=0A=
			continueResize =3D true;=0A=
=0A=
		if ( ce[ 0 ] !=3D=3D document && ( /static/ ).test( ce.css( "position" =
) ) ) {=0A=
			cop =3D co;=0A=
		}=0A=
=0A=
		if ( cp.left < ( that._helper ? co.left : 0 ) ) {=0A=
			that.size.width =3D that.size.width +=0A=
				( that._helper ?=0A=
					( that.position.left - co.left ) :=0A=
					( that.position.left - cop.left ) );=0A=
=0A=
			if ( pRatio ) {=0A=
				that.size.height =3D that.size.width / that.aspectRatio;=0A=
				continueResize =3D false;=0A=
			}=0A=
			that.position.left =3D o.helper ? co.left : 0;=0A=
		}=0A=
=0A=
		if ( cp.top < ( that._helper ? co.top : 0 ) ) {=0A=
			that.size.height =3D that.size.height +=0A=
				( that._helper ?=0A=
					( that.position.top - co.top ) :=0A=
					that.position.top );=0A=
=0A=
			if ( pRatio ) {=0A=
				that.size.width =3D that.size.height * that.aspectRatio;=0A=
				continueResize =3D false;=0A=
			}=0A=
			that.position.top =3D that._helper ? co.top : 0;=0A=
		}=0A=
=0A=
		isParent =3D that.containerElement.get( 0 ) =3D=3D=3D =
that.element.parent().get( 0 );=0A=
		isOffsetRelative =3D /relative|absolute/.test( =
that.containerElement.css( "position" ) );=0A=
=0A=
		if ( isParent && isOffsetRelative ) {=0A=
			that.offset.left =3D that.parentData.left + that.position.left;=0A=
			that.offset.top =3D that.parentData.top + that.position.top;=0A=
		} else {=0A=
			that.offset.left =3D that.element.offset().left;=0A=
			that.offset.top =3D that.element.offset().top;=0A=
		}=0A=
=0A=
		woset =3D Math.abs( that.sizeDiff.width +=0A=
			(that._helper ?=0A=
				that.offset.left - cop.left :=0A=
				(that.offset.left - co.left)) );=0A=
=0A=
		hoset =3D Math.abs( that.sizeDiff.height +=0A=
			(that._helper ?=0A=
				that.offset.top - cop.top :=0A=
				(that.offset.top - co.top)) );=0A=
=0A=
		if ( woset + that.size.width >=3D that.parentData.width ) {=0A=
			that.size.width =3D that.parentData.width - woset;=0A=
			if ( pRatio ) {=0A=
				that.size.height =3D that.size.width / that.aspectRatio;=0A=
				continueResize =3D false;=0A=
			}=0A=
		}=0A=
=0A=
		if ( hoset + that.size.height >=3D that.parentData.height ) {=0A=
			that.size.height =3D that.parentData.height - hoset;=0A=
			if ( pRatio ) {=0A=
				that.size.width =3D that.size.height * that.aspectRatio;=0A=
				continueResize =3D false;=0A=
			}=0A=
		}=0A=
=0A=
		if ( !continueResize ){=0A=
			that.position.left =3D that.prevPosition.left;=0A=
			that.position.top =3D that.prevPosition.top;=0A=
			that.size.width =3D that.prevSize.width;=0A=
			that.size.height =3D that.prevSize.height;=0A=
		}=0A=
	},=0A=
=0A=
	stop: function() {=0A=
		var that =3D $( this ).resizable( "instance" ),=0A=
			o =3D that.options,=0A=
			co =3D that.containerOffset,=0A=
			cop =3D that.containerPosition,=0A=
			ce =3D that.containerElement,=0A=
			helper =3D $( that.helper ),=0A=
			ho =3D helper.offset(),=0A=
			w =3D helper.outerWidth() - that.sizeDiff.width,=0A=
			h =3D helper.outerHeight() - that.sizeDiff.height;=0A=
=0A=
		if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( =
"position" ) ) ) {=0A=
			$( this ).css({=0A=
				left: ho.left - cop.left - co.left,=0A=
				width: w,=0A=
				height: h=0A=
			});=0A=
		}=0A=
=0A=
		if ( that._helper && !o.animate && ( /static/ ).test( ce.css( =
"position" ) ) ) {=0A=
			$( this ).css({=0A=
				left: ho.left - cop.left - co.left,=0A=
				width: w,=0A=
				height: h=0A=
			});=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
$.ui.plugin.add("resizable", "alsoResize", {=0A=
=0A=
	start: function() {=0A=
		var that =3D $(this).resizable( "instance" ),=0A=
			o =3D that.options,=0A=
			_store =3D function(exp) {=0A=
				$(exp).each(function() {=0A=
					var el =3D $(this);=0A=
					el.data("ui-resizable-alsoresize", {=0A=
						width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),=0A=
						left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), =
10)=0A=
					});=0A=
				});=0A=
			};=0A=
=0A=
		if (typeof(o.alsoResize) =3D=3D=3D "object" && =
!o.alsoResize.parentNode) {=0A=
			if (o.alsoResize.length) {=0A=
				o.alsoResize =3D o.alsoResize[0];=0A=
				_store(o.alsoResize);=0A=
			} else {=0A=
				$.each(o.alsoResize, function(exp) {=0A=
					_store(exp);=0A=
				});=0A=
			}=0A=
		} else {=0A=
			_store(o.alsoResize);=0A=
		}=0A=
	},=0A=
=0A=
	resize: function(event, ui) {=0A=
		var that =3D $(this).resizable( "instance" ),=0A=
			o =3D that.options,=0A=
			os =3D that.originalSize,=0A=
			op =3D that.originalPosition,=0A=
			delta =3D {=0A=
				height: (that.size.height - os.height) || 0,=0A=
				width: (that.size.width - os.width) || 0,=0A=
				top: (that.position.top - op.top) || 0,=0A=
				left: (that.position.left - op.left) || 0=0A=
			},=0A=
=0A=
			_alsoResize =3D function(exp, c) {=0A=
				$(exp).each(function() {=0A=
					var el =3D $(this), start =3D =
$(this).data("ui-resizable-alsoresize"), style =3D {},=0A=
						css =3D c && c.length ?=0A=
							c :=0A=
							el.parents(ui.originalElement[0]).length ?=0A=
								[ "width", "height" ] :=0A=
								[ "width", "height", "top", "left" ];=0A=
=0A=
					$.each(css, function(i, prop) {=0A=
						var sum =3D (start[prop] || 0) + (delta[prop] || 0);=0A=
						if (sum && sum >=3D 0) {=0A=
							style[prop] =3D sum || null;=0A=
						}=0A=
					});=0A=
=0A=
					el.css(style);=0A=
				});=0A=
			};=0A=
=0A=
		if (typeof(o.alsoResize) =3D=3D=3D "object" && !o.alsoResize.nodeType) =
{=0A=
			$.each(o.alsoResize, function(exp, c) {=0A=
				_alsoResize(exp, c);=0A=
			});=0A=
		} else {=0A=
			_alsoResize(o.alsoResize);=0A=
		}=0A=
	},=0A=
=0A=
	stop: function() {=0A=
		$(this).removeData("resizable-alsoresize");=0A=
	}=0A=
});=0A=
=0A=
$.ui.plugin.add("resizable", "ghost", {=0A=
=0A=
	start: function() {=0A=
=0A=
		var that =3D $(this).resizable( "instance" ), o =3D that.options, cs =
=3D that.size;=0A=
=0A=
		that.ghost =3D that.originalElement.clone();=0A=
		that.ghost=0A=
			.css({=0A=
				opacity: 0.25,=0A=
				display: "block",=0A=
				position: "relative",=0A=
				height: cs.height,=0A=
				width: cs.width,=0A=
				margin: 0,=0A=
				left: 0,=0A=
				top: 0=0A=
			})=0A=
			.addClass("ui-resizable-ghost")=0A=
			.addClass(typeof o.ghost =3D=3D=3D "string" ? o.ghost : "");=0A=
=0A=
		that.ghost.appendTo(that.helper);=0A=
=0A=
	},=0A=
=0A=
	resize: function() {=0A=
		var that =3D $(this).resizable( "instance" );=0A=
		if (that.ghost) {=0A=
			that.ghost.css({=0A=
				position: "relative",=0A=
				height: that.size.height,=0A=
				width: that.size.width=0A=
			});=0A=
		}=0A=
	},=0A=
=0A=
	stop: function() {=0A=
		var that =3D $(this).resizable( "instance" );=0A=
		if (that.ghost && that.helper) {=0A=
			that.helper.get(0).removeChild(that.ghost.get(0));=0A=
		}=0A=
	}=0A=
=0A=
});=0A=
=0A=
$.ui.plugin.add("resizable", "grid", {=0A=
=0A=
	resize: function() {=0A=
		var outerDimensions,=0A=
			that =3D $(this).resizable( "instance" ),=0A=
			o =3D that.options,=0A=
			cs =3D that.size,=0A=
			os =3D that.originalSize,=0A=
			op =3D that.originalPosition,=0A=
			a =3D that.axis,=0A=
			grid =3D typeof o.grid =3D=3D=3D "number" ? [ o.grid, o.grid ] : =
o.grid,=0A=
			gridX =3D (grid[0] || 1),=0A=
			gridY =3D (grid[1] || 1),=0A=
			ox =3D Math.round((cs.width - os.width) / gridX) * gridX,=0A=
			oy =3D Math.round((cs.height - os.height) / gridY) * gridY,=0A=
			newWidth =3D os.width + ox,=0A=
			newHeight =3D os.height + oy,=0A=
			isMaxWidth =3D o.maxWidth && (o.maxWidth < newWidth),=0A=
			isMaxHeight =3D o.maxHeight && (o.maxHeight < newHeight),=0A=
			isMinWidth =3D o.minWidth && (o.minWidth > newWidth),=0A=
			isMinHeight =3D o.minHeight && (o.minHeight > newHeight);=0A=
=0A=
		o.grid =3D grid;=0A=
=0A=
		if (isMinWidth) {=0A=
			newWidth +=3D gridX;=0A=
		}=0A=
		if (isMinHeight) {=0A=
			newHeight +=3D gridY;=0A=
		}=0A=
		if (isMaxWidth) {=0A=
			newWidth -=3D gridX;=0A=
		}=0A=
		if (isMaxHeight) {=0A=
			newHeight -=3D gridY;=0A=
		}=0A=
=0A=
		if (/^(se|s|e)$/.test(a)) {=0A=
			that.size.width =3D newWidth;=0A=
			that.size.height =3D newHeight;=0A=
		} else if (/^(ne)$/.test(a)) {=0A=
			that.size.width =3D newWidth;=0A=
			that.size.height =3D newHeight;=0A=
			that.position.top =3D op.top - oy;=0A=
		} else if (/^(sw)$/.test(a)) {=0A=
			that.size.width =3D newWidth;=0A=
			that.size.height =3D newHeight;=0A=
			that.position.left =3D op.left - ox;=0A=
		} else {=0A=
			if ( newHeight - gridY <=3D 0 || newWidth - gridX <=3D 0) {=0A=
				outerDimensions =3D that._getPaddingPlusBorderDimensions( this );=0A=
			}=0A=
=0A=
			if ( newHeight - gridY > 0 ) {=0A=
				that.size.height =3D newHeight;=0A=
				that.position.top =3D op.top - oy;=0A=
			} else {=0A=
				newHeight =3D gridY - outerDimensions.height;=0A=
				that.size.height =3D newHeight;=0A=
				that.position.top =3D op.top + os.height - newHeight;=0A=
			}=0A=
			if ( newWidth - gridX > 0 ) {=0A=
				that.size.width =3D newWidth;=0A=
				that.position.left =3D op.left - ox;=0A=
			} else {=0A=
				newWidth =3D gridY - outerDimensions.height;=0A=
				that.size.width =3D newWidth;=0A=
				that.position.left =3D op.left + os.width - newWidth;=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
});=0A=
=0A=
var resizable =3D $.ui.resizable;=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Selectable 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/selectable/=0A=
 */=0A=
=0A=
=0A=
var selectable =3D $.widget("ui.selectable", $.ui.mouse, {=0A=
	version: "1.11.1",=0A=
	options: {=0A=
		appendTo: "body",=0A=
		autoRefresh: true,=0A=
		distance: 0,=0A=
		filter: "*",=0A=
		tolerance: "touch",=0A=
=0A=
		// callbacks=0A=
		selected: null,=0A=
		selecting: null,=0A=
		start: null,=0A=
		stop: null,=0A=
		unselected: null,=0A=
		unselecting: null=0A=
	},=0A=
	_create: function() {=0A=
		var selectees,=0A=
			that =3D this;=0A=
=0A=
		this.element.addClass("ui-selectable");=0A=
=0A=
		this.dragged =3D false;=0A=
=0A=
		// cache selectee children based on filter=0A=
		this.refresh =3D function() {=0A=
			selectees =3D $(that.options.filter, that.element[0]);=0A=
			selectees.addClass("ui-selectee");=0A=
			selectees.each(function() {=0A=
				var $this =3D $(this),=0A=
					pos =3D $this.offset();=0A=
				$.data(this, "selectable-item", {=0A=
					element: this,=0A=
					$element: $this,=0A=
					left: pos.left,=0A=
					top: pos.top,=0A=
					right: pos.left + $this.outerWidth(),=0A=
					bottom: pos.top + $this.outerHeight(),=0A=
					startselected: false,=0A=
					selected: $this.hasClass("ui-selected"),=0A=
					selecting: $this.hasClass("ui-selecting"),=0A=
					unselecting: $this.hasClass("ui-unselecting")=0A=
				});=0A=
			});=0A=
		};=0A=
		this.refresh();=0A=
=0A=
		this.selectees =3D selectees.addClass("ui-selectee");=0A=
=0A=
		this._mouseInit();=0A=
=0A=
		this.helper =3D $("<div class=3D'ui-selectable-helper'></div>");=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		this.selectees=0A=
			.removeClass("ui-selectee")=0A=
			.removeData("selectable-item");=0A=
		this.element=0A=
			.removeClass("ui-selectable ui-selectable-disabled");=0A=
		this._mouseDestroy();=0A=
	},=0A=
=0A=
	_mouseStart: function(event) {=0A=
		var that =3D this,=0A=
			options =3D this.options;=0A=
=0A=
		this.opos =3D [ event.pageX, event.pageY ];=0A=
=0A=
		if (this.options.disabled) {=0A=
			return;=0A=
		}=0A=
=0A=
		this.selectees =3D $(options.filter, this.element[0]);=0A=
=0A=
		this._trigger("start", event);=0A=
=0A=
		$(options.appendTo).append(this.helper);=0A=
		// position helper (lasso)=0A=
		this.helper.css({=0A=
			"left": event.pageX,=0A=
			"top": event.pageY,=0A=
			"width": 0,=0A=
			"height": 0=0A=
		});=0A=
=0A=
		if (options.autoRefresh) {=0A=
			this.refresh();=0A=
		}=0A=
=0A=
		this.selectees.filter(".ui-selected").each(function() {=0A=
			var selectee =3D $.data(this, "selectable-item");=0A=
			selectee.startselected =3D true;=0A=
			if (!event.metaKey && !event.ctrlKey) {=0A=
				selectee.$element.removeClass("ui-selected");=0A=
				selectee.selected =3D false;=0A=
				selectee.$element.addClass("ui-unselecting");=0A=
				selectee.unselecting =3D true;=0A=
				// selectable UNSELECTING callback=0A=
				that._trigger("unselecting", event, {=0A=
					unselecting: selectee.element=0A=
				});=0A=
			}=0A=
		});=0A=
=0A=
		$(event.target).parents().addBack().each(function() {=0A=
			var doSelect,=0A=
				selectee =3D $.data(this, "selectable-item");=0A=
			if (selectee) {=0A=
				doSelect =3D (!event.metaKey && !event.ctrlKey) || =
!selectee.$element.hasClass("ui-selected");=0A=
				selectee.$element=0A=
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")=0A=
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");=0A=
				selectee.unselecting =3D !doSelect;=0A=
				selectee.selecting =3D doSelect;=0A=
				selectee.selected =3D doSelect;=0A=
				// selectable (UN)SELECTING callback=0A=
				if (doSelect) {=0A=
					that._trigger("selecting", event, {=0A=
						selecting: selectee.element=0A=
					});=0A=
				} else {=0A=
					that._trigger("unselecting", event, {=0A=
						unselecting: selectee.element=0A=
					});=0A=
				}=0A=
				return false;=0A=
			}=0A=
		});=0A=
=0A=
	},=0A=
=0A=
	_mouseDrag: function(event) {=0A=
=0A=
		this.dragged =3D true;=0A=
=0A=
		if (this.options.disabled) {=0A=
			return;=0A=
		}=0A=
=0A=
		var tmp,=0A=
			that =3D this,=0A=
			options =3D this.options,=0A=
			x1 =3D this.opos[0],=0A=
			y1 =3D this.opos[1],=0A=
			x2 =3D event.pageX,=0A=
			y2 =3D event.pageY;=0A=
=0A=
		if (x1 > x2) { tmp =3D x2; x2 =3D x1; x1 =3D tmp; }=0A=
		if (y1 > y2) { tmp =3D y2; y2 =3D y1; y1 =3D tmp; }=0A=
		this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 =
});=0A=
=0A=
		this.selectees.each(function() {=0A=
			var selectee =3D $.data(this, "selectable-item"),=0A=
				hit =3D false;=0A=
=0A=
			//prevent helper from being selected if appendTo: selectable=0A=
			if (!selectee || selectee.element =3D=3D=3D that.element[0]) {=0A=
				return;=0A=
			}=0A=
=0A=
			if (options.tolerance =3D=3D=3D "touch") {=0A=
				hit =3D ( !(selectee.left > x2 || selectee.right < x1 || =
selectee.top > y2 || selectee.bottom < y1) );=0A=
			} else if (options.tolerance =3D=3D=3D "fit") {=0A=
				hit =3D (selectee.left > x1 && selectee.right < x2 && selectee.top > =
y1 && selectee.bottom < y2);=0A=
			}=0A=
=0A=
			if (hit) {=0A=
				// SELECT=0A=
				if (selectee.selected) {=0A=
					selectee.$element.removeClass("ui-selected");=0A=
					selectee.selected =3D false;=0A=
				}=0A=
				if (selectee.unselecting) {=0A=
					selectee.$element.removeClass("ui-unselecting");=0A=
					selectee.unselecting =3D false;=0A=
				}=0A=
				if (!selectee.selecting) {=0A=
					selectee.$element.addClass("ui-selecting");=0A=
					selectee.selecting =3D true;=0A=
					// selectable SELECTING callback=0A=
					that._trigger("selecting", event, {=0A=
						selecting: selectee.element=0A=
					});=0A=
				}=0A=
			} else {=0A=
				// UNSELECT=0A=
				if (selectee.selecting) {=0A=
					if ((event.metaKey || event.ctrlKey) && selectee.startselected) {=0A=
						selectee.$element.removeClass("ui-selecting");=0A=
						selectee.selecting =3D false;=0A=
						selectee.$element.addClass("ui-selected");=0A=
						selectee.selected =3D true;=0A=
					} else {=0A=
						selectee.$element.removeClass("ui-selecting");=0A=
						selectee.selecting =3D false;=0A=
						if (selectee.startselected) {=0A=
							selectee.$element.addClass("ui-unselecting");=0A=
							selectee.unselecting =3D true;=0A=
						}=0A=
						// selectable UNSELECTING callback=0A=
						that._trigger("unselecting", event, {=0A=
							unselecting: selectee.element=0A=
						});=0A=
					}=0A=
				}=0A=
				if (selectee.selected) {=0A=
					if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {=0A=
						selectee.$element.removeClass("ui-selected");=0A=
						selectee.selected =3D false;=0A=
=0A=
						selectee.$element.addClass("ui-unselecting");=0A=
						selectee.unselecting =3D true;=0A=
						// selectable UNSELECTING callback=0A=
						that._trigger("unselecting", event, {=0A=
							unselecting: selectee.element=0A=
						});=0A=
					}=0A=
				}=0A=
			}=0A=
		});=0A=
=0A=
		return false;=0A=
	},=0A=
=0A=
	_mouseStop: function(event) {=0A=
		var that =3D this;=0A=
=0A=
		this.dragged =3D false;=0A=
=0A=
		$(".ui-unselecting", this.element[0]).each(function() {=0A=
			var selectee =3D $.data(this, "selectable-item");=0A=
			selectee.$element.removeClass("ui-unselecting");=0A=
			selectee.unselecting =3D false;=0A=
			selectee.startselected =3D false;=0A=
			that._trigger("unselected", event, {=0A=
				unselected: selectee.element=0A=
			});=0A=
		});=0A=
		$(".ui-selecting", this.element[0]).each(function() {=0A=
			var selectee =3D $.data(this, "selectable-item");=0A=
			selectee.$element.removeClass("ui-selecting").addClass("ui-selected");=0A=
			selectee.selecting =3D false;=0A=
			selectee.selected =3D true;=0A=
			selectee.startselected =3D true;=0A=
			that._trigger("selected", event, {=0A=
				selected: selectee.element=0A=
			});=0A=
		});=0A=
		this._trigger("stop", event);=0A=
=0A=
		this.helper.remove();=0A=
=0A=
		return false;=0A=
	}=0A=
=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Sortable 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/sortable/=0A=
 */=0A=
=0A=
=0A=
var sortable =3D $.widget("ui.sortable", $.ui.mouse, {=0A=
	version: "1.11.1",=0A=
	widgetEventPrefix: "sort",=0A=
	ready: false,=0A=
	options: {=0A=
		appendTo: "parent",=0A=
		axis: false,=0A=
		connectWith: false,=0A=
		containment: false,=0A=
		cursor: "auto",=0A=
		cursorAt: false,=0A=
		dropOnEmpty: true,=0A=
		forcePlaceholderSize: false,=0A=
		forceHelperSize: false,=0A=
		grid: false,=0A=
		handle: false,=0A=
		helper: "original",=0A=
		items: "> *",=0A=
		opacity: false,=0A=
		placeholder: false,=0A=
		revert: false,=0A=
		scroll: true,=0A=
		scrollSensitivity: 20,=0A=
		scrollSpeed: 20,=0A=
		scope: "default",=0A=
		tolerance: "intersect",=0A=
		zIndex: 1000,=0A=
=0A=
		// callbacks=0A=
		activate: null,=0A=
		beforeStop: null,=0A=
		change: null,=0A=
		deactivate: null,=0A=
		out: null,=0A=
		over: null,=0A=
		receive: null,=0A=
		remove: null,=0A=
		sort: null,=0A=
		start: null,=0A=
		stop: null,=0A=
		update: null=0A=
	},=0A=
=0A=
	_isOverAxis: function( x, reference, size ) {=0A=
		return ( x >=3D reference ) && ( x < ( reference + size ) );=0A=
	},=0A=
=0A=
	_isFloating: function( item ) {=0A=
		return (/left|right/).test(item.css("float")) || =
(/inline|table-cell/).test(item.css("display"));=0A=
	},=0A=
=0A=
	_create: function() {=0A=
=0A=
		var o =3D this.options;=0A=
		this.containerCache =3D {};=0A=
		this.element.addClass("ui-sortable");=0A=
=0A=
		//Get the items=0A=
		this.refresh();=0A=
=0A=
		//Let's determine if the items are being displayed horizontally=0A=
		this.floating =3D this.items.length ? o.axis =3D=3D=3D "x" || =
this._isFloating(this.items[0].item) : false;=0A=
=0A=
		//Let's determine the parent's offset=0A=
		this.offset =3D this.element.offset();=0A=
=0A=
		//Initialize mouse events for interaction=0A=
		this._mouseInit();=0A=
=0A=
		this._setHandleClassName();=0A=
=0A=
		//We're ready to go=0A=
		this.ready =3D true;=0A=
=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		this._super( key, value );=0A=
=0A=
		if ( key =3D=3D=3D "handle" ) {=0A=
			this._setHandleClassName();=0A=
		}=0A=
	},=0A=
=0A=
	_setHandleClassName: function() {=0A=
		this.element.find( ".ui-sortable-handle" ).removeClass( =
"ui-sortable-handle" );=0A=
		$.each( this.items, function() {=0A=
			( this.instance.options.handle ?=0A=
				this.item.find( this.instance.options.handle ) : this.item )=0A=
				.addClass( "ui-sortable-handle" );=0A=
		});=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		this.element=0A=
			.removeClass( "ui-sortable ui-sortable-disabled" )=0A=
			.find( ".ui-sortable-handle" )=0A=
				.removeClass( "ui-sortable-handle" );=0A=
		this._mouseDestroy();=0A=
=0A=
		for ( var i =3D this.items.length - 1; i >=3D 0; i-- ) {=0A=
			this.items[i].item.removeData(this.widgetName + "-item");=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	_mouseCapture: function(event, overrideHandle) {=0A=
		var currentItem =3D null,=0A=
			validHandle =3D false,=0A=
			that =3D this;=0A=
=0A=
		if (this.reverting) {=0A=
			return false;=0A=
		}=0A=
=0A=
		if(this.options.disabled || this.options.type =3D=3D=3D "static") {=0A=
			return false;=0A=
		}=0A=
=0A=
		//We have to refresh the items data once first=0A=
		this._refreshItems(event);=0A=
=0A=
		//Find out if the clicked node (or one of its parents) is a actual =
item in this.items=0A=
		$(event.target).parents().each(function() {=0A=
			if($.data(this, that.widgetName + "-item") =3D=3D=3D that) {=0A=
				currentItem =3D $(this);=0A=
				return false;=0A=
			}=0A=
		});=0A=
		if($.data(event.target, that.widgetName + "-item") =3D=3D=3D that) {=0A=
			currentItem =3D $(event.target);=0A=
		}=0A=
=0A=
		if(!currentItem) {=0A=
			return false;=0A=
		}=0A=
		if(this.options.handle && !overrideHandle) {=0A=
			$(this.options.handle, =
currentItem).find("*").addBack().each(function() {=0A=
				if(this =3D=3D=3D event.target) {=0A=
					validHandle =3D true;=0A=
				}=0A=
			});=0A=
			if(!validHandle) {=0A=
				return false;=0A=
			}=0A=
		}=0A=
=0A=
		this.currentItem =3D currentItem;=0A=
		this._removeCurrentsFromItems();=0A=
		return true;=0A=
=0A=
	},=0A=
=0A=
	_mouseStart: function(event, overrideHandle, noActivation) {=0A=
=0A=
		var i, body,=0A=
			o =3D this.options;=0A=
=0A=
		this.currentContainer =3D this;=0A=
=0A=
		//We only need to call refreshPositions, because the refreshItems call =
has been moved to mouseCapture=0A=
		this.refreshPositions();=0A=
=0A=
		//Create and append the visible helper=0A=
		this.helper =3D this._createHelper(event);=0A=
=0A=
		//Cache the helper size=0A=
		this._cacheHelperProportions();=0A=
=0A=
		/*=0A=
		 * - Position generation -=0A=
		 * This block generates everything position related - it's the core of =
draggables.=0A=
		 */=0A=
=0A=
		//Cache the margins of the original element=0A=
		this._cacheMargins();=0A=
=0A=
		//Get the next scrolling parent=0A=
		this.scrollParent =3D this.helper.scrollParent();=0A=
=0A=
		//The element's absolute position on the page minus margins=0A=
		this.offset =3D this.currentItem.offset();=0A=
		this.offset =3D {=0A=
			top: this.offset.top - this.margins.top,=0A=
			left: this.offset.left - this.margins.left=0A=
		};=0A=
=0A=
		$.extend(this.offset, {=0A=
			click: { //Where the click happened, relative to the element=0A=
				left: event.pageX - this.offset.left,=0A=
				top: event.pageY - this.offset.top=0A=
			},=0A=
			parent: this._getParentOffset(),=0A=
			relative: this._getRelativeOffset() //This is a relative to absolute =
position minus the actual position calculation - only used for relative =
positioned helper=0A=
		});=0A=
=0A=
		// Only after we got the offset, we can change the helper's position =
to absolute=0A=
		// TODO: Still need to figure out a way to make relative sorting =
possible=0A=
		this.helper.css("position", "absolute");=0A=
		this.cssPosition =3D this.helper.css("position");=0A=
=0A=
		//Generate the original position=0A=
		this.originalPosition =3D this._generatePosition(event);=0A=
		this.originalPageX =3D event.pageX;=0A=
		this.originalPageY =3D event.pageY;=0A=
=0A=
		//Adjust the mouse offset relative to the helper if "cursorAt" is =
supplied=0A=
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));=0A=
=0A=
		//Cache the former DOM position=0A=
		this.domPosition =3D { prev: this.currentItem.prev()[0], parent: =
this.currentItem.parent()[0] };=0A=
=0A=
		//If the helper is not the original, hide the original so it's not =
playing any role during the drag, won't cause anything bad this way=0A=
		if(this.helper[0] !=3D=3D this.currentItem[0]) {=0A=
			this.currentItem.hide();=0A=
		}=0A=
=0A=
		//Create the placeholder=0A=
		this._createPlaceholder();=0A=
=0A=
		//Set a containment if given in the options=0A=
		if(o.containment) {=0A=
			this._setContainment();=0A=
		}=0A=
=0A=
		if( o.cursor && o.cursor !=3D=3D "auto" ) { // cursor option=0A=
			body =3D this.document.find( "body" );=0A=
=0A=
			// support: IE=0A=
			this.storedCursor =3D body.css( "cursor" );=0A=
			body.css( "cursor", o.cursor );=0A=
=0A=
			this.storedStylesheet =3D $( "<style>*{ cursor: "+o.cursor+" =
!important; }</style>" ).appendTo( body );=0A=
		}=0A=
=0A=
		if(o.opacity) { // opacity option=0A=
			if (this.helper.css("opacity")) {=0A=
				this._storedOpacity =3D this.helper.css("opacity");=0A=
			}=0A=
			this.helper.css("opacity", o.opacity);=0A=
		}=0A=
=0A=
		if(o.zIndex) { // zIndex option=0A=
			if (this.helper.css("zIndex")) {=0A=
				this._storedZIndex =3D this.helper.css("zIndex");=0A=
			}=0A=
			this.helper.css("zIndex", o.zIndex);=0A=
		}=0A=
=0A=
		//Prepare scrolling=0A=
		if(this.scrollParent[0] !=3D=3D document && =
this.scrollParent[0].tagName !=3D=3D "HTML") {=0A=
			this.overflowOffset =3D this.scrollParent.offset();=0A=
		}=0A=
=0A=
		//Call callbacks=0A=
		this._trigger("start", event, this._uiHash());=0A=
=0A=
		//Recache the helper size=0A=
		if(!this._preserveHelperProportions) {=0A=
			this._cacheHelperProportions();=0A=
		}=0A=
=0A=
=0A=
		//Post "activate" events to possible containers=0A=
		if( !noActivation ) {=0A=
			for ( i =3D this.containers.length - 1; i >=3D 0; i-- ) {=0A=
				this.containers[ i ]._trigger( "activate", event, this._uiHash( this =
) );=0A=
			}=0A=
		}=0A=
=0A=
		//Prepare possible droppables=0A=
		if($.ui.ddmanager) {=0A=
			$.ui.ddmanager.current =3D this;=0A=
		}=0A=
=0A=
		if ($.ui.ddmanager && !o.dropBehaviour) {=0A=
			$.ui.ddmanager.prepareOffsets(this, event);=0A=
		}=0A=
=0A=
		this.dragging =3D true;=0A=
=0A=
		this.helper.addClass("ui-sortable-helper");=0A=
		this._mouseDrag(event); //Execute the drag once - this causes the =
helper not to be visible before getting its correct position=0A=
		return true;=0A=
=0A=
	},=0A=
=0A=
	_mouseDrag: function(event) {=0A=
		var i, item, itemElement, intersection,=0A=
			o =3D this.options,=0A=
			scrolled =3D false;=0A=
=0A=
		//Compute the helpers position=0A=
		this.position =3D this._generatePosition(event);=0A=
		this.positionAbs =3D this._convertPositionTo("absolute");=0A=
=0A=
		if (!this.lastPositionAbs) {=0A=
			this.lastPositionAbs =3D this.positionAbs;=0A=
		}=0A=
=0A=
		//Do scrolling=0A=
		if(this.options.scroll) {=0A=
			if(this.scrollParent[0] !=3D=3D document && =
this.scrollParent[0].tagName !=3D=3D "HTML") {=0A=
=0A=
				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - =
event.pageY < o.scrollSensitivity) {=0A=
					this.scrollParent[0].scrollTop =3D scrolled =3D =
this.scrollParent[0].scrollTop + o.scrollSpeed;=0A=
				} else if(event.pageY - this.overflowOffset.top < =
o.scrollSensitivity) {=0A=
					this.scrollParent[0].scrollTop =3D scrolled =3D =
this.scrollParent[0].scrollTop - o.scrollSpeed;=0A=
				}=0A=
=0A=
				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - =
event.pageX < o.scrollSensitivity) {=0A=
					this.scrollParent[0].scrollLeft =3D scrolled =3D =
this.scrollParent[0].scrollLeft + o.scrollSpeed;=0A=
				} else if(event.pageX - this.overflowOffset.left < =
o.scrollSensitivity) {=0A=
					this.scrollParent[0].scrollLeft =3D scrolled =3D =
this.scrollParent[0].scrollLeft - o.scrollSpeed;=0A=
				}=0A=
=0A=
			} else {=0A=
=0A=
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {=0A=
					scrolled =3D $(document).scrollTop($(document).scrollTop() - =
o.scrollSpeed);=0A=
				} else if($(window).height() - (event.pageY - =
$(document).scrollTop()) < o.scrollSensitivity) {=0A=
					scrolled =3D $(document).scrollTop($(document).scrollTop() + =
o.scrollSpeed);=0A=
				}=0A=
=0A=
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {=0A=
					scrolled =3D $(document).scrollLeft($(document).scrollLeft() - =
o.scrollSpeed);=0A=
				} else if($(window).width() - (event.pageX - =
$(document).scrollLeft()) < o.scrollSensitivity) {=0A=
					scrolled =3D $(document).scrollLeft($(document).scrollLeft() + =
o.scrollSpeed);=0A=
				}=0A=
=0A=
			}=0A=
=0A=
			if(scrolled !=3D=3D false && $.ui.ddmanager && !o.dropBehaviour) {=0A=
				$.ui.ddmanager.prepareOffsets(this, event);=0A=
			}=0A=
		}=0A=
=0A=
		//Regenerate the absolute position used for position checks=0A=
		this.positionAbs =3D this._convertPositionTo("absolute");=0A=
=0A=
		//Set the helper position=0A=
		if(!this.options.axis || this.options.axis !=3D=3D "y") {=0A=
			this.helper[0].style.left =3D this.position.left+"px";=0A=
		}=0A=
		if(!this.options.axis || this.options.axis !=3D=3D "x") {=0A=
			this.helper[0].style.top =3D this.position.top+"px";=0A=
		}=0A=
=0A=
		//Rearrange=0A=
		for (i =3D this.items.length - 1; i >=3D 0; i--) {=0A=
=0A=
			//Cache variables and intersection, continue if no intersection=0A=
			item =3D this.items[i];=0A=
			itemElement =3D item.item[0];=0A=
			intersection =3D this._intersectsWithPointer(item);=0A=
			if (!intersection) {=0A=
				continue;=0A=
			}=0A=
=0A=
			// Only put the placeholder inside the current Container, skip all=0A=
			// items from other containers. This works because when moving=0A=
			// an item from one container to another the=0A=
			// currentContainer is switched before the placeholder is moved.=0A=
			//=0A=
			// Without this, moving items in "sub-sortables" can cause=0A=
			// the placeholder to jitter between the outer and inner container.=0A=
			if (item.instance !=3D=3D this.currentContainer) {=0A=
				continue;=0A=
			}=0A=
=0A=
			// cannot intersect with itself=0A=
			// no useless actions that have been done before=0A=
			// no action if the item moved is the parent of the item checked=0A=
			if (itemElement !=3D=3D this.currentItem[0] &&=0A=
				this.placeholder[intersection =3D=3D=3D 1 ? "next" : "prev"]()[0] =
!=3D=3D itemElement &&=0A=
				!$.contains(this.placeholder[0], itemElement) &&=0A=
				(this.options.type =3D=3D=3D "semi-dynamic" ? =
!$.contains(this.element[0], itemElement) : true)=0A=
			) {=0A=
=0A=
				this.direction =3D intersection =3D=3D=3D 1 ? "down" : "up";=0A=
=0A=
				if (this.options.tolerance =3D=3D=3D "pointer" || =
this._intersectsWithSides(item)) {=0A=
					this._rearrange(event, item);=0A=
				} else {=0A=
					break;=0A=
				}=0A=
=0A=
				this._trigger("change", event, this._uiHash());=0A=
				break;=0A=
			}=0A=
		}=0A=
=0A=
		//Post events to containers=0A=
		this._contactContainers(event);=0A=
=0A=
		//Interconnect with droppables=0A=
		if($.ui.ddmanager) {=0A=
			$.ui.ddmanager.drag(this, event);=0A=
		}=0A=
=0A=
		//Call callbacks=0A=
		this._trigger("sort", event, this._uiHash());=0A=
=0A=
		this.lastPositionAbs =3D this.positionAbs;=0A=
		return false;=0A=
=0A=
	},=0A=
=0A=
	_mouseStop: function(event, noPropagation) {=0A=
=0A=
		if(!event) {=0A=
			return;=0A=
		}=0A=
=0A=
		//If we are using droppables, inform the manager about the drop=0A=
		if ($.ui.ddmanager && !this.options.dropBehaviour) {=0A=
			$.ui.ddmanager.drop(this, event);=0A=
		}=0A=
=0A=
		if(this.options.revert) {=0A=
			var that =3D this,=0A=
				cur =3D this.placeholder.offset(),=0A=
				axis =3D this.options.axis,=0A=
				animation =3D {};=0A=
=0A=
			if ( !axis || axis =3D=3D=3D "x" ) {=0A=
				animation.left =3D cur.left - this.offset.parent.left - =
this.margins.left + (this.offsetParent[0] =3D=3D=3D document.body ? 0 : =
this.offsetParent[0].scrollLeft);=0A=
			}=0A=
			if ( !axis || axis =3D=3D=3D "y" ) {=0A=
				animation.top =3D cur.top - this.offset.parent.top - =
this.margins.top + (this.offsetParent[0] =3D=3D=3D document.body ? 0 : =
this.offsetParent[0].scrollTop);=0A=
			}=0A=
			this.reverting =3D true;=0A=
			$(this.helper).animate( animation, parseInt(this.options.revert, 10) =
|| 500, function() {=0A=
				that._clear(event);=0A=
			});=0A=
		} else {=0A=
			this._clear(event, noPropagation);=0A=
		}=0A=
=0A=
		return false;=0A=
=0A=
	},=0A=
=0A=
	cancel: function() {=0A=
=0A=
		if(this.dragging) {=0A=
=0A=
			this._mouseUp({ target: null });=0A=
=0A=
			if(this.options.helper =3D=3D=3D "original") {=0A=
				=
this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");=0A=
			} else {=0A=
				this.currentItem.show();=0A=
			}=0A=
=0A=
			//Post deactivating events to containers=0A=
			for (var i =3D this.containers.length - 1; i >=3D 0; i--){=0A=
				this.containers[i]._trigger("deactivate", null, this._uiHash(this));=0A=
				if(this.containers[i].containerCache.over) {=0A=
					this.containers[i]._trigger("out", null, this._uiHash(this));=0A=
					this.containers[i].containerCache.over =3D 0;=0A=
				}=0A=
			}=0A=
=0A=
		}=0A=
=0A=
		if (this.placeholder) {=0A=
			//$(this.placeholder[0]).remove(); would have been the jQuery way - =
unfortunately, it unbinds ALL events from the original node!=0A=
			if(this.placeholder[0].parentNode) {=0A=
				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);=0A=
			}=0A=
			if(this.options.helper !=3D=3D "original" && this.helper && =
this.helper[0].parentNode) {=0A=
				this.helper.remove();=0A=
			}=0A=
=0A=
			$.extend(this, {=0A=
				helper: null,=0A=
				dragging: false,=0A=
				reverting: false,=0A=
				_noFinalSort: null=0A=
			});=0A=
=0A=
			if(this.domPosition.prev) {=0A=
				$(this.domPosition.prev).after(this.currentItem);=0A=
			} else {=0A=
				$(this.domPosition.parent).prepend(this.currentItem);=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
=0A=
	},=0A=
=0A=
	serialize: function(o) {=0A=
=0A=
		var items =3D this._getItemsAsjQuery(o && o.connected),=0A=
			str =3D [];=0A=
		o =3D o || {};=0A=
=0A=
		$(items).each(function() {=0A=
			var res =3D ($(o.item || this).attr(o.attribute || "id") || =
"").match(o.expression || (/(.+)[\-=3D_](.+)/));=0A=
			if (res) {=0A=
				str.push((o.key || res[1]+"[]")+"=3D"+(o.key && o.expression ? =
res[1] : res[2]));=0A=
			}=0A=
		});=0A=
=0A=
		if(!str.length && o.key) {=0A=
			str.push(o.key + "=3D");=0A=
		}=0A=
=0A=
		return str.join("&");=0A=
=0A=
	},=0A=
=0A=
	toArray: function(o) {=0A=
=0A=
		var items =3D this._getItemsAsjQuery(o && o.connected),=0A=
			ret =3D [];=0A=
=0A=
		o =3D o || {};=0A=
=0A=
		items.each(function() { ret.push($(o.item || this).attr(o.attribute || =
"id") || ""); });=0A=
		return ret;=0A=
=0A=
	},=0A=
=0A=
	/* Be careful with the following core functions */=0A=
	_intersectsWith: function(item) {=0A=
=0A=
		var x1 =3D this.positionAbs.left,=0A=
			x2 =3D x1 + this.helperProportions.width,=0A=
			y1 =3D this.positionAbs.top,=0A=
			y2 =3D y1 + this.helperProportions.height,=0A=
			l =3D item.left,=0A=
			r =3D l + item.width,=0A=
			t =3D item.top,=0A=
			b =3D t + item.height,=0A=
			dyClick =3D this.offset.click.top,=0A=
			dxClick =3D this.offset.click.left,=0A=
			isOverElementHeight =3D ( this.options.axis =3D=3D=3D "x" ) || ( ( y1 =
+ dyClick ) > t && ( y1 + dyClick ) < b ),=0A=
			isOverElementWidth =3D ( this.options.axis =3D=3D=3D "y" ) || ( ( x1 =
+ dxClick ) > l && ( x1 + dxClick ) < r ),=0A=
			isOverElement =3D isOverElementHeight && isOverElementWidth;=0A=
=0A=
		if ( this.options.tolerance =3D=3D=3D "pointer" ||=0A=
			this.options.forcePointerForContainers ||=0A=
			(this.options.tolerance !=3D=3D "pointer" && =
this.helperProportions[this.floating ? "width" : "height"] > =
item[this.floating ? "width" : "height"])=0A=
		) {=0A=
			return isOverElement;=0A=
		} else {=0A=
=0A=
			return (l < x1 + (this.helperProportions.width / 2) && // Right Half=0A=
				x2 - (this.helperProportions.width / 2) < r && // Left Half=0A=
				t < y1 + (this.helperProportions.height / 2) && // Bottom Half=0A=
				y2 - (this.helperProportions.height / 2) < b ); // Top Half=0A=
=0A=
		}=0A=
	},=0A=
=0A=
	_intersectsWithPointer: function(item) {=0A=
=0A=
		var isOverElementHeight =3D (this.options.axis =3D=3D=3D "x") || =
this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, =
item.height),=0A=
			isOverElementWidth =3D (this.options.axis =3D=3D=3D "y") || =
this._isOverAxis(this.positionAbs.left + this.offset.click.left, =
item.left, item.width),=0A=
			isOverElement =3D isOverElementHeight && isOverElementWidth,=0A=
			verticalDirection =3D this._getDragVerticalDirection(),=0A=
			horizontalDirection =3D this._getDragHorizontalDirection();=0A=
=0A=
		if (!isOverElement) {=0A=
			return false;=0A=
		}=0A=
=0A=
		return this.floating ?=0A=
			( ((horizontalDirection && horizontalDirection =3D=3D=3D "right") || =
verticalDirection =3D=3D=3D "down") ? 2 : 1 )=0A=
			: ( verticalDirection && (verticalDirection =3D=3D=3D "down" ? 2 : 1) =
);=0A=
=0A=
	},=0A=
=0A=
	_intersectsWithSides: function(item) {=0A=
=0A=
		var isOverBottomHalf =3D this._isOverAxis(this.positionAbs.top + =
this.offset.click.top, item.top + (item.height/2), item.height),=0A=
			isOverRightHalf =3D this._isOverAxis(this.positionAbs.left + =
this.offset.click.left, item.left + (item.width/2), item.width),=0A=
			verticalDirection =3D this._getDragVerticalDirection(),=0A=
			horizontalDirection =3D this._getDragHorizontalDirection();=0A=
=0A=
		if (this.floating && horizontalDirection) {=0A=
			return ((horizontalDirection =3D=3D=3D "right" && isOverRightHalf) || =
(horizontalDirection =3D=3D=3D "left" && !isOverRightHalf));=0A=
		} else {=0A=
			return verticalDirection && ((verticalDirection =3D=3D=3D "down" && =
isOverBottomHalf) || (verticalDirection =3D=3D=3D "up" && =
!isOverBottomHalf));=0A=
		}=0A=
=0A=
	},=0A=
=0A=
	_getDragVerticalDirection: function() {=0A=
		var delta =3D this.positionAbs.top - this.lastPositionAbs.top;=0A=
		return delta !=3D=3D 0 && (delta > 0 ? "down" : "up");=0A=
	},=0A=
=0A=
	_getDragHorizontalDirection: function() {=0A=
		var delta =3D this.positionAbs.left - this.lastPositionAbs.left;=0A=
		return delta !=3D=3D 0 && (delta > 0 ? "right" : "left");=0A=
	},=0A=
=0A=
	refresh: function(event) {=0A=
		this._refreshItems(event);=0A=
		this._setHandleClassName();=0A=
		this.refreshPositions();=0A=
		return this;=0A=
	},=0A=
=0A=
	_connectWith: function() {=0A=
		var options =3D this.options;=0A=
		return options.connectWith.constructor =3D=3D=3D String ? =
[options.connectWith] : options.connectWith;=0A=
	},=0A=
=0A=
	_getItemsAsjQuery: function(connected) {=0A=
=0A=
		var i, j, cur, inst,=0A=
			items =3D [],=0A=
			queries =3D [],=0A=
			connectWith =3D this._connectWith();=0A=
=0A=
		if(connectWith && connected) {=0A=
			for (i =3D connectWith.length - 1; i >=3D 0; i--){=0A=
				cur =3D $(connectWith[i]);=0A=
				for ( j =3D cur.length - 1; j >=3D 0; j--){=0A=
					inst =3D $.data(cur[j], this.widgetFullName);=0A=
					if(inst && inst !=3D=3D this && !inst.options.disabled) {=0A=
						queries.push([$.isFunction(inst.options.items) ? =
inst.options.items.call(inst.element) : $(inst.options.items, =
inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),=
 inst]);=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		queries.push([$.isFunction(this.options.items) ? =
this.options.items.call(this.element, null, { options: this.options, =
item: this.currentItem }) : $(this.options.items, =
this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),=
 this]);=0A=
=0A=
		function addItems() {=0A=
			items.push( this );=0A=
		}=0A=
		for (i =3D queries.length - 1; i >=3D 0; i--){=0A=
			queries[i][0].each( addItems );=0A=
		}=0A=
=0A=
		return $(items);=0A=
=0A=
	},=0A=
=0A=
	_removeCurrentsFromItems: function() {=0A=
=0A=
		var list =3D this.currentItem.find(":data(" + this.widgetName + =
"-item)");=0A=
=0A=
		this.items =3D $.grep(this.items, function (item) {=0A=
			for (var j=3D0; j < list.length; j++) {=0A=
				if(list[j] =3D=3D=3D item.item[0]) {=0A=
					return false;=0A=
				}=0A=
			}=0A=
			return true;=0A=
		});=0A=
=0A=
	},=0A=
=0A=
	_refreshItems: function(event) {=0A=
=0A=
		this.items =3D [];=0A=
		this.containers =3D [this];=0A=
=0A=
		var i, j, cur, inst, targetData, _queries, item, queriesLength,=0A=
			items =3D this.items,=0A=
			queries =3D [[$.isFunction(this.options.items) ? =
this.options.items.call(this.element[0], event, { item: this.currentItem =
}) : $(this.options.items, this.element), this]],=0A=
			connectWith =3D this._connectWith();=0A=
=0A=
		if(connectWith && this.ready) { //Shouldn't be run the first time =
through due to massive slow-down=0A=
			for (i =3D connectWith.length - 1; i >=3D 0; i--){=0A=
				cur =3D $(connectWith[i]);=0A=
				for (j =3D cur.length - 1; j >=3D 0; j--){=0A=
					inst =3D $.data(cur[j], this.widgetFullName);=0A=
					if(inst && inst !=3D=3D this && !inst.options.disabled) {=0A=
						queries.push([$.isFunction(inst.options.items) ? =
inst.options.items.call(inst.element[0], event, { item: this.currentItem =
}) : $(inst.options.items, inst.element), inst]);=0A=
						this.containers.push(inst);=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		for (i =3D queries.length - 1; i >=3D 0; i--) {=0A=
			targetData =3D queries[i][1];=0A=
			_queries =3D queries[i][0];=0A=
=0A=
			for (j=3D0, queriesLength =3D _queries.length; j < queriesLength; =
j++) {=0A=
				item =3D $(_queries[j]);=0A=
=0A=
				item.data(this.widgetName + "-item", targetData); // Data for target =
checking (mouse manager)=0A=
=0A=
				items.push({=0A=
					item: item,=0A=
					instance: targetData,=0A=
					width: 0, height: 0,=0A=
					left: 0, top: 0=0A=
				});=0A=
			}=0A=
		}=0A=
=0A=
	},=0A=
=0A=
	refreshPositions: function(fast) {=0A=
=0A=
		//This has to be redone because due to the item being moved out/into =
the offsetParent, the offsetParent's position will change=0A=
		if(this.offsetParent && this.helper) {=0A=
			this.offset.parent =3D this._getParentOffset();=0A=
		}=0A=
=0A=
		var i, item, t, p;=0A=
=0A=
		for (i =3D this.items.length - 1; i >=3D 0; i--){=0A=
			item =3D this.items[i];=0A=
=0A=
			//We ignore calculating positions of all connected containers when =
we're not over them=0A=
			if(item.instance !=3D=3D this.currentContainer && =
this.currentContainer && item.item[0] !=3D=3D this.currentItem[0]) {=0A=
				continue;=0A=
			}=0A=
=0A=
			t =3D this.options.toleranceElement ? =
$(this.options.toleranceElement, item.item) : item.item;=0A=
=0A=
			if (!fast) {=0A=
				item.width =3D t.outerWidth();=0A=
				item.height =3D t.outerHeight();=0A=
			}=0A=
=0A=
			p =3D t.offset();=0A=
			item.left =3D p.left;=0A=
			item.top =3D p.top;=0A=
		}=0A=
=0A=
		if(this.options.custom && this.options.custom.refreshContainers) {=0A=
			this.options.custom.refreshContainers.call(this);=0A=
		} else {=0A=
			for (i =3D this.containers.length - 1; i >=3D 0; i--){=0A=
				p =3D this.containers[i].element.offset();=0A=
				this.containers[i].containerCache.left =3D p.left;=0A=
				this.containers[i].containerCache.top =3D p.top;=0A=
				this.containers[i].containerCache.width =3D =
this.containers[i].element.outerWidth();=0A=
				this.containers[i].containerCache.height =3D =
this.containers[i].element.outerHeight();=0A=
			}=0A=
		}=0A=
=0A=
		return this;=0A=
	},=0A=
=0A=
	_createPlaceholder: function(that) {=0A=
		that =3D that || this;=0A=
		var className,=0A=
			o =3D that.options;=0A=
=0A=
		if(!o.placeholder || o.placeholder.constructor =3D=3D=3D String) {=0A=
			className =3D o.placeholder;=0A=
			o.placeholder =3D {=0A=
				element: function() {=0A=
=0A=
					var nodeName =3D that.currentItem[0].nodeName.toLowerCase(),=0A=
						element =3D $( "<" + nodeName + ">", that.document[0] )=0A=
							.addClass(className || that.currentItem[0].className+" =
ui-sortable-placeholder")=0A=
							.removeClass("ui-sortable-helper");=0A=
=0A=
					if ( nodeName =3D=3D=3D "tr" ) {=0A=
						that.currentItem.children().each(function() {=0A=
							$( "<td>&#160;</td>", that.document[0] )=0A=
								.attr( "colspan", $( this ).attr( "colspan" ) || 1 )=0A=
								.appendTo( element );=0A=
						});=0A=
					} else if ( nodeName =3D=3D=3D "img" ) {=0A=
						element.attr( "src", that.currentItem.attr( "src" ) );=0A=
					}=0A=
=0A=
					if ( !className ) {=0A=
						element.css( "visibility", "hidden" );=0A=
					}=0A=
=0A=
					return element;=0A=
				},=0A=
				update: function(container, p) {=0A=
=0A=
					// 1. If a className is set as 'placeholder option, we don't force =
sizes - the class is responsible for that=0A=
					// 2. The option 'forcePlaceholderSize can be enabled to force it =
even if a class name is specified=0A=
					if(className && !o.forcePlaceholderSize) {=0A=
						return;=0A=
					}=0A=
=0A=
					//If the element doesn't have a actual height by itself (without =
styles coming from a stylesheet), it receives the inline height from the =
dragged item=0A=
					if(!p.height()) { p.height(that.currentItem.innerHeight() - =
parseInt(that.currentItem.css("paddingTop")||0, 10) - =
parseInt(that.currentItem.css("paddingBottom")||0, 10)); }=0A=
					if(!p.width()) { p.width(that.currentItem.innerWidth() - =
parseInt(that.currentItem.css("paddingLeft")||0, 10) - =
parseInt(that.currentItem.css("paddingRight")||0, 10)); }=0A=
				}=0A=
			};=0A=
		}=0A=
=0A=
		//Create the placeholder=0A=
		that.placeholder =3D $(o.placeholder.element.call(that.element, =
that.currentItem));=0A=
=0A=
		//Append it after the actual current item=0A=
		that.currentItem.after(that.placeholder);=0A=
=0A=
		//Update the size of the placeholder (TODO: Logic to fuzzy, see line =
316/317)=0A=
		o.placeholder.update(that, that.placeholder);=0A=
=0A=
	},=0A=
=0A=
	_contactContainers: function(event) {=0A=
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, =
nearBottom, floating, axis,=0A=
			innermostContainer =3D null,=0A=
			innermostIndex =3D null;=0A=
=0A=
		// get innermost container that intersects with item=0A=
		for (i =3D this.containers.length - 1; i >=3D 0; i--) {=0A=
=0A=
			// never consider a container that's located within the item itself=0A=
			if($.contains(this.currentItem[0], this.containers[i].element[0])) {=0A=
				continue;=0A=
			}=0A=
=0A=
			if(this._intersectsWith(this.containers[i].containerCache)) {=0A=
=0A=
				// if we've already found a container and it's more "inner" than =
this, then continue=0A=
				if(innermostContainer && $.contains(this.containers[i].element[0], =
innermostContainer.element[0])) {=0A=
					continue;=0A=
				}=0A=
=0A=
				innermostContainer =3D this.containers[i];=0A=
				innermostIndex =3D i;=0A=
=0A=
			} else {=0A=
				// container doesn't intersect. trigger "out" event if necessary=0A=
				if(this.containers[i].containerCache.over) {=0A=
					this.containers[i]._trigger("out", event, this._uiHash(this));=0A=
					this.containers[i].containerCache.over =3D 0;=0A=
				}=0A=
			}=0A=
=0A=
		}=0A=
=0A=
		// if no intersecting containers found, return=0A=
		if(!innermostContainer) {=0A=
			return;=0A=
		}=0A=
=0A=
		// move the item into the container if it's not there already=0A=
		if(this.containers.length =3D=3D=3D 1) {=0A=
			if (!this.containers[innermostIndex].containerCache.over) {=0A=
				this.containers[innermostIndex]._trigger("over", event, =
this._uiHash(this));=0A=
				this.containers[innermostIndex].containerCache.over =3D 1;=0A=
			}=0A=
		} else {=0A=
=0A=
			//When entering a new container, we will find the item with the least =
distance and append our item near it=0A=
			dist =3D 10000;=0A=
			itemWithLeastDistance =3D null;=0A=
			floating =3D innermostContainer.floating || =
this._isFloating(this.currentItem);=0A=
			posProperty =3D floating ? "left" : "top";=0A=
			sizeProperty =3D floating ? "width" : "height";=0A=
			axis =3D floating ? "clientX" : "clientY";=0A=
=0A=
			for (j =3D this.items.length - 1; j >=3D 0; j--) {=0A=
				if(!$.contains(this.containers[innermostIndex].element[0], =
this.items[j].item[0])) {=0A=
					continue;=0A=
				}=0A=
				if(this.items[j].item[0] =3D=3D=3D this.currentItem[0]) {=0A=
					continue;=0A=
				}=0A=
=0A=
				cur =3D this.items[j].item.offset()[posProperty];=0A=
				nearBottom =3D false;=0A=
				if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {=0A=
					nearBottom =3D true;=0A=
				}=0A=
=0A=
				if ( Math.abs( event[ axis ] - cur ) < dist ) {=0A=
					dist =3D Math.abs( event[ axis ] - cur );=0A=
					itemWithLeastDistance =3D this.items[ j ];=0A=
					this.direction =3D nearBottom ? "up": "down";=0A=
				}=0A=
			}=0A=
=0A=
			//Check if dropOnEmpty is enabled=0A=
			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {=0A=
				return;=0A=
			}=0A=
=0A=
			if(this.currentContainer =3D=3D=3D this.containers[innermostIndex]) {=0A=
				return;=0A=
			}=0A=
=0A=
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, =
null, true) : this._rearrange(event, null, =
this.containers[innermostIndex].element, true);=0A=
			this._trigger("change", event, this._uiHash());=0A=
			this.containers[innermostIndex]._trigger("change", event, =
this._uiHash(this));=0A=
			this.currentContainer =3D this.containers[innermostIndex];=0A=
=0A=
			//Update the placeholder=0A=
			this.options.placeholder.update(this.currentContainer, =
this.placeholder);=0A=
=0A=
			this.containers[innermostIndex]._trigger("over", event, =
this._uiHash(this));=0A=
			this.containers[innermostIndex].containerCache.over =3D 1;=0A=
		}=0A=
=0A=
=0A=
	},=0A=
=0A=
	_createHelper: function(event) {=0A=
=0A=
		var o =3D this.options,=0A=
			helper =3D $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], =
[event, this.currentItem])) : (o.helper =3D=3D=3D "clone" ? =
this.currentItem.clone() : this.currentItem);=0A=
=0A=
		//Add the helper to the DOM if that didn't happen already=0A=
		if(!helper.parents("body").length) {=0A=
			$(o.appendTo !=3D=3D "parent" ? o.appendTo : =
this.currentItem[0].parentNode)[0].appendChild(helper[0]);=0A=
		}=0A=
=0A=
		if(helper[0] =3D=3D=3D this.currentItem[0]) {=0A=
			this._storedCSS =3D { width: this.currentItem[0].style.width, height: =
this.currentItem[0].style.height, position: =
this.currentItem.css("position"), top: this.currentItem.css("top"), =
left: this.currentItem.css("left") };=0A=
		}=0A=
=0A=
		if(!helper[0].style.width || o.forceHelperSize) {=0A=
			helper.width(this.currentItem.width());=0A=
		}=0A=
		if(!helper[0].style.height || o.forceHelperSize) {=0A=
			helper.height(this.currentItem.height());=0A=
		}=0A=
=0A=
		return helper;=0A=
=0A=
	},=0A=
=0A=
	_adjustOffsetFromHelper: function(obj) {=0A=
		if (typeof obj =3D=3D=3D "string") {=0A=
			obj =3D obj.split(" ");=0A=
		}=0A=
		if ($.isArray(obj)) {=0A=
			obj =3D {left: +obj[0], top: +obj[1] || 0};=0A=
		}=0A=
		if ("left" in obj) {=0A=
			this.offset.click.left =3D obj.left + this.margins.left;=0A=
		}=0A=
		if ("right" in obj) {=0A=
			this.offset.click.left =3D this.helperProportions.width - obj.right + =
this.margins.left;=0A=
		}=0A=
		if ("top" in obj) {=0A=
			this.offset.click.top =3D obj.top + this.margins.top;=0A=
		}=0A=
		if ("bottom" in obj) {=0A=
			this.offset.click.top =3D this.helperProportions.height - obj.bottom =
+ this.margins.top;=0A=
		}=0A=
	},=0A=
=0A=
	_getParentOffset: function() {=0A=
=0A=
=0A=
		//Get the offsetParent and cache its position=0A=
		this.offsetParent =3D this.helper.offsetParent();=0A=
		var po =3D this.offsetParent.offset();=0A=
=0A=
		// This is a special case where we need to modify a offset calculated =
on start, since the following happened:=0A=
		// 1. The position of the helper is absolute, so it's position is =
calculated based on the next positioned parent=0A=
		// 2. The actual offset parent is a child of the scroll parent, and =
the scroll parent isn't the document, which means that=0A=
		//    the scroll is included in the initial calculation of the offset =
of the parent, and never recalculated upon drag=0A=
		if(this.cssPosition =3D=3D=3D "absolute" && this.scrollParent[0] =
!=3D=3D document && $.contains(this.scrollParent[0], =
this.offsetParent[0])) {=0A=
			po.left +=3D this.scrollParent.scrollLeft();=0A=
			po.top +=3D this.scrollParent.scrollTop();=0A=
		}=0A=
=0A=
		// This needs to be actually done for all browsers, since pageX/pageY =
includes this information=0A=
		// with an ugly IE fix=0A=
		if( this.offsetParent[0] =3D=3D=3D document.body || =
(this.offsetParent[0].tagName && =
this.offsetParent[0].tagName.toLowerCase() =3D=3D=3D "html" && $.ui.ie)) =
{=0A=
			po =3D { top: 0, left: 0 };=0A=
		}=0A=
=0A=
		return {=0A=
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) =
|| 0),=0A=
			left: po.left + =
(parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)=0A=
		};=0A=
=0A=
	},=0A=
=0A=
	_getRelativeOffset: function() {=0A=
=0A=
		if(this.cssPosition =3D=3D=3D "relative") {=0A=
			var p =3D this.currentItem.position();=0A=
			return {=0A=
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + =
this.scrollParent.scrollTop(),=0A=
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + =
this.scrollParent.scrollLeft()=0A=
			};=0A=
		} else {=0A=
			return { top: 0, left: 0 };=0A=
		}=0A=
=0A=
	},=0A=
=0A=
	_cacheMargins: function() {=0A=
		this.margins =3D {=0A=
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),=0A=
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)=0A=
		};=0A=
	},=0A=
=0A=
	_cacheHelperProportions: function() {=0A=
		this.helperProportions =3D {=0A=
			width: this.helper.outerWidth(),=0A=
			height: this.helper.outerHeight()=0A=
		};=0A=
	},=0A=
=0A=
	_setContainment: function() {=0A=
=0A=
		var ce, co, over,=0A=
			o =3D this.options;=0A=
		if(o.containment =3D=3D=3D "parent") {=0A=
			o.containment =3D this.helper[0].parentNode;=0A=
		}=0A=
		if(o.containment =3D=3D=3D "document" || o.containment =3D=3D=3D =
"window") {=0A=
			this.containment =3D [=0A=
				0 - this.offset.relative.left - this.offset.parent.left,=0A=
				0 - this.offset.relative.top - this.offset.parent.top,=0A=
				$(o.containment =3D=3D=3D "document" ? document : window).width() - =
this.helperProportions.width - this.margins.left,=0A=
				($(o.containment =3D=3D=3D "document" ? document : window).height() =
|| document.body.parentNode.scrollHeight) - =
this.helperProportions.height - this.margins.top=0A=
			];=0A=
		}=0A=
=0A=
		if(!(/^(document|window|parent)$/).test(o.containment)) {=0A=
			ce =3D $(o.containment)[0];=0A=
			co =3D $(o.containment).offset();=0A=
			over =3D ($(ce).css("overflow") !=3D=3D "hidden");=0A=
=0A=
			this.containment =3D [=0A=
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + =
(parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,=0A=
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + =
(parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,=0A=
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : =
ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - =
(parseInt($(ce).css("paddingRight"),10) || 0) - =
this.helperProportions.width - this.margins.left,=0A=
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : =
ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - =
(parseInt($(ce).css("paddingBottom"),10) || 0) - =
this.helperProportions.height - this.margins.top=0A=
			];=0A=
		}=0A=
=0A=
	},=0A=
=0A=
	_convertPositionTo: function(d, pos) {=0A=
=0A=
		if(!pos) {=0A=
			pos =3D this.position;=0A=
		}=0A=
		var mod =3D d =3D=3D=3D "absolute" ? 1 : -1,=0A=
			scroll =3D this.cssPosition =3D=3D=3D "absolute" && =
!(this.scrollParent[0] !=3D=3D document && =
$.contains(this.scrollParent[0], this.offsetParent[0])) ? =
this.offsetParent : this.scrollParent,=0A=
			scrollIsRootNode =3D (/(html|body)/i).test(scroll[0].tagName);=0A=
=0A=
		return {=0A=
			top: (=0A=
				pos.top	+																// The absolute mouse position=0A=
				this.offset.relative.top * mod +										// Only for relative =
positioned nodes: Relative offset from element to offset parent=0A=
				this.offset.parent.top * mod -											// The offsetParent's =
offset without borders (offset + border)=0A=
				( ( this.cssPosition =3D=3D=3D "fixed" ? =
-this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : =
scroll.scrollTop() ) ) * mod)=0A=
			),=0A=
			left: (=0A=
				pos.left +																// The absolute mouse position=0A=
				this.offset.relative.left * mod +										// Only for relative =
positioned nodes: Relative offset from element to offset parent=0A=
				this.offset.parent.left * mod	-										// The offsetParent's =
offset without borders (offset + border)=0A=
				( ( this.cssPosition =3D=3D=3D "fixed" ? =
-this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : =
scroll.scrollLeft() ) * mod)=0A=
			)=0A=
		};=0A=
=0A=
	},=0A=
=0A=
	_generatePosition: function(event) {=0A=
=0A=
		var top, left,=0A=
			o =3D this.options,=0A=
			pageX =3D event.pageX,=0A=
			pageY =3D event.pageY,=0A=
			scroll =3D this.cssPosition =3D=3D=3D "absolute" && =
!(this.scrollParent[0] !=3D=3D document && =
$.contains(this.scrollParent[0], this.offsetParent[0])) ? =
this.offsetParent : this.scrollParent, scrollIsRootNode =3D =
(/(html|body)/i).test(scroll[0].tagName);=0A=
=0A=
		// This is another very weird special case that only happens for =
relative elements:=0A=
		// 1. If the css position is relative=0A=
		// 2. and the scroll parent is the document or similar to the offset =
parent=0A=
		// we have to refresh the relative offset during the scroll so there =
are no jumps=0A=
		if(this.cssPosition =3D=3D=3D "relative" && !(this.scrollParent[0] =
!=3D=3D document && this.scrollParent[0] !=3D=3D this.offsetParent[0])) {=0A=
			this.offset.relative =3D this._getRelativeOffset();=0A=
		}=0A=
=0A=
		/*=0A=
		 * - Position constraining -=0A=
		 * Constrain the position to a mix of grid, containment.=0A=
		 */=0A=
=0A=
		if(this.originalPosition) { //If we are not dragging yet, we won't =
check for options=0A=
=0A=
			if(this.containment) {=0A=
				if(event.pageX - this.offset.click.left < this.containment[0]) {=0A=
					pageX =3D this.containment[0] + this.offset.click.left;=0A=
				}=0A=
				if(event.pageY - this.offset.click.top < this.containment[1]) {=0A=
					pageY =3D this.containment[1] + this.offset.click.top;=0A=
				}=0A=
				if(event.pageX - this.offset.click.left > this.containment[2]) {=0A=
					pageX =3D this.containment[2] + this.offset.click.left;=0A=
				}=0A=
				if(event.pageY - this.offset.click.top > this.containment[3]) {=0A=
					pageY =3D this.containment[3] + this.offset.click.top;=0A=
				}=0A=
			}=0A=
=0A=
			if(o.grid) {=0A=
				top =3D this.originalPageY + Math.round((pageY - this.originalPageY) =
/ o.grid[1]) * o.grid[1];=0A=
				pageY =3D this.containment ? ( (top - this.offset.click.top >=3D =
this.containment[1] && top - this.offset.click.top <=3D =
this.containment[3]) ? top : ((top - this.offset.click.top >=3D =
this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;=0A=
=0A=
				left =3D this.originalPageX + Math.round((pageX - =
this.originalPageX) / o.grid[0]) * o.grid[0];=0A=
				pageX =3D this.containment ? ( (left - this.offset.click.left >=3D =
this.containment[0] && left - this.offset.click.left <=3D =
this.containment[2]) ? left : ((left - this.offset.click.left >=3D =
this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;=0A=
			}=0A=
=0A=
		}=0A=
=0A=
		return {=0A=
			top: (=0A=
				pageY -																// The absolute mouse position=0A=
				this.offset.click.top -													// Click offset (relative to the =
element)=0A=
				this.offset.relative.top	-											// Only for relative positioned =
nodes: Relative offset from element to offset parent=0A=
				this.offset.parent.top +												// The offsetParent's offset =
without borders (offset + border)=0A=
				( ( this.cssPosition =3D=3D=3D "fixed" ? =
-this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : =
scroll.scrollTop() ) ))=0A=
			),=0A=
			left: (=0A=
				pageX -																// The absolute mouse position=0A=
				this.offset.click.left -												// Click offset (relative to the =
element)=0A=
				this.offset.relative.left	-											// Only for relative =
positioned nodes: Relative offset from element to offset parent=0A=
				this.offset.parent.left +												// The offsetParent's offset =
without borders (offset + border)=0A=
				( ( this.cssPosition =3D=3D=3D "fixed" ? =
-this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : =
scroll.scrollLeft() ))=0A=
			)=0A=
		};=0A=
=0A=
	},=0A=
=0A=
	_rearrange: function(event, i, a, hardRefresh) {=0A=
=0A=
		a ? a[0].appendChild(this.placeholder[0]) : =
i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction =
=3D=3D=3D "down" ? i.item[0] : i.item[0].nextSibling));=0A=
=0A=
		//Various things done here to improve the performance:=0A=
		// 1. we create a setTimeout, that calls refreshPositions=0A=
		// 2. on the instance, we have a counter variable, that get's higher =
after every append=0A=
		// 3. on the local scope, we copy the counter variable, and check in =
the timeout, if it's still the same=0A=
		// 4. this lets only the last addition to the timeout stack through=0A=
		this.counter =3D this.counter ? ++this.counter : 1;=0A=
		var counter =3D this.counter;=0A=
=0A=
		this._delay(function() {=0A=
			if(counter =3D=3D=3D this.counter) {=0A=
				this.refreshPositions(!hardRefresh); //Precompute after each DOM =
insertion, NOT on mousemove=0A=
			}=0A=
		});=0A=
=0A=
	},=0A=
=0A=
	_clear: function(event, noPropagation) {=0A=
=0A=
		this.reverting =3D false;=0A=
		// We delay all events that have to be triggered to after the point =
where the placeholder has been removed and=0A=
		// everything else normalized again=0A=
		var i,=0A=
			delayedTriggers =3D [];=0A=
=0A=
		// We first have to update the dom position of the actual currentItem=0A=
		// Note: don't do it if the current item is already removed (by a =
user), or it gets reappended (see #4088)=0A=
		if(!this._noFinalSort && this.currentItem.parent().length) {=0A=
			this.placeholder.before(this.currentItem);=0A=
		}=0A=
		this._noFinalSort =3D null;=0A=
=0A=
		if(this.helper[0] =3D=3D=3D this.currentItem[0]) {=0A=
			for(i in this._storedCSS) {=0A=
				if(this._storedCSS[i] =3D=3D=3D "auto" || this._storedCSS[i] =
=3D=3D=3D "static") {=0A=
					this._storedCSS[i] =3D "";=0A=
				}=0A=
			}=0A=
			=
this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");=0A=
		} else {=0A=
			this.currentItem.show();=0A=
		}=0A=
=0A=
		if(this.fromOutside && !noPropagation) {=0A=
			delayedTriggers.push(function(event) { this._trigger("receive", =
event, this._uiHash(this.fromOutside)); });=0A=
		}=0A=
		if((this.fromOutside || this.domPosition.prev !=3D=3D =
this.currentItem.prev().not(".ui-sortable-helper")[0] || =
this.domPosition.parent !=3D=3D this.currentItem.parent()[0]) && =
!noPropagation) {=0A=
			delayedTriggers.push(function(event) { this._trigger("update", event, =
this._uiHash()); }); //Trigger update callback if the DOM position has =
changed=0A=
		}=0A=
=0A=
		// Check if the items Container has Changed and trigger appropriate=0A=
		// events.=0A=
		if (this !=3D=3D this.currentContainer) {=0A=
			if(!noPropagation) {=0A=
				delayedTriggers.push(function(event) { this._trigger("remove", =
event, this._uiHash()); });=0A=
				delayedTriggers.push((function(c) { return function(event) { =
c._trigger("receive", event, this._uiHash(this)); };  }).call(this, =
this.currentContainer));=0A=
				delayedTriggers.push((function(c) { return function(event) { =
c._trigger("update", event, this._uiHash(this));  }; }).call(this, =
this.currentContainer));=0A=
			}=0A=
		}=0A=
=0A=
=0A=
		//Post events to containers=0A=
		function delayEvent( type, instance, container ) {=0A=
			return function( event ) {=0A=
				container._trigger( type, event, instance._uiHash( instance ) );=0A=
			};=0A=
		}=0A=
		for (i =3D this.containers.length - 1; i >=3D 0; i--){=0A=
			if (!noPropagation) {=0A=
				delayedTriggers.push( delayEvent( "deactivate", this, =
this.containers[ i ] ) );=0A=
			}=0A=
			if(this.containers[i].containerCache.over) {=0A=
				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] =
) );=0A=
				this.containers[i].containerCache.over =3D 0;=0A=
			}=0A=
		}=0A=
=0A=
		//Do what was originally in plugins=0A=
		if ( this.storedCursor ) {=0A=
			this.document.find( "body" ).css( "cursor", this.storedCursor );=0A=
			this.storedStylesheet.remove();=0A=
		}=0A=
		if(this._storedOpacity) {=0A=
			this.helper.css("opacity", this._storedOpacity);=0A=
		}=0A=
		if(this._storedZIndex) {=0A=
			this.helper.css("zIndex", this._storedZIndex =3D=3D=3D "auto" ? "" : =
this._storedZIndex);=0A=
		}=0A=
=0A=
		this.dragging =3D false;=0A=
		if(this.cancelHelperRemoval) {=0A=
			if(!noPropagation) {=0A=
				this._trigger("beforeStop", event, this._uiHash());=0A=
				for (i=3D0; i < delayedTriggers.length; i++) {=0A=
					delayedTriggers[i].call(this, event);=0A=
				} //Trigger all delayed events=0A=
				this._trigger("stop", event, this._uiHash());=0A=
			}=0A=
=0A=
			this.fromOutside =3D false;=0A=
			return false;=0A=
		}=0A=
=0A=
		if(!noPropagation) {=0A=
			this._trigger("beforeStop", event, this._uiHash());=0A=
		}=0A=
=0A=
		//$(this.placeholder[0]).remove(); would have been the jQuery way - =
unfortunately, it unbinds ALL events from the original node!=0A=
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);=0A=
=0A=
		if(this.helper[0] !=3D=3D this.currentItem[0]) {=0A=
			this.helper.remove();=0A=
		}=0A=
		this.helper =3D null;=0A=
=0A=
		if(!noPropagation) {=0A=
			for (i=3D0; i < delayedTriggers.length; i++) {=0A=
				delayedTriggers[i].call(this, event);=0A=
			} //Trigger all delayed events=0A=
			this._trigger("stop", event, this._uiHash());=0A=
		}=0A=
=0A=
		this.fromOutside =3D false;=0A=
		return true;=0A=
=0A=
	},=0A=
=0A=
	_trigger: function() {=0A=
		if ($.Widget.prototype._trigger.apply(this, arguments) =3D=3D=3D =
false) {=0A=
			this.cancel();=0A=
		}=0A=
	},=0A=
=0A=
	_uiHash: function(_inst) {=0A=
		var inst =3D _inst || this;=0A=
		return {=0A=
			helper: inst.helper,=0A=
			placeholder: inst.placeholder || $([]),=0A=
			position: inst.position,=0A=
			originalPosition: inst.originalPosition,=0A=
			offset: inst.positionAbs,=0A=
			item: inst.currentItem,=0A=
			sender: _inst ? _inst.element : null=0A=
		};=0A=
	}=0A=
=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Accordion 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/accordion/=0A=
 */=0A=
=0A=
=0A=
var accordion =3D $.widget( "ui.accordion", {=0A=
	version: "1.11.1",=0A=
	options: {=0A=
		active: 0,=0A=
		animate: {},=0A=
		collapsible: false,=0A=
		event: "click",=0A=
		header: "> li > :first-child,> :not(li):even",=0A=
		heightStyle: "auto",=0A=
		icons: {=0A=
			activeHeader: "ui-icon-triangle-1-s",=0A=
			header: "ui-icon-triangle-1-e"=0A=
		},=0A=
=0A=
		// callbacks=0A=
		activate: null,=0A=
		beforeActivate: null=0A=
	},=0A=
=0A=
	hideProps: {=0A=
		borderTopWidth: "hide",=0A=
		borderBottomWidth: "hide",=0A=
		paddingTop: "hide",=0A=
		paddingBottom: "hide",=0A=
		height: "hide"=0A=
	},=0A=
=0A=
	showProps: {=0A=
		borderTopWidth: "show",=0A=
		borderBottomWidth: "show",=0A=
		paddingTop: "show",=0A=
		paddingBottom: "show",=0A=
		height: "show"=0A=
	},=0A=
=0A=
	_create: function() {=0A=
		var options =3D this.options;=0A=
		this.prevShow =3D this.prevHide =3D $();=0A=
		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )=0A=
			// ARIA=0A=
			.attr( "role", "tablist" );=0A=
=0A=
		// don't allow collapsible: false and active: false / null=0A=
		if ( !options.collapsible && (options.active =3D=3D=3D false || =
options.active =3D=3D null) ) {=0A=
			options.active =3D 0;=0A=
		}=0A=
=0A=
		this._processPanels();=0A=
		// handle negative values=0A=
		if ( options.active < 0 ) {=0A=
			options.active +=3D this.headers.length;=0A=
		}=0A=
		this._refresh();=0A=
	},=0A=
=0A=
	_getCreateEventData: function() {=0A=
		return {=0A=
			header: this.active,=0A=
			panel: !this.active.length ? $() : this.active.next()=0A=
		};=0A=
	},=0A=
=0A=
	_createIcons: function() {=0A=
		var icons =3D this.options.icons;=0A=
		if ( icons ) {=0A=
			$( "<span>" )=0A=
				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )=0A=
				.prependTo( this.headers );=0A=
			this.active.children( ".ui-accordion-header-icon" )=0A=
				.removeClass( icons.header )=0A=
				.addClass( icons.activeHeader );=0A=
			this.headers.addClass( "ui-accordion-icons" );=0A=
		}=0A=
	},=0A=
=0A=
	_destroyIcons: function() {=0A=
		this.headers=0A=
			.removeClass( "ui-accordion-icons" )=0A=
			.children( ".ui-accordion-header-icon" )=0A=
				.remove();=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		var contents;=0A=
=0A=
		// clean up main element=0A=
		this.element=0A=
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )=0A=
			.removeAttr( "role" );=0A=
=0A=
		// clean up headers=0A=
		this.headers=0A=
			.removeClass( "ui-accordion-header ui-accordion-header-active =
ui-state-default " +=0A=
				"ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )=0A=
			.removeAttr( "role" )=0A=
			.removeAttr( "aria-expanded" )=0A=
			.removeAttr( "aria-selected" )=0A=
			.removeAttr( "aria-controls" )=0A=
			.removeAttr( "tabIndex" )=0A=
			.removeUniqueId();=0A=
=0A=
		this._destroyIcons();=0A=
=0A=
		// clean up content panels=0A=
		contents =3D this.headers.next()=0A=
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom " +=0A=
				"ui-accordion-content ui-accordion-content-active ui-state-disabled" =
)=0A=
			.css( "display", "" )=0A=
			.removeAttr( "role" )=0A=
			.removeAttr( "aria-hidden" )=0A=
			.removeAttr( "aria-labelledby" )=0A=
			.removeUniqueId();=0A=
=0A=
		if ( this.options.heightStyle !=3D=3D "content" ) {=0A=
			contents.css( "height", "" );=0A=
		}=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		if ( key =3D=3D=3D "active" ) {=0A=
			// _activate() will handle invalid values and update this.options=0A=
			this._activate( value );=0A=
			return;=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "event" ) {=0A=
			if ( this.options.event ) {=0A=
				this._off( this.headers, this.options.event );=0A=
			}=0A=
			this._setupEvents( value );=0A=
		}=0A=
=0A=
		this._super( key, value );=0A=
=0A=
		// setting collapsible: false while collapsed; open first panel=0A=
		if ( key =3D=3D=3D "collapsible" && !value && this.options.active =
=3D=3D=3D false ) {=0A=
			this._activate( 0 );=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "icons" ) {=0A=
			this._destroyIcons();=0A=
			if ( value ) {=0A=
				this._createIcons();=0A=
			}=0A=
		}=0A=
=0A=
		// #5332 - opacity doesn't cascade to positioned elements in IE=0A=
		// so we need to add the disabled class to the headers and panels=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			this.element=0A=
				.toggleClass( "ui-state-disabled", !!value )=0A=
				.attr( "aria-disabled", value );=0A=
			this.headers.add( this.headers.next() )=0A=
				.toggleClass( "ui-state-disabled", !!value );=0A=
		}=0A=
	},=0A=
=0A=
	_keydown: function( event ) {=0A=
		if ( event.altKey || event.ctrlKey ) {=0A=
			return;=0A=
		}=0A=
=0A=
		var keyCode =3D $.ui.keyCode,=0A=
			length =3D this.headers.length,=0A=
			currentIndex =3D this.headers.index( event.target ),=0A=
			toFocus =3D false;=0A=
=0A=
		switch ( event.keyCode ) {=0A=
			case keyCode.RIGHT:=0A=
			case keyCode.DOWN:=0A=
				toFocus =3D this.headers[ ( currentIndex + 1 ) % length ];=0A=
				break;=0A=
			case keyCode.LEFT:=0A=
			case keyCode.UP:=0A=
				toFocus =3D this.headers[ ( currentIndex - 1 + length ) % length ];=0A=
				break;=0A=
			case keyCode.SPACE:=0A=
			case keyCode.ENTER:=0A=
				this._eventHandler( event );=0A=
				break;=0A=
			case keyCode.HOME:=0A=
				toFocus =3D this.headers[ 0 ];=0A=
				break;=0A=
			case keyCode.END:=0A=
				toFocus =3D this.headers[ length - 1 ];=0A=
				break;=0A=
		}=0A=
=0A=
		if ( toFocus ) {=0A=
			$( event.target ).attr( "tabIndex", -1 );=0A=
			$( toFocus ).attr( "tabIndex", 0 );=0A=
			toFocus.focus();=0A=
			event.preventDefault();=0A=
		}=0A=
	},=0A=
=0A=
	_panelKeyDown: function( event ) {=0A=
		if ( event.keyCode =3D=3D=3D $.ui.keyCode.UP && event.ctrlKey ) {=0A=
			$( event.currentTarget ).prev().focus();=0A=
		}=0A=
	},=0A=
=0A=
	refresh: function() {=0A=
		var options =3D this.options;=0A=
		this._processPanels();=0A=
=0A=
		// was collapsed or no panel=0A=
		if ( ( options.active =3D=3D=3D false && options.collapsible =3D=3D=3D =
true ) || !this.headers.length ) {=0A=
			options.active =3D false;=0A=
			this.active =3D $();=0A=
		// active false only when collapsible is true=0A=
		} else if ( options.active =3D=3D=3D false ) {=0A=
			this._activate( 0 );=0A=
		// was active, but active panel is gone=0A=
		} else if ( this.active.length && !$.contains( this.element[ 0 ], =
this.active[ 0 ] ) ) {=0A=
			// all remaining panel are disabled=0A=
			if ( this.headers.length =3D=3D=3D =
this.headers.find(".ui-state-disabled").length ) {=0A=
				options.active =3D false;=0A=
				this.active =3D $();=0A=
			// activate previous panel=0A=
			} else {=0A=
				this._activate( Math.max( 0, options.active - 1 ) );=0A=
			}=0A=
		// was active, active panel still exists=0A=
		} else {=0A=
			// make sure active index is correct=0A=
			options.active =3D this.headers.index( this.active );=0A=
		}=0A=
=0A=
		this._destroyIcons();=0A=
=0A=
		this._refresh();=0A=
	},=0A=
=0A=
	_processPanels: function() {=0A=
		this.headers =3D this.element.find( this.options.header )=0A=
			.addClass( "ui-accordion-header ui-state-default ui-corner-all" );=0A=
=0A=
		this.headers.next()=0A=
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content =
ui-corner-bottom" )=0A=
			.filter( ":not(.ui-accordion-content-active)" )=0A=
			.hide();=0A=
	},=0A=
=0A=
	_refresh: function() {=0A=
		var maxHeight,=0A=
			options =3D this.options,=0A=
			heightStyle =3D options.heightStyle,=0A=
			parent =3D this.element.parent();=0A=
=0A=
		this.active =3D this._findActive( options.active )=0A=
			.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" =
)=0A=
			.removeClass( "ui-corner-all" );=0A=
		this.active.next()=0A=
			.addClass( "ui-accordion-content-active" )=0A=
			.show();=0A=
=0A=
		this.headers=0A=
			.attr( "role", "tab" )=0A=
			.each(function() {=0A=
				var header =3D $( this ),=0A=
					headerId =3D header.uniqueId().attr( "id" ),=0A=
					panel =3D header.next(),=0A=
					panelId =3D panel.uniqueId().attr( "id" );=0A=
				header.attr( "aria-controls", panelId );=0A=
				panel.attr( "aria-labelledby", headerId );=0A=
			})=0A=
			.next()=0A=
				.attr( "role", "tabpanel" );=0A=
=0A=
		this.headers=0A=
			.not( this.active )=0A=
			.attr({=0A=
				"aria-selected": "false",=0A=
				"aria-expanded": "false",=0A=
				tabIndex: -1=0A=
			})=0A=
			.next()=0A=
				.attr({=0A=
					"aria-hidden": "true"=0A=
				})=0A=
				.hide();=0A=
=0A=
		// make sure at least one header is in the tab order=0A=
		if ( !this.active.length ) {=0A=
			this.headers.eq( 0 ).attr( "tabIndex", 0 );=0A=
		} else {=0A=
			this.active.attr({=0A=
				"aria-selected": "true",=0A=
				"aria-expanded": "true",=0A=
				tabIndex: 0=0A=
			})=0A=
			.next()=0A=
				.attr({=0A=
					"aria-hidden": "false"=0A=
				});=0A=
		}=0A=
=0A=
		this._createIcons();=0A=
=0A=
		this._setupEvents( options.event );=0A=
=0A=
		if ( heightStyle =3D=3D=3D "fill" ) {=0A=
			maxHeight =3D parent.height();=0A=
			this.element.siblings( ":visible" ).each(function() {=0A=
				var elem =3D $( this ),=0A=
					position =3D elem.css( "position" );=0A=
=0A=
				if ( position =3D=3D=3D "absolute" || position =3D=3D=3D "fixed" ) {=0A=
					return;=0A=
				}=0A=
				maxHeight -=3D elem.outerHeight( true );=0A=
			});=0A=
=0A=
			this.headers.each(function() {=0A=
				maxHeight -=3D $( this ).outerHeight( true );=0A=
			});=0A=
=0A=
			this.headers.next()=0A=
				.each(function() {=0A=
					$( this ).height( Math.max( 0, maxHeight -=0A=
						$( this ).innerHeight() + $( this ).height() ) );=0A=
				})=0A=
				.css( "overflow", "auto" );=0A=
		} else if ( heightStyle =3D=3D=3D "auto" ) {=0A=
			maxHeight =3D 0;=0A=
			this.headers.next()=0A=
				.each(function() {=0A=
					maxHeight =3D Math.max( maxHeight, $( this ).css( "height", "" =
).height() );=0A=
				})=0A=
				.height( maxHeight );=0A=
		}=0A=
	},=0A=
=0A=
	_activate: function( index ) {=0A=
		var active =3D this._findActive( index )[ 0 ];=0A=
=0A=
		// trying to activate the already active panel=0A=
		if ( active =3D=3D=3D this.active[ 0 ] ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// trying to collapse, simulate a click on the currently active header=0A=
		active =3D active || this.active[ 0 ];=0A=
=0A=
		this._eventHandler({=0A=
			target: active,=0A=
			currentTarget: active,=0A=
			preventDefault: $.noop=0A=
		});=0A=
	},=0A=
=0A=
	_findActive: function( selector ) {=0A=
		return typeof selector =3D=3D=3D "number" ? this.headers.eq( selector =
) : $();=0A=
	},=0A=
=0A=
	_setupEvents: function( event ) {=0A=
		var events =3D {=0A=
			keydown: "_keydown"=0A=
		};=0A=
		if ( event ) {=0A=
			$.each( event.split( " " ), function( index, eventName ) {=0A=
				events[ eventName ] =3D "_eventHandler";=0A=
			});=0A=
		}=0A=
=0A=
		this._off( this.headers.add( this.headers.next() ) );=0A=
		this._on( this.headers, events );=0A=
		this._on( this.headers.next(), { keydown: "_panelKeyDown" });=0A=
		this._hoverable( this.headers );=0A=
		this._focusable( this.headers );=0A=
	},=0A=
=0A=
	_eventHandler: function( event ) {=0A=
		var options =3D this.options,=0A=
			active =3D this.active,=0A=
			clicked =3D $( event.currentTarget ),=0A=
			clickedIsActive =3D clicked[ 0 ] =3D=3D=3D active[ 0 ],=0A=
			collapsing =3D clickedIsActive && options.collapsible,=0A=
			toShow =3D collapsing ? $() : clicked.next(),=0A=
			toHide =3D active.next(),=0A=
			eventData =3D {=0A=
				oldHeader: active,=0A=
				oldPanel: toHide,=0A=
				newHeader: collapsing ? $() : clicked,=0A=
				newPanel: toShow=0A=
			};=0A=
=0A=
		event.preventDefault();=0A=
=0A=
		if (=0A=
				// click on active header, but not collapsible=0A=
				( clickedIsActive && !options.collapsible ) ||=0A=
				// allow canceling activation=0A=
				( this._trigger( "beforeActivate", event, eventData ) =3D=3D=3D =
false ) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		options.active =3D collapsing ? false : this.headers.index( clicked );=0A=
=0A=
		// when the call to ._toggle() comes after the class changes=0A=
		// it causes a very odd bug in IE 8 (see #6720)=0A=
		this.active =3D clickedIsActive ? $() : clicked;=0A=
		this._toggle( eventData );=0A=
=0A=
		// switch classes=0A=
		// corner classes on the previously active header stay after the =
animation=0A=
		active.removeClass( "ui-accordion-header-active ui-state-active" );=0A=
		if ( options.icons ) {=0A=
			active.children( ".ui-accordion-header-icon" )=0A=
				.removeClass( options.icons.activeHeader )=0A=
				.addClass( options.icons.header );=0A=
		}=0A=
=0A=
		if ( !clickedIsActive ) {=0A=
			clicked=0A=
				.removeClass( "ui-corner-all" )=0A=
				.addClass( "ui-accordion-header-active ui-state-active =
ui-corner-top" );=0A=
			if ( options.icons ) {=0A=
				clicked.children( ".ui-accordion-header-icon" )=0A=
					.removeClass( options.icons.header )=0A=
					.addClass( options.icons.activeHeader );=0A=
			}=0A=
=0A=
			clicked=0A=
				.next()=0A=
				.addClass( "ui-accordion-content-active" );=0A=
		}=0A=
	},=0A=
=0A=
	_toggle: function( data ) {=0A=
		var toShow =3D data.newPanel,=0A=
			toHide =3D this.prevShow.length ? this.prevShow : data.oldPanel;=0A=
=0A=
		// handle activating a panel during the animation for another =
activation=0A=
		this.prevShow.add( this.prevHide ).stop( true, true );=0A=
		this.prevShow =3D toShow;=0A=
		this.prevHide =3D toHide;=0A=
=0A=
		if ( this.options.animate ) {=0A=
			this._animate( toShow, toHide, data );=0A=
		} else {=0A=
			toHide.hide();=0A=
			toShow.show();=0A=
			this._toggleComplete( data );=0A=
		}=0A=
=0A=
		toHide.attr({=0A=
			"aria-hidden": "true"=0A=
		});=0A=
		toHide.prev().attr( "aria-selected", "false" );=0A=
		// if we're switching panels, remove the old header from the tab order=0A=
		// if we're opening from collapsed state, remove the previous header =
from the tab order=0A=
		// if we're collapsing, then keep the collapsing header in the tab =
order=0A=
		if ( toShow.length && toHide.length ) {=0A=
			toHide.prev().attr({=0A=
				"tabIndex": -1,=0A=
				"aria-expanded": "false"=0A=
			});=0A=
		} else if ( toShow.length ) {=0A=
			this.headers.filter(function() {=0A=
				return $( this ).attr( "tabIndex" ) =3D=3D=3D 0;=0A=
			})=0A=
			.attr( "tabIndex", -1 );=0A=
		}=0A=
=0A=
		toShow=0A=
			.attr( "aria-hidden", "false" )=0A=
			.prev()=0A=
				.attr({=0A=
					"aria-selected": "true",=0A=
					tabIndex: 0,=0A=
					"aria-expanded": "true"=0A=
				});=0A=
	},=0A=
=0A=
	_animate: function( toShow, toHide, data ) {=0A=
		var total, easing, duration,=0A=
			that =3D this,=0A=
			adjust =3D 0,=0A=
			down =3D toShow.length &&=0A=
				( !toHide.length || ( toShow.index() < toHide.index() ) ),=0A=
			animate =3D this.options.animate || {},=0A=
			options =3D down && animate.down || animate,=0A=
			complete =3D function() {=0A=
				that._toggleComplete( data );=0A=
			};=0A=
=0A=
		if ( typeof options =3D=3D=3D "number" ) {=0A=
			duration =3D options;=0A=
		}=0A=
		if ( typeof options =3D=3D=3D "string" ) {=0A=
			easing =3D options;=0A=
		}=0A=
		// fall back from options to animation in case of partial down settings=0A=
		easing =3D easing || options.easing || animate.easing;=0A=
		duration =3D duration || options.duration || animate.duration;=0A=
=0A=
		if ( !toHide.length ) {=0A=
			return toShow.animate( this.showProps, duration, easing, complete );=0A=
		}=0A=
		if ( !toShow.length ) {=0A=
			return toHide.animate( this.hideProps, duration, easing, complete );=0A=
		}=0A=
=0A=
		total =3D toShow.show().outerHeight();=0A=
		toHide.animate( this.hideProps, {=0A=
			duration: duration,=0A=
			easing: easing,=0A=
			step: function( now, fx ) {=0A=
				fx.now =3D Math.round( now );=0A=
			}=0A=
		});=0A=
		toShow=0A=
			.hide()=0A=
			.animate( this.showProps, {=0A=
				duration: duration,=0A=
				easing: easing,=0A=
				complete: complete,=0A=
				step: function( now, fx ) {=0A=
					fx.now =3D Math.round( now );=0A=
					if ( fx.prop !=3D=3D "height" ) {=0A=
						adjust +=3D fx.now;=0A=
					} else if ( that.options.heightStyle !=3D=3D "content" ) {=0A=
						fx.now =3D Math.round( total - toHide.outerHeight() - adjust );=0A=
						adjust =3D 0;=0A=
					}=0A=
				}=0A=
			});=0A=
	},=0A=
=0A=
	_toggleComplete: function( data ) {=0A=
		var toHide =3D data.oldPanel;=0A=
=0A=
		toHide=0A=
			.removeClass( "ui-accordion-content-active" )=0A=
			.prev()=0A=
				.removeClass( "ui-corner-top" )=0A=
				.addClass( "ui-corner-all" );=0A=
=0A=
		// Work around for rendering bug in IE (#5421)=0A=
		if ( toHide.length ) {=0A=
			toHide.parent()[ 0 ].className =3D toHide.parent()[ 0 ].className;=0A=
		}=0A=
		this._trigger( "activate", null, data );=0A=
	}=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Menu 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/menu/=0A=
 */=0A=
=0A=
=0A=
var menu =3D $.widget( "ui.menu", {=0A=
	version: "1.11.1",=0A=
	defaultElement: "<ul>",=0A=
	delay: 300,=0A=
	options: {=0A=
		icons: {=0A=
			submenu: "ui-icon-carat-1-e"=0A=
		},=0A=
		items: "> *",=0A=
		menus: "ul",=0A=
		position: {=0A=
			my: "left-1 top",=0A=
			at: "right top"=0A=
		},=0A=
		role: "menu",=0A=
=0A=
		// callbacks=0A=
		blur: null,=0A=
		focus: null,=0A=
		select: null=0A=
	},=0A=
=0A=
	_create: function() {=0A=
		this.activeMenu =3D this.element;=0A=
=0A=
		// Flag used to prevent firing of the click handler=0A=
		// as the event bubbles up through nested menus=0A=
		this.mouseHandled =3D false;=0A=
		this.element=0A=
			.uniqueId()=0A=
			.addClass( "ui-menu ui-widget ui-widget-content" )=0A=
			.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" =
).length )=0A=
			.attr({=0A=
				role: this.options.role,=0A=
				tabIndex: 0=0A=
			});=0A=
=0A=
		if ( this.options.disabled ) {=0A=
			this.element=0A=
				.addClass( "ui-state-disabled" )=0A=
				.attr( "aria-disabled", "true" );=0A=
		}=0A=
=0A=
		this._on({=0A=
			// Prevent focus from sticking to links inside menu after clicking=0A=
			// them (focus should always stay on UL during navigation).=0A=
			"mousedown .ui-menu-item": function( event ) {=0A=
				event.preventDefault();=0A=
			},=0A=
			"click .ui-menu-item": function( event ) {=0A=
				var target =3D $( event.target );=0A=
				if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length =
) {=0A=
					this.select( event );=0A=
=0A=
					// Only set the mouseHandled flag if the event will bubble, see =
#9469.=0A=
					if ( !event.isPropagationStopped() ) {=0A=
						this.mouseHandled =3D true;=0A=
					}=0A=
=0A=
					// Open submenu on click=0A=
					if ( target.has( ".ui-menu" ).length ) {=0A=
						this.expand( event );=0A=
					} else if ( !this.element.is( ":focus" ) && $( this.document[ 0 =
].activeElement ).closest( ".ui-menu" ).length ) {=0A=
=0A=
						// Redirect focus to the menu=0A=
						this.element.trigger( "focus", [ true ] );=0A=
=0A=
						// If the active item is on the top level, let it stay active.=0A=
						// Otherwise, blur the active item since it is no longer visible.=0A=
						if ( this.active && this.active.parents( ".ui-menu" ).length =
=3D=3D=3D 1 ) {=0A=
							clearTimeout( this.timer );=0A=
						}=0A=
					}=0A=
				}=0A=
			},=0A=
			"mouseenter .ui-menu-item": function( event ) {=0A=
				var target =3D $( event.currentTarget );=0A=
				// Remove ui-state-active class from siblings of the newly focused =
menu item=0A=
				// to avoid a jump caused by adjacent elements both having a class =
with a border=0A=
				target.siblings( ".ui-state-active" ).removeClass( "ui-state-active" =
);=0A=
				this.focus( event, target );=0A=
			},=0A=
			mouseleave: "collapseAll",=0A=
			"mouseleave .ui-menu": "collapseAll",=0A=
			focus: function( event, keepActiveItem ) {=0A=
				// If there's already an active item, keep it active=0A=
				// If not, activate the first item=0A=
				var item =3D this.active || this.element.find( this.options.items =
).eq( 0 );=0A=
=0A=
				if ( !keepActiveItem ) {=0A=
					this.focus( event, item );=0A=
				}=0A=
			},=0A=
			blur: function( event ) {=0A=
				this._delay(function() {=0A=
					if ( !$.contains( this.element[0], this.document[0].activeElement ) =
) {=0A=
						this.collapseAll( event );=0A=
					}=0A=
				});=0A=
			},=0A=
			keydown: "_keydown"=0A=
		});=0A=
=0A=
		this.refresh();=0A=
=0A=
		// Clicks outside of a menu collapse any open menus=0A=
		this._on( this.document, {=0A=
			click: function( event ) {=0A=
				if ( this._closeOnDocumentClick( event ) ) {=0A=
					this.collapseAll( event );=0A=
				}=0A=
=0A=
				// Reset the mouseHandled flag=0A=
				this.mouseHandled =3D false;=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		// Destroy (sub)menus=0A=
		this.element=0A=
			.removeAttr( "aria-activedescendant" )=0A=
			.find( ".ui-menu" ).addBack()=0A=
				.removeClass( "ui-menu ui-widget ui-widget-content ui-menu-icons =
ui-front" )=0A=
				.removeAttr( "role" )=0A=
				.removeAttr( "tabIndex" )=0A=
				.removeAttr( "aria-labelledby" )=0A=
				.removeAttr( "aria-expanded" )=0A=
				.removeAttr( "aria-hidden" )=0A=
				.removeAttr( "aria-disabled" )=0A=
				.removeUniqueId()=0A=
				.show();=0A=
=0A=
		// Destroy menu items=0A=
		this.element.find( ".ui-menu-item" )=0A=
			.removeClass( "ui-menu-item" )=0A=
			.removeAttr( "role" )=0A=
			.removeAttr( "aria-disabled" )=0A=
			.removeUniqueId()=0A=
			.removeClass( "ui-state-hover" )=0A=
			.removeAttr( "tabIndex" )=0A=
			.removeAttr( "role" )=0A=
			.removeAttr( "aria-haspopup" )=0A=
			.children().each( function() {=0A=
				var elem =3D $( this );=0A=
				if ( elem.data( "ui-menu-submenu-carat" ) ) {=0A=
					elem.remove();=0A=
				}=0A=
			});=0A=
=0A=
		// Destroy menu dividers=0A=
		this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider =
ui-widget-content" );=0A=
	},=0A=
=0A=
	_keydown: function( event ) {=0A=
		var match, prev, character, skip, regex,=0A=
			preventDefault =3D true;=0A=
=0A=
		function escape( value ) {=0A=
			return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );=0A=
		}=0A=
=0A=
		switch ( event.keyCode ) {=0A=
		case $.ui.keyCode.PAGE_UP:=0A=
			this.previousPage( event );=0A=
			break;=0A=
		case $.ui.keyCode.PAGE_DOWN:=0A=
			this.nextPage( event );=0A=
			break;=0A=
		case $.ui.keyCode.HOME:=0A=
			this._move( "first", "first", event );=0A=
			break;=0A=
		case $.ui.keyCode.END:=0A=
			this._move( "last", "last", event );=0A=
			break;=0A=
		case $.ui.keyCode.UP:=0A=
			this.previous( event );=0A=
			break;=0A=
		case $.ui.keyCode.DOWN:=0A=
			this.next( event );=0A=
			break;=0A=
		case $.ui.keyCode.LEFT:=0A=
			this.collapse( event );=0A=
			break;=0A=
		case $.ui.keyCode.RIGHT:=0A=
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {=0A=
				this.expand( event );=0A=
			}=0A=
			break;=0A=
		case $.ui.keyCode.ENTER:=0A=
		case $.ui.keyCode.SPACE:=0A=
			this._activate( event );=0A=
			break;=0A=
		case $.ui.keyCode.ESCAPE:=0A=
			this.collapse( event );=0A=
			break;=0A=
		default:=0A=
			preventDefault =3D false;=0A=
			prev =3D this.previousFilter || "";=0A=
			character =3D String.fromCharCode( event.keyCode );=0A=
			skip =3D false;=0A=
=0A=
			clearTimeout( this.filterTimer );=0A=
=0A=
			if ( character =3D=3D=3D prev ) {=0A=
				skip =3D true;=0A=
			} else {=0A=
				character =3D prev + character;=0A=
			}=0A=
=0A=
			regex =3D new RegExp( "^" + escape( character ), "i" );=0A=
			match =3D this.activeMenu.find( this.options.items =
).filter(function() {=0A=
				return regex.test( $( this ).text() );=0A=
			});=0A=
			match =3D skip && match.index( this.active.next() ) !=3D=3D -1 ?=0A=
				this.active.nextAll( ".ui-menu-item" ) :=0A=
				match;=0A=
=0A=
			// If no matches on the current filter, reset to the last character =
pressed=0A=
			// to move down the menu to the first item that starts with that =
character=0A=
			if ( !match.length ) {=0A=
				character =3D String.fromCharCode( event.keyCode );=0A=
				regex =3D new RegExp( "^" + escape( character ), "i" );=0A=
				match =3D this.activeMenu.find( this.options.items =
).filter(function() {=0A=
					return regex.test( $( this ).text() );=0A=
				});=0A=
			}=0A=
=0A=
			if ( match.length ) {=0A=
				this.focus( event, match );=0A=
				if ( match.length > 1 ) {=0A=
					this.previousFilter =3D character;=0A=
					this.filterTimer =3D this._delay(function() {=0A=
						delete this.previousFilter;=0A=
					}, 1000 );=0A=
				} else {=0A=
					delete this.previousFilter;=0A=
				}=0A=
			} else {=0A=
				delete this.previousFilter;=0A=
			}=0A=
		}=0A=
=0A=
		if ( preventDefault ) {=0A=
			event.preventDefault();=0A=
		}=0A=
	},=0A=
=0A=
	_activate: function( event ) {=0A=
		if ( !this.active.is( ".ui-state-disabled" ) ) {=0A=
			if ( this.active.is( "[aria-haspopup=3D'true']" ) ) {=0A=
				this.expand( event );=0A=
			} else {=0A=
				this.select( event );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	refresh: function() {=0A=
		var menus, items,=0A=
			that =3D this,=0A=
			icon =3D this.options.icons.submenu,=0A=
			submenus =3D this.element.find( this.options.menus );=0A=
=0A=
		this.element.toggleClass( "ui-menu-icons", !!this.element.find( =
".ui-icon" ).length );=0A=
=0A=
		// Initialize nested menus=0A=
		submenus.filter( ":not(.ui-menu)" )=0A=
			.addClass( "ui-menu ui-widget ui-widget-content ui-front" )=0A=
			.hide()=0A=
			.attr({=0A=
				role: this.options.role,=0A=
				"aria-hidden": "true",=0A=
				"aria-expanded": "false"=0A=
			})=0A=
			.each(function() {=0A=
				var menu =3D $( this ),=0A=
					item =3D menu.parent(),=0A=
					submenuCarat =3D $( "<span>" )=0A=
						.addClass( "ui-menu-icon ui-icon " + icon )=0A=
						.data( "ui-menu-submenu-carat", true );=0A=
=0A=
				item=0A=
					.attr( "aria-haspopup", "true" )=0A=
					.prepend( submenuCarat );=0A=
				menu.attr( "aria-labelledby", item.attr( "id" ) );=0A=
			});=0A=
=0A=
		menus =3D submenus.add( this.element );=0A=
		items =3D menus.find( this.options.items );=0A=
=0A=
		// Initialize menu-items containing spaces and/or dashes only as =
dividers=0A=
		items.not( ".ui-menu-item" ).each(function() {=0A=
			var item =3D $( this );=0A=
			if ( that._isDivider( item ) ) {=0A=
				item.addClass( "ui-widget-content ui-menu-divider" );=0A=
			}=0A=
		});=0A=
=0A=
		// Don't refresh list items that are already adapted=0A=
		items.not( ".ui-menu-item, .ui-menu-divider" )=0A=
			.addClass( "ui-menu-item" )=0A=
			.uniqueId()=0A=
			.attr({=0A=
				tabIndex: -1,=0A=
				role: this._itemRole()=0A=
			});=0A=
=0A=
		// Add aria-disabled attribute to any disabled menu item=0A=
		items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );=0A=
=0A=
		// If the active item has been removed, blur the menu=0A=
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) =
) {=0A=
			this.blur();=0A=
		}=0A=
	},=0A=
=0A=
	_itemRole: function() {=0A=
		return {=0A=
			menu: "menuitem",=0A=
			listbox: "option"=0A=
		}[ this.options.role ];=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		if ( key =3D=3D=3D "icons" ) {=0A=
			this.element.find( ".ui-menu-icon" )=0A=
				.removeClass( this.options.icons.submenu )=0A=
				.addClass( value.submenu );=0A=
		}=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			this.element=0A=
				.toggleClass( "ui-state-disabled", !!value )=0A=
				.attr( "aria-disabled", value );=0A=
		}=0A=
		this._super( key, value );=0A=
	},=0A=
=0A=
	focus: function( event, item ) {=0A=
		var nested, focused;=0A=
		this.blur( event, event && event.type =3D=3D=3D "focus" );=0A=
=0A=
		this._scrollIntoView( item );=0A=
=0A=
		this.active =3D item.first();=0A=
		focused =3D this.active.addClass( "ui-state-focus" ).removeClass( =
"ui-state-active" );=0A=
		// Only update aria-activedescendant if there's a role=0A=
		// otherwise we assume focus is managed elsewhere=0A=
		if ( this.options.role ) {=0A=
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );=0A=
		}=0A=
=0A=
		// Highlight active parent menu item, if any=0A=
		this.active=0A=
			.parent()=0A=
			.closest( ".ui-menu-item" )=0A=
			.addClass( "ui-state-active" );=0A=
=0A=
		if ( event && event.type =3D=3D=3D "keydown" ) {=0A=
			this._close();=0A=
		} else {=0A=
			this.timer =3D this._delay(function() {=0A=
				this._close();=0A=
			}, this.delay );=0A=
		}=0A=
=0A=
		nested =3D item.children( ".ui-menu" );=0A=
		if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {=0A=
			this._startOpening(nested);=0A=
		}=0A=
		this.activeMenu =3D item.parent();=0A=
=0A=
		this._trigger( "focus", event, { item: item } );=0A=
	},=0A=
=0A=
	_scrollIntoView: function( item ) {=0A=
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;=0A=
		if ( this._hasScroll() ) {=0A=
			borderTop =3D parseFloat( $.css( this.activeMenu[0], "borderTopWidth" =
) ) || 0;=0A=
			paddingTop =3D parseFloat( $.css( this.activeMenu[0], "paddingTop" ) =
) || 0;=0A=
			offset =3D item.offset().top - this.activeMenu.offset().top - =
borderTop - paddingTop;=0A=
			scroll =3D this.activeMenu.scrollTop();=0A=
			elementHeight =3D this.activeMenu.height();=0A=
			itemHeight =3D item.outerHeight();=0A=
=0A=
			if ( offset < 0 ) {=0A=
				this.activeMenu.scrollTop( scroll + offset );=0A=
			} else if ( offset + itemHeight > elementHeight ) {=0A=
				this.activeMenu.scrollTop( scroll + offset - elementHeight + =
itemHeight );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	blur: function( event, fromFocus ) {=0A=
		if ( !fromFocus ) {=0A=
			clearTimeout( this.timer );=0A=
		}=0A=
=0A=
		if ( !this.active ) {=0A=
			return;=0A=
		}=0A=
=0A=
		this.active.removeClass( "ui-state-focus" );=0A=
		this.active =3D null;=0A=
=0A=
		this._trigger( "blur", event, { item: this.active } );=0A=
	},=0A=
=0A=
	_startOpening: function( submenu ) {=0A=
		clearTimeout( this.timer );=0A=
=0A=
		// Don't open if already open fixes a Firefox bug that caused a .5 =
pixel=0A=
		// shift in the submenu position when mousing over the carat icon=0A=
		if ( submenu.attr( "aria-hidden" ) !=3D=3D "true" ) {=0A=
			return;=0A=
		}=0A=
=0A=
		this.timer =3D this._delay(function() {=0A=
			this._close();=0A=
			this._open( submenu );=0A=
		}, this.delay );=0A=
	},=0A=
=0A=
	_open: function( submenu ) {=0A=
		var position =3D $.extend({=0A=
			of: this.active=0A=
		}, this.options.position );=0A=
=0A=
		clearTimeout( this.timer );=0A=
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )=0A=
			.hide()=0A=
			.attr( "aria-hidden", "true" );=0A=
=0A=
		submenu=0A=
			.show()=0A=
			.removeAttr( "aria-hidden" )=0A=
			.attr( "aria-expanded", "true" )=0A=
			.position( position );=0A=
	},=0A=
=0A=
	collapseAll: function( event, all ) {=0A=
		clearTimeout( this.timer );=0A=
		this.timer =3D this._delay(function() {=0A=
			// If we were passed an event, look for the submenu that contains the =
event=0A=
			var currentMenu =3D all ? this.element :=0A=
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) =
);=0A=
=0A=
			// If we found no valid submenu ancestor, use the main menu to close =
all sub menus anyway=0A=
			if ( !currentMenu.length ) {=0A=
				currentMenu =3D this.element;=0A=
			}=0A=
=0A=
			this._close( currentMenu );=0A=
=0A=
			this.blur( event );=0A=
			this.activeMenu =3D currentMenu;=0A=
		}, this.delay );=0A=
	},=0A=
=0A=
	// With no arguments, closes the currently active menu - if nothing is =
active=0A=
	// it closes all menus.  If passed an argument, it will search for =
menus BELOW=0A=
	_close: function( startMenu ) {=0A=
		if ( !startMenu ) {=0A=
			startMenu =3D this.active ? this.active.parent() : this.element;=0A=
		}=0A=
=0A=
		startMenu=0A=
			.find( ".ui-menu" )=0A=
				.hide()=0A=
				.attr( "aria-hidden", "true" )=0A=
				.attr( "aria-expanded", "false" )=0A=
			.end()=0A=
			.find( ".ui-state-active" ).not( ".ui-state-focus" )=0A=
				.removeClass( "ui-state-active" );=0A=
	},=0A=
=0A=
	_closeOnDocumentClick: function( event ) {=0A=
		return !$( event.target ).closest( ".ui-menu" ).length;=0A=
	},=0A=
=0A=
	_isDivider: function( item ) {=0A=
=0A=
		// Match hyphen, em dash, en dash=0A=
		return !/[^\-\u2014\u2013\s]/.test( item.text() );=0A=
	},=0A=
=0A=
	collapse: function( event ) {=0A=
		var newItem =3D this.active &&=0A=
			this.active.parent().closest( ".ui-menu-item", this.element );=0A=
		if ( newItem && newItem.length ) {=0A=
			this._close();=0A=
			this.focus( event, newItem );=0A=
		}=0A=
	},=0A=
=0A=
	expand: function( event ) {=0A=
		var newItem =3D this.active &&=0A=
			this.active=0A=
				.children( ".ui-menu " )=0A=
				.find( this.options.items )=0A=
				.first();=0A=
=0A=
		if ( newItem && newItem.length ) {=0A=
			this._open( newItem.parent() );=0A=
=0A=
			// Delay so Firefox will not hide activedescendant change in =
expanding submenu from AT=0A=
			this._delay(function() {=0A=
				this.focus( event, newItem );=0A=
			});=0A=
		}=0A=
	},=0A=
=0A=
	next: function( event ) {=0A=
		this._move( "next", "first", event );=0A=
	},=0A=
=0A=
	previous: function( event ) {=0A=
		this._move( "prev", "last", event );=0A=
	},=0A=
=0A=
	isFirstItem: function() {=0A=
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;=0A=
	},=0A=
=0A=
	isLastItem: function() {=0A=
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;=0A=
	},=0A=
=0A=
	_move: function( direction, filter, event ) {=0A=
		var next;=0A=
		if ( this.active ) {=0A=
			if ( direction =3D=3D=3D "first" || direction =3D=3D=3D "last" ) {=0A=
				next =3D this.active=0A=
					[ direction =3D=3D=3D "first" ? "prevAll" : "nextAll" ]( =
".ui-menu-item" )=0A=
					.eq( -1 );=0A=
			} else {=0A=
				next =3D this.active=0A=
					[ direction + "All" ]( ".ui-menu-item" )=0A=
					.eq( 0 );=0A=
			}=0A=
		}=0A=
		if ( !next || !next.length || !this.active ) {=0A=
			next =3D this.activeMenu.find( this.options.items )[ filter ]();=0A=
		}=0A=
=0A=
		this.focus( event, next );=0A=
	},=0A=
=0A=
	nextPage: function( event ) {=0A=
		var item, base, height;=0A=
=0A=
		if ( !this.active ) {=0A=
			this.next( event );=0A=
			return;=0A=
		}=0A=
		if ( this.isLastItem() ) {=0A=
			return;=0A=
		}=0A=
		if ( this._hasScroll() ) {=0A=
			base =3D this.active.offset().top;=0A=
			height =3D this.element.height();=0A=
			this.active.nextAll( ".ui-menu-item" ).each(function() {=0A=
				item =3D $( this );=0A=
				return item.offset().top - base - height < 0;=0A=
			});=0A=
=0A=
			this.focus( event, item );=0A=
		} else {=0A=
			this.focus( event, this.activeMenu.find( this.options.items )=0A=
				[ !this.active ? "first" : "last" ]() );=0A=
		}=0A=
	},=0A=
=0A=
	previousPage: function( event ) {=0A=
		var item, base, height;=0A=
		if ( !this.active ) {=0A=
			this.next( event );=0A=
			return;=0A=
		}=0A=
		if ( this.isFirstItem() ) {=0A=
			return;=0A=
		}=0A=
		if ( this._hasScroll() ) {=0A=
			base =3D this.active.offset().top;=0A=
			height =3D this.element.height();=0A=
			this.active.prevAll( ".ui-menu-item" ).each(function() {=0A=
				item =3D $( this );=0A=
				return item.offset().top - base + height > 0;=0A=
			});=0A=
=0A=
			this.focus( event, item );=0A=
		} else {=0A=
			this.focus( event, this.activeMenu.find( this.options.items ).first() =
);=0A=
		}=0A=
	},=0A=
=0A=
	_hasScroll: function() {=0A=
		return this.element.outerHeight() < this.element.prop( "scrollHeight" =
);=0A=
	},=0A=
=0A=
	select: function( event ) {=0A=
		// TODO: It should never be possible to not have an active item at this=0A=
		// point, but the tests don't trigger mouseenter before click.=0A=
		this.active =3D this.active || $( event.target ).closest( =
".ui-menu-item" );=0A=
		var ui =3D { item: this.active };=0A=
		if ( !this.active.has( ".ui-menu" ).length ) {=0A=
			this.collapseAll( event, true );=0A=
		}=0A=
		this._trigger( "select", event, ui );=0A=
	}=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Autocomplete 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/autocomplete/=0A=
 */=0A=
=0A=
=0A=
$.widget( "ui.autocomplete", {=0A=
	version: "1.11.1",=0A=
	defaultElement: "<input>",=0A=
	options: {=0A=
		appendTo: null,=0A=
		autoFocus: false,=0A=
		delay: 300,=0A=
		minLength: 1,=0A=
		position: {=0A=
			my: "left top",=0A=
			at: "left bottom",=0A=
			collision: "none"=0A=
		},=0A=
		source: null,=0A=
=0A=
		// callbacks=0A=
		change: null,=0A=
		close: null,=0A=
		focus: null,=0A=
		open: null,=0A=
		response: null,=0A=
		search: null,=0A=
		select: null=0A=
	},=0A=
=0A=
	requestIndex: 0,=0A=
	pending: 0,=0A=
=0A=
	_create: function() {=0A=
		// Some browsers only repeat keydown events, not keypress events,=0A=
		// so we use the suppressKeyPress flag to determine if we've already=0A=
		// handled the keydown event. #7269=0A=
		// Unfortunately the code for & in keypress is the same as the up =
arrow,=0A=
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress=0A=
		// events when we know the keydown event was used to modify the=0A=
		// search term. #7799=0A=
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput,=0A=
			nodeName =3D this.element[ 0 ].nodeName.toLowerCase(),=0A=
			isTextarea =3D nodeName =3D=3D=3D "textarea",=0A=
			isInput =3D nodeName =3D=3D=3D "input";=0A=
=0A=
		this.isMultiLine =3D=0A=
			// Textareas are always multi-line=0A=
			isTextarea ? true :=0A=
			// Inputs are always single-line, even if inside a contentEditable =
element=0A=
			// IE also treats inputs as contentEditable=0A=
			isInput ? false :=0A=
			// All other element types are determined by whether or not they're =
contentEditable=0A=
			this.element.prop( "isContentEditable" );=0A=
=0A=
		this.valueMethod =3D this.element[ isTextarea || isInput ? "val" : =
"text" ];=0A=
		this.isNewMenu =3D true;=0A=
=0A=
		this.element=0A=
			.addClass( "ui-autocomplete-input" )=0A=
			.attr( "autocomplete", "off" );=0A=
=0A=
		this._on( this.element, {=0A=
			keydown: function( event ) {=0A=
				if ( this.element.prop( "readOnly" ) ) {=0A=
					suppressKeyPress =3D true;=0A=
					suppressInput =3D true;=0A=
					suppressKeyPressRepeat =3D true;=0A=
					return;=0A=
				}=0A=
=0A=
				suppressKeyPress =3D false;=0A=
				suppressInput =3D false;=0A=
				suppressKeyPressRepeat =3D false;=0A=
				var keyCode =3D $.ui.keyCode;=0A=
				switch ( event.keyCode ) {=0A=
				case keyCode.PAGE_UP:=0A=
					suppressKeyPress =3D true;=0A=
					this._move( "previousPage", event );=0A=
					break;=0A=
				case keyCode.PAGE_DOWN:=0A=
					suppressKeyPress =3D true;=0A=
					this._move( "nextPage", event );=0A=
					break;=0A=
				case keyCode.UP:=0A=
					suppressKeyPress =3D true;=0A=
					this._keyEvent( "previous", event );=0A=
					break;=0A=
				case keyCode.DOWN:=0A=
					suppressKeyPress =3D true;=0A=
					this._keyEvent( "next", event );=0A=
					break;=0A=
				case keyCode.ENTER:=0A=
					// when menu is open and has focus=0A=
					if ( this.menu.active ) {=0A=
						// #6055 - Opera still allows the keypress to occur=0A=
						// which causes forms to submit=0A=
						suppressKeyPress =3D true;=0A=
						event.preventDefault();=0A=
						this.menu.select( event );=0A=
					}=0A=
					break;=0A=
				case keyCode.TAB:=0A=
					if ( this.menu.active ) {=0A=
						this.menu.select( event );=0A=
					}=0A=
					break;=0A=
				case keyCode.ESCAPE:=0A=
					if ( this.menu.element.is( ":visible" ) ) {=0A=
						if ( !this.isMultiLine ) {=0A=
							this._value( this.term );=0A=
						}=0A=
						this.close( event );=0A=
						// Different browsers have different default behavior for escape=0A=
						// Single press can mean undo or clear=0A=
						// Double press in IE means clear the whole form=0A=
						event.preventDefault();=0A=
					}=0A=
					break;=0A=
				default:=0A=
					suppressKeyPressRepeat =3D true;=0A=
					// search timeout should be triggered before the input value is =
changed=0A=
					this._searchTimeout( event );=0A=
					break;=0A=
				}=0A=
			},=0A=
			keypress: function( event ) {=0A=
				if ( suppressKeyPress ) {=0A=
					suppressKeyPress =3D false;=0A=
					if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {=0A=
						event.preventDefault();=0A=
					}=0A=
					return;=0A=
				}=0A=
				if ( suppressKeyPressRepeat ) {=0A=
					return;=0A=
				}=0A=
=0A=
				// replicate some key handlers to allow them to repeat in Firefox =
and Opera=0A=
				var keyCode =3D $.ui.keyCode;=0A=
				switch ( event.keyCode ) {=0A=
				case keyCode.PAGE_UP:=0A=
					this._move( "previousPage", event );=0A=
					break;=0A=
				case keyCode.PAGE_DOWN:=0A=
					this._move( "nextPage", event );=0A=
					break;=0A=
				case keyCode.UP:=0A=
					this._keyEvent( "previous", event );=0A=
					break;=0A=
				case keyCode.DOWN:=0A=
					this._keyEvent( "next", event );=0A=
					break;=0A=
				}=0A=
			},=0A=
			input: function( event ) {=0A=
				if ( suppressInput ) {=0A=
					suppressInput =3D false;=0A=
					event.preventDefault();=0A=
					return;=0A=
				}=0A=
				this._searchTimeout( event );=0A=
			},=0A=
			focus: function() {=0A=
				this.selectedItem =3D null;=0A=
				this.previous =3D this._value();=0A=
			},=0A=
			blur: function( event ) {=0A=
				if ( this.cancelBlur ) {=0A=
					delete this.cancelBlur;=0A=
					return;=0A=
				}=0A=
=0A=
				clearTimeout( this.searching );=0A=
				this.close( event );=0A=
				this._change( event );=0A=
			}=0A=
		});=0A=
=0A=
		this._initSource();=0A=
		this.menu =3D $( "<ul>" )=0A=
			.addClass( "ui-autocomplete ui-front" )=0A=
			.appendTo( this._appendTo() )=0A=
			.menu({=0A=
				// disable ARIA support, the live region takes care of that=0A=
				role: null=0A=
			})=0A=
			.hide()=0A=
			.menu( "instance" );=0A=
=0A=
		this._on( this.menu.element, {=0A=
			mousedown: function( event ) {=0A=
				// prevent moving focus out of the text field=0A=
				event.preventDefault();=0A=
=0A=
				// IE doesn't prevent moving focus even with event.preventDefault()=0A=
				// so we set a flag to know when we should ignore the blur event=0A=
				this.cancelBlur =3D true;=0A=
				this._delay(function() {=0A=
					delete this.cancelBlur;=0A=
				});=0A=
=0A=
				// clicking on the scrollbar causes focus to shift to the body=0A=
				// but we can't detect a mouseup or a click immediately afterward=0A=
				// so we have to track the next mousedown and close the menu if=0A=
				// the user clicks somewhere outside of the autocomplete=0A=
				var menuElement =3D this.menu.element[ 0 ];=0A=
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {=0A=
					this._delay(function() {=0A=
						var that =3D this;=0A=
						this.document.one( "mousedown", function( event ) {=0A=
							if ( event.target !=3D=3D that.element[ 0 ] &&=0A=
									event.target !=3D=3D menuElement &&=0A=
									!$.contains( menuElement, event.target ) ) {=0A=
								that.close();=0A=
							}=0A=
						});=0A=
					});=0A=
				}=0A=
			},=0A=
			menufocus: function( event, ui ) {=0A=
				var label, item;=0A=
				// support: Firefox=0A=
				// Prevent accidental activation of menu items in Firefox (#7024 =
#9118)=0A=
				if ( this.isNewMenu ) {=0A=
					this.isNewMenu =3D false;=0A=
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type =
) ) {=0A=
						this.menu.blur();=0A=
=0A=
						this.document.one( "mousemove", function() {=0A=
							$( event.target ).trigger( event.originalEvent );=0A=
						});=0A=
=0A=
						return;=0A=
					}=0A=
				}=0A=
=0A=
				item =3D ui.item.data( "ui-autocomplete-item" );=0A=
				if ( false !=3D=3D this._trigger( "focus", event, { item: item } ) ) =
{=0A=
					// use value to match what will end up in the input, if it was a =
key event=0A=
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) =
) {=0A=
						this._value( item.value );=0A=
					}=0A=
				}=0A=
=0A=
				// Announce the value in the liveRegion=0A=
				label =3D ui.item.attr( "aria-label" ) || item.value;=0A=
				if ( label && $.trim( label ).length ) {=0A=
					this.liveRegion.children().hide();=0A=
					$( "<div>" ).text( label ).appendTo( this.liveRegion );=0A=
				}=0A=
			},=0A=
			menuselect: function( event, ui ) {=0A=
				var item =3D ui.item.data( "ui-autocomplete-item" ),=0A=
					previous =3D this.previous;=0A=
=0A=
				// only trigger when focus was lost (click on menu)=0A=
				if ( this.element[ 0 ] !=3D=3D this.document[ 0 ].activeElement ) {=0A=
					this.element.focus();=0A=
					this.previous =3D previous;=0A=
					// #6109 - IE triggers two focus events and the second=0A=
					// is asynchronous, so we need to reset the previous=0A=
					// term synchronously and asynchronously :-(=0A=
					this._delay(function() {=0A=
						this.previous =3D previous;=0A=
						this.selectedItem =3D item;=0A=
					});=0A=
				}=0A=
=0A=
				if ( false !=3D=3D this._trigger( "select", event, { item: item } ) =
) {=0A=
					this._value( item.value );=0A=
				}=0A=
				// reset the term after the select event=0A=
				// this allows custom select handling to work properly=0A=
				this.term =3D this._value();=0A=
=0A=
				this.close( event );=0A=
				this.selectedItem =3D item;=0A=
			}=0A=
		});=0A=
=0A=
		this.liveRegion =3D $( "<span>", {=0A=
				role: "status",=0A=
				"aria-live": "assertive",=0A=
				"aria-relevant": "additions"=0A=
			})=0A=
			.addClass( "ui-helper-hidden-accessible" )=0A=
			.appendTo( this.document[ 0 ].body );=0A=
=0A=
		// turning off autocomplete prevents the browser from remembering the=0A=
		// value when navigating through history, so we re-enable autocomplete=0A=
		// if the page is unloaded before the widget is destroyed. #7790=0A=
		this._on( this.window, {=0A=
			beforeunload: function() {=0A=
				this.element.removeAttr( "autocomplete" );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		clearTimeout( this.searching );=0A=
		this.element=0A=
			.removeClass( "ui-autocomplete-input" )=0A=
			.removeAttr( "autocomplete" );=0A=
		this.menu.element.remove();=0A=
		this.liveRegion.remove();=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		this._super( key, value );=0A=
		if ( key =3D=3D=3D "source" ) {=0A=
			this._initSource();=0A=
		}=0A=
		if ( key =3D=3D=3D "appendTo" ) {=0A=
			this.menu.element.appendTo( this._appendTo() );=0A=
		}=0A=
		if ( key =3D=3D=3D "disabled" && value && this.xhr ) {=0A=
			this.xhr.abort();=0A=
		}=0A=
	},=0A=
=0A=
	_appendTo: function() {=0A=
		var element =3D this.options.appendTo;=0A=
=0A=
		if ( element ) {=0A=
			element =3D element.jquery || element.nodeType ?=0A=
				$( element ) :=0A=
				this.document.find( element ).eq( 0 );=0A=
		}=0A=
=0A=
		if ( !element || !element[ 0 ] ) {=0A=
			element =3D this.element.closest( ".ui-front" );=0A=
		}=0A=
=0A=
		if ( !element.length ) {=0A=
			element =3D this.document[ 0 ].body;=0A=
		}=0A=
=0A=
		return element;=0A=
	},=0A=
=0A=
	_initSource: function() {=0A=
		var array, url,=0A=
			that =3D this;=0A=
		if ( $.isArray( this.options.source ) ) {=0A=
			array =3D this.options.source;=0A=
			this.source =3D function( request, response ) {=0A=
				response( $.ui.autocomplete.filter( array, request.term ) );=0A=
			};=0A=
		} else if ( typeof this.options.source =3D=3D=3D "string" ) {=0A=
			url =3D this.options.source;=0A=
			this.source =3D function( request, response ) {=0A=
				if ( that.xhr ) {=0A=
					that.xhr.abort();=0A=
				}=0A=
				that.xhr =3D $.ajax({=0A=
					url: url,=0A=
					data: request,=0A=
					dataType: "json",=0A=
					success: function( data ) {=0A=
						response( data );=0A=
					},=0A=
					error: function() {=0A=
						response([]);=0A=
					}=0A=
				});=0A=
			};=0A=
		} else {=0A=
			this.source =3D this.options.source;=0A=
		}=0A=
	},=0A=
=0A=
	_searchTimeout: function( event ) {=0A=
		clearTimeout( this.searching );=0A=
		this.searching =3D this._delay(function() {=0A=
=0A=
			// Search if the value has changed, or if the user retypes the same =
value (see #7434)=0A=
			var equalValues =3D this.term =3D=3D=3D this._value(),=0A=
				menuVisible =3D this.menu.element.is( ":visible" ),=0A=
				modifierKey =3D event.altKey || event.ctrlKey || event.metaKey || =
event.shiftKey;=0A=
=0A=
			if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) =
) {=0A=
				this.selectedItem =3D null;=0A=
				this.search( null, event );=0A=
			}=0A=
		}, this.options.delay );=0A=
	},=0A=
=0A=
	search: function( value, event ) {=0A=
		value =3D value !=3D null ? value : this._value();=0A=
=0A=
		// always save the actual value, not the one passed as an argument=0A=
		this.term =3D this._value();=0A=
=0A=
		if ( value.length < this.options.minLength ) {=0A=
			return this.close( event );=0A=
		}=0A=
=0A=
		if ( this._trigger( "search", event ) =3D=3D=3D false ) {=0A=
			return;=0A=
		}=0A=
=0A=
		return this._search( value );=0A=
	},=0A=
=0A=
	_search: function( value ) {=0A=
		this.pending++;=0A=
		this.element.addClass( "ui-autocomplete-loading" );=0A=
		this.cancelSearch =3D false;=0A=
=0A=
		this.source( { term: value }, this._response() );=0A=
	},=0A=
=0A=
	_response: function() {=0A=
		var index =3D ++this.requestIndex;=0A=
=0A=
		return $.proxy(function( content ) {=0A=
			if ( index =3D=3D=3D this.requestIndex ) {=0A=
				this.__response( content );=0A=
			}=0A=
=0A=
			this.pending--;=0A=
			if ( !this.pending ) {=0A=
				this.element.removeClass( "ui-autocomplete-loading" );=0A=
			}=0A=
		}, this );=0A=
	},=0A=
=0A=
	__response: function( content ) {=0A=
		if ( content ) {=0A=
			content =3D this._normalize( content );=0A=
		}=0A=
		this._trigger( "response", null, { content: content } );=0A=
		if ( !this.options.disabled && content && content.length && =
!this.cancelSearch ) {=0A=
			this._suggest( content );=0A=
			this._trigger( "open" );=0A=
		} else {=0A=
			// use ._close() instead of .close() so we don't cancel future =
searches=0A=
			this._close();=0A=
		}=0A=
	},=0A=
=0A=
	close: function( event ) {=0A=
		this.cancelSearch =3D true;=0A=
		this._close( event );=0A=
	},=0A=
=0A=
	_close: function( event ) {=0A=
		if ( this.menu.element.is( ":visible" ) ) {=0A=
			this.menu.element.hide();=0A=
			this.menu.blur();=0A=
			this.isNewMenu =3D true;=0A=
			this._trigger( "close", event );=0A=
		}=0A=
	},=0A=
=0A=
	_change: function( event ) {=0A=
		if ( this.previous !=3D=3D this._value() ) {=0A=
			this._trigger( "change", event, { item: this.selectedItem } );=0A=
		}=0A=
	},=0A=
=0A=
	_normalize: function( items ) {=0A=
		// assume all items have the right format when the first item is =
complete=0A=
		if ( items.length && items[ 0 ].label && items[ 0 ].value ) {=0A=
			return items;=0A=
		}=0A=
		return $.map( items, function( item ) {=0A=
			if ( typeof item =3D=3D=3D "string" ) {=0A=
				return {=0A=
					label: item,=0A=
					value: item=0A=
				};=0A=
			}=0A=
			return $.extend( {}, item, {=0A=
				label: item.label || item.value,=0A=
				value: item.value || item.label=0A=
			});=0A=
		});=0A=
	},=0A=
=0A=
	_suggest: function( items ) {=0A=
		var ul =3D this.menu.element.empty();=0A=
		this._renderMenu( ul, items );=0A=
		this.isNewMenu =3D true;=0A=
		this.menu.refresh();=0A=
=0A=
		// size and position menu=0A=
		ul.show();=0A=
		this._resizeMenu();=0A=
		ul.position( $.extend({=0A=
			of: this.element=0A=
		}, this.options.position ) );=0A=
=0A=
		if ( this.options.autoFocus ) {=0A=
			this.menu.next();=0A=
		}=0A=
	},=0A=
=0A=
	_resizeMenu: function() {=0A=
		var ul =3D this.menu.element;=0A=
		ul.outerWidth( Math.max(=0A=
			// Firefox wraps long text (possibly a rounding bug)=0A=
			// so we add 1px to avoid the wrapping (#7513)=0A=
			ul.width( "" ).outerWidth() + 1,=0A=
			this.element.outerWidth()=0A=
		) );=0A=
	},=0A=
=0A=
	_renderMenu: function( ul, items ) {=0A=
		var that =3D this;=0A=
		$.each( items, function( index, item ) {=0A=
			that._renderItemData( ul, item );=0A=
		});=0A=
	},=0A=
=0A=
	_renderItemData: function( ul, item ) {=0A=
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item =
);=0A=
	},=0A=
=0A=
	_renderItem: function( ul, item ) {=0A=
		return $( "<li>" ).text( item.label ).appendTo( ul );=0A=
	},=0A=
=0A=
	_move: function( direction, event ) {=0A=
		if ( !this.menu.element.is( ":visible" ) ) {=0A=
			this.search( null, event );=0A=
			return;=0A=
		}=0A=
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||=0A=
				this.menu.isLastItem() && /^next/.test( direction ) ) {=0A=
=0A=
			if ( !this.isMultiLine ) {=0A=
				this._value( this.term );=0A=
			}=0A=
=0A=
			this.menu.blur();=0A=
			return;=0A=
		}=0A=
		this.menu[ direction ]( event );=0A=
	},=0A=
=0A=
	widget: function() {=0A=
		return this.menu.element;=0A=
	},=0A=
=0A=
	_value: function() {=0A=
		return this.valueMethod.apply( this.element, arguments );=0A=
	},=0A=
=0A=
	_keyEvent: function( keyEvent, event ) {=0A=
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {=0A=
			this._move( keyEvent, event );=0A=
=0A=
			// prevents moving cursor to beginning/end of the text field in some =
browsers=0A=
			event.preventDefault();=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
$.extend( $.ui.autocomplete, {=0A=
	escapeRegex: function( value ) {=0A=
		return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );=0A=
	},=0A=
	filter: function( array, term ) {=0A=
		var matcher =3D new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" =
);=0A=
		return $.grep( array, function( value ) {=0A=
			return matcher.test( value.label || value.value || value );=0A=
		});=0A=
	}=0A=
});=0A=
=0A=
// live region extension, adding a `messages` option=0A=
// NOTE: This is an experimental API. We are still investigating=0A=
// a full solution for string manipulation and internationalization.=0A=
$.widget( "ui.autocomplete", $.ui.autocomplete, {=0A=
	options: {=0A=
		messages: {=0A=
			noResults: "No search results.",=0A=
			results: function( amount ) {=0A=
				return amount + ( amount > 1 ? " results are" : " result is" ) +=0A=
					" available, use up and down arrow keys to navigate.";=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	__response: function( content ) {=0A=
		var message;=0A=
		this._superApply( arguments );=0A=
		if ( this.options.disabled || this.cancelSearch ) {=0A=
			return;=0A=
		}=0A=
		if ( content && content.length ) {=0A=
			message =3D this.options.messages.results( content.length );=0A=
		} else {=0A=
			message =3D this.options.messages.noResults;=0A=
		}=0A=
		this.liveRegion.children().hide();=0A=
		$( "<div>" ).text( message ).appendTo( this.liveRegion );=0A=
	}=0A=
});=0A=
=0A=
var autocomplete =3D $.ui.autocomplete;=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Button 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/button/=0A=
 */=0A=
=0A=
=0A=
var lastActive,=0A=
	baseClasses =3D "ui-button ui-widget ui-state-default ui-corner-all",=0A=
	typeClasses =3D "ui-button-icons-only ui-button-icon-only =
ui-button-text-icons ui-button-text-icon-primary =
ui-button-text-icon-secondary ui-button-text-only",=0A=
	formResetHandler =3D function() {=0A=
		var form =3D $( this );=0A=
		setTimeout(function() {=0A=
			form.find( ":ui-button" ).button( "refresh" );=0A=
		}, 1 );=0A=
	},=0A=
	radioGroup =3D function( radio ) {=0A=
		var name =3D radio.name,=0A=
			form =3D radio.form,=0A=
			radios =3D $( [] );=0A=
		if ( name ) {=0A=
			name =3D name.replace( /'/g, "\\'" );=0A=
			if ( form ) {=0A=
				radios =3D $( form ).find( "[name=3D'" + name + "'][type=3Dradio]" );=0A=
			} else {=0A=
				radios =3D $( "[name=3D'" + name + "'][type=3Dradio]", =
radio.ownerDocument )=0A=
					.filter(function() {=0A=
						return !this.form;=0A=
					});=0A=
			}=0A=
		}=0A=
		return radios;=0A=
	};=0A=
=0A=
$.widget( "ui.button", {=0A=
	version: "1.11.1",=0A=
	defaultElement: "<button>",=0A=
	options: {=0A=
		disabled: null,=0A=
		text: true,=0A=
		label: null,=0A=
		icons: {=0A=
			primary: null,=0A=
			secondary: null=0A=
		}=0A=
	},=0A=
	_create: function() {=0A=
		this.element.closest( "form" )=0A=
			.unbind( "reset" + this.eventNamespace )=0A=
			.bind( "reset" + this.eventNamespace, formResetHandler );=0A=
=0A=
		if ( typeof this.options.disabled !=3D=3D "boolean" ) {=0A=
			this.options.disabled =3D !!this.element.prop( "disabled" );=0A=
		} else {=0A=
			this.element.prop( "disabled", this.options.disabled );=0A=
		}=0A=
=0A=
		this._determineButtonType();=0A=
		this.hasTitle =3D !!this.buttonElement.attr( "title" );=0A=
=0A=
		var that =3D this,=0A=
			options =3D this.options,=0A=
			toggleButton =3D this.type =3D=3D=3D "checkbox" || this.type =
=3D=3D=3D "radio",=0A=
			activeClass =3D !toggleButton ? "ui-state-active" : "";=0A=
=0A=
		if ( options.label =3D=3D=3D null ) {=0A=
			options.label =3D (this.type =3D=3D=3D "input" ? =
this.buttonElement.val() : this.buttonElement.html());=0A=
		}=0A=
=0A=
		this._hoverable( this.buttonElement );=0A=
=0A=
		this.buttonElement=0A=
			.addClass( baseClasses )=0A=
			.attr( "role", "button" )=0A=
			.bind( "mouseenter" + this.eventNamespace, function() {=0A=
				if ( options.disabled ) {=0A=
					return;=0A=
				}=0A=
				if ( this =3D=3D=3D lastActive ) {=0A=
					$( this ).addClass( "ui-state-active" );=0A=
				}=0A=
			})=0A=
			.bind( "mouseleave" + this.eventNamespace, function() {=0A=
				if ( options.disabled ) {=0A=
					return;=0A=
				}=0A=
				$( this ).removeClass( activeClass );=0A=
			})=0A=
			.bind( "click" + this.eventNamespace, function( event ) {=0A=
				if ( options.disabled ) {=0A=
					event.preventDefault();=0A=
					event.stopImmediatePropagation();=0A=
				}=0A=
			});=0A=
=0A=
		// Can't use _focusable() because the element that receives focus=0A=
		// and the element that gets the ui-state-focus class are different=0A=
		this._on({=0A=
			focus: function() {=0A=
				this.buttonElement.addClass( "ui-state-focus" );=0A=
			},=0A=
			blur: function() {=0A=
				this.buttonElement.removeClass( "ui-state-focus" );=0A=
			}=0A=
		});=0A=
=0A=
		if ( toggleButton ) {=0A=
			this.element.bind( "change" + this.eventNamespace, function() {=0A=
				that.refresh();=0A=
			});=0A=
		}=0A=
=0A=
		if ( this.type =3D=3D=3D "checkbox" ) {=0A=
			this.buttonElement.bind( "click" + this.eventNamespace, function() {=0A=
				if ( options.disabled ) {=0A=
					return false;=0A=
				}=0A=
			});=0A=
		} else if ( this.type =3D=3D=3D "radio" ) {=0A=
			this.buttonElement.bind( "click" + this.eventNamespace, function() {=0A=
				if ( options.disabled ) {=0A=
					return false;=0A=
				}=0A=
				$( this ).addClass( "ui-state-active" );=0A=
				that.buttonElement.attr( "aria-pressed", "true" );=0A=
=0A=
				var radio =3D that.element[ 0 ];=0A=
				radioGroup( radio )=0A=
					.not( radio )=0A=
					.map(function() {=0A=
						return $( this ).button( "widget" )[ 0 ];=0A=
					})=0A=
					.removeClass( "ui-state-active" )=0A=
					.attr( "aria-pressed", "false" );=0A=
			});=0A=
		} else {=0A=
			this.buttonElement=0A=
				.bind( "mousedown" + this.eventNamespace, function() {=0A=
					if ( options.disabled ) {=0A=
						return false;=0A=
					}=0A=
					$( this ).addClass( "ui-state-active" );=0A=
					lastActive =3D this;=0A=
					that.document.one( "mouseup", function() {=0A=
						lastActive =3D null;=0A=
					});=0A=
				})=0A=
				.bind( "mouseup" + this.eventNamespace, function() {=0A=
					if ( options.disabled ) {=0A=
						return false;=0A=
					}=0A=
					$( this ).removeClass( "ui-state-active" );=0A=
				})=0A=
				.bind( "keydown" + this.eventNamespace, function(event) {=0A=
					if ( options.disabled ) {=0A=
						return false;=0A=
					}=0A=
					if ( event.keyCode =3D=3D=3D $.ui.keyCode.SPACE || event.keyCode =
=3D=3D=3D $.ui.keyCode.ENTER ) {=0A=
						$( this ).addClass( "ui-state-active" );=0A=
					}=0A=
				})=0A=
				// see #8559, we bind to blur here in case the button element loses=0A=
				// focus between keydown and keyup, it would be left in an "active" =
state=0A=
				.bind( "keyup" + this.eventNamespace + " blur" + =
this.eventNamespace, function() {=0A=
					$( this ).removeClass( "ui-state-active" );=0A=
				});=0A=
=0A=
			if ( this.buttonElement.is("a") ) {=0A=
				this.buttonElement.keyup(function(event) {=0A=
					if ( event.keyCode =3D=3D=3D $.ui.keyCode.SPACE ) {=0A=
						// TODO pass through original event correctly (just as 2nd =
argument doesn't work)=0A=
						$( this ).click();=0A=
					}=0A=
				});=0A=
			}=0A=
		}=0A=
=0A=
		this._setOption( "disabled", options.disabled );=0A=
		this._resetButton();=0A=
	},=0A=
=0A=
	_determineButtonType: function() {=0A=
		var ancestor, labelSelector, checked;=0A=
=0A=
		if ( this.element.is("[type=3Dcheckbox]") ) {=0A=
			this.type =3D "checkbox";=0A=
		} else if ( this.element.is("[type=3Dradio]") ) {=0A=
			this.type =3D "radio";=0A=
		} else if ( this.element.is("input") ) {=0A=
			this.type =3D "input";=0A=
		} else {=0A=
			this.type =3D "button";=0A=
		}=0A=
=0A=
		if ( this.type =3D=3D=3D "checkbox" || this.type =3D=3D=3D "radio" ) {=0A=
			// we don't search against the document in case the element=0A=
			// is disconnected from the DOM=0A=
			ancestor =3D this.element.parents().last();=0A=
			labelSelector =3D "label[for=3D'" + this.element.attr("id") + "']";=0A=
			this.buttonElement =3D ancestor.find( labelSelector );=0A=
			if ( !this.buttonElement.length ) {=0A=
				ancestor =3D ancestor.length ? ancestor.siblings() : =
this.element.siblings();=0A=
				this.buttonElement =3D ancestor.filter( labelSelector );=0A=
				if ( !this.buttonElement.length ) {=0A=
					this.buttonElement =3D ancestor.find( labelSelector );=0A=
				}=0A=
			}=0A=
			this.element.addClass( "ui-helper-hidden-accessible" );=0A=
=0A=
			checked =3D this.element.is( ":checked" );=0A=
			if ( checked ) {=0A=
				this.buttonElement.addClass( "ui-state-active" );=0A=
			}=0A=
			this.buttonElement.prop( "aria-pressed", checked );=0A=
		} else {=0A=
			this.buttonElement =3D this.element;=0A=
		}=0A=
	},=0A=
=0A=
	widget: function() {=0A=
		return this.buttonElement;=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		this.element=0A=
			.removeClass( "ui-helper-hidden-accessible" );=0A=
		this.buttonElement=0A=
			.removeClass( baseClasses + " ui-state-active " + typeClasses )=0A=
			.removeAttr( "role" )=0A=
			.removeAttr( "aria-pressed" )=0A=
			.html( this.buttonElement.find(".ui-button-text").html() );=0A=
=0A=
		if ( !this.hasTitle ) {=0A=
			this.buttonElement.removeAttr( "title" );=0A=
		}=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		this._super( key, value );=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			this.widget().toggleClass( "ui-state-disabled", !!value );=0A=
			this.element.prop( "disabled", !!value );=0A=
			if ( value ) {=0A=
				if ( this.type =3D=3D=3D "checkbox" || this.type =3D=3D=3D "radio" ) =
{=0A=
					this.buttonElement.removeClass( "ui-state-focus" );=0A=
				} else {=0A=
					this.buttonElement.removeClass( "ui-state-focus ui-state-active" );=0A=
				}=0A=
			}=0A=
			return;=0A=
		}=0A=
		this._resetButton();=0A=
	},=0A=
=0A=
	refresh: function() {=0A=
		//See #8237 & #8828=0A=
		var isDisabled =3D this.element.is( "input, button" ) ? =
this.element.is( ":disabled" ) : this.element.hasClass( =
"ui-button-disabled" );=0A=
=0A=
		if ( isDisabled !=3D=3D this.options.disabled ) {=0A=
			this._setOption( "disabled", isDisabled );=0A=
		}=0A=
		if ( this.type =3D=3D=3D "radio" ) {=0A=
			radioGroup( this.element[0] ).each(function() {=0A=
				if ( $( this ).is( ":checked" ) ) {=0A=
					$( this ).button( "widget" )=0A=
						.addClass( "ui-state-active" )=0A=
						.attr( "aria-pressed", "true" );=0A=
				} else {=0A=
					$( this ).button( "widget" )=0A=
						.removeClass( "ui-state-active" )=0A=
						.attr( "aria-pressed", "false" );=0A=
				}=0A=
			});=0A=
		} else if ( this.type =3D=3D=3D "checkbox" ) {=0A=
			if ( this.element.is( ":checked" ) ) {=0A=
				this.buttonElement=0A=
					.addClass( "ui-state-active" )=0A=
					.attr( "aria-pressed", "true" );=0A=
			} else {=0A=
				this.buttonElement=0A=
					.removeClass( "ui-state-active" )=0A=
					.attr( "aria-pressed", "false" );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	_resetButton: function() {=0A=
		if ( this.type =3D=3D=3D "input" ) {=0A=
			if ( this.options.label ) {=0A=
				this.element.val( this.options.label );=0A=
			}=0A=
			return;=0A=
		}=0A=
		var buttonElement =3D this.buttonElement.removeClass( typeClasses ),=0A=
			buttonText =3D $( "<span></span>", this.document[0] )=0A=
				.addClass( "ui-button-text" )=0A=
				.html( this.options.label )=0A=
				.appendTo( buttonElement.empty() )=0A=
				.text(),=0A=
			icons =3D this.options.icons,=0A=
			multipleIcons =3D icons.primary && icons.secondary,=0A=
			buttonClasses =3D [];=0A=
=0A=
		if ( icons.primary || icons.secondary ) {=0A=
			if ( this.options.text ) {=0A=
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : =
( icons.primary ? "-primary" : "-secondary" ) ) );=0A=
			}=0A=
=0A=
			if ( icons.primary ) {=0A=
				buttonElement.prepend( "<span class=3D'ui-button-icon-primary =
ui-icon " + icons.primary + "'></span>" );=0A=
			}=0A=
=0A=
			if ( icons.secondary ) {=0A=
				buttonElement.append( "<span class=3D'ui-button-icon-secondary =
ui-icon " + icons.secondary + "'></span>" );=0A=
			}=0A=
=0A=
			if ( !this.options.text ) {=0A=
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : =
"ui-button-icon-only" );=0A=
=0A=
				if ( !this.hasTitle ) {=0A=
					buttonElement.attr( "title", $.trim( buttonText ) );=0A=
				}=0A=
			}=0A=
		} else {=0A=
			buttonClasses.push( "ui-button-text-only" );=0A=
		}=0A=
		buttonElement.addClass( buttonClasses.join( " " ) );=0A=
	}=0A=
});=0A=
=0A=
$.widget( "ui.buttonset", {=0A=
	version: "1.11.1",=0A=
	options: {=0A=
		items: "button, input[type=3Dbutton], input[type=3Dsubmit], =
input[type=3Dreset], input[type=3Dcheckbox], input[type=3Dradio], a, =
:data(ui-button)"=0A=
	},=0A=
=0A=
	_create: function() {=0A=
		this.element.addClass( "ui-buttonset" );=0A=
	},=0A=
=0A=
	_init: function() {=0A=
		this.refresh();=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			this.buttons.button( "option", key, value );=0A=
		}=0A=
=0A=
		this._super( key, value );=0A=
	},=0A=
=0A=
	refresh: function() {=0A=
		var rtl =3D this.element.css( "direction" ) =3D=3D=3D "rtl",=0A=
			allButtons =3D this.element.find( this.options.items ),=0A=
			existingButtons =3D allButtons.filter( ":ui-button" );=0A=
=0A=
		// Initialize new buttons=0A=
		allButtons.not( ":ui-button" ).button();=0A=
=0A=
		// Refresh existing buttons=0A=
		existingButtons.button( "refresh" );=0A=
=0A=
		this.buttons =3D allButtons=0A=
			.map(function() {=0A=
				return $( this ).button( "widget" )[ 0 ];=0A=
			})=0A=
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )=0A=
				.filter( ":first" )=0A=
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )=0A=
				.end()=0A=
				.filter( ":last" )=0A=
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )=0A=
				.end()=0A=
			.end();=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		this.element.removeClass( "ui-buttonset" );=0A=
		this.buttons=0A=
			.map(function() {=0A=
				return $( this ).button( "widget" )[ 0 ];=0A=
			})=0A=
				.removeClass( "ui-corner-left ui-corner-right" )=0A=
			.end()=0A=
			.button( "destroy" );=0A=
	}=0A=
});=0A=
=0A=
var button =3D $.ui.button;=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Datepicker 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/datepicker/=0A=
 */=0A=
=0A=
=0A=
$.extend($.ui, { datepicker: { version: "1.11.1" } });=0A=
=0A=
var datepicker_instActive;=0A=
=0A=
function datepicker_getZindex( elem ) {=0A=
	var position, value;=0A=
	while ( elem.length && elem[ 0 ] !=3D=3D document ) {=0A=
		// Ignore z-index if position is set to a value where z-index is =
ignored by the browser=0A=
		// This makes behavior of this function consistent across browsers=0A=
		// WebKit always returns auto if the element is positioned=0A=
		position =3D elem.css( "position" );=0A=
		if ( position =3D=3D=3D "absolute" || position =3D=3D=3D "relative" || =
position =3D=3D=3D "fixed" ) {=0A=
			// IE returns 0 when zIndex is not specified=0A=
			// other browsers return a string=0A=
			// we ignore the case of nested elements with an explicit value of 0=0A=
			// <div style=3D"z-index: -10;"><div style=3D"z-index: =
0;"></div></div>=0A=
			value =3D parseInt( elem.css( "zIndex" ), 10 );=0A=
			if ( !isNaN( value ) && value !=3D=3D 0 ) {=0A=
				return value;=0A=
			}=0A=
		}=0A=
		elem =3D elem.parent();=0A=
	}=0A=
=0A=
	return 0;=0A=
}=0A=
/* Date picker manager.=0A=
   Use the singleton instance of this class, $.datepicker, to interact =
with the date picker.=0A=
   Settings for (groups of) date pickers are maintained in an instance =
object,=0A=
   allowing multiple different settings on the same page. */=0A=
=0A=
function Datepicker() {=0A=
	this._curInst =3D null; // The current instance in use=0A=
	this._keyEvent =3D false; // If the last event was a key event=0A=
	this._disabledInputs =3D []; // List of date picker inputs that have =
been disabled=0A=
	this._datepickerShowing =3D false; // True if the popup picker is =
showing , false if not=0A=
	this._inDialog =3D false; // True if showing within a "dialog", false =
if not=0A=
	this._mainDivId =3D "ui-datepicker-div"; // The ID of the main =
datepicker division=0A=
	this._inlineClass =3D "ui-datepicker-inline"; // The name of the inline =
marker class=0A=
	this._appendClass =3D "ui-datepicker-append"; // The name of the append =
marker class=0A=
	this._triggerClass =3D "ui-datepicker-trigger"; // The name of the =
trigger marker class=0A=
	this._dialogClass =3D "ui-datepicker-dialog"; // The name of the dialog =
marker class=0A=
	this._disableClass =3D "ui-datepicker-disabled"; // The name of the =
disabled covering marker class=0A=
	this._unselectableClass =3D "ui-datepicker-unselectable"; // The name =
of the unselectable cell marker class=0A=
	this._currentClass =3D "ui-datepicker-current-day"; // The name of the =
current day marker class=0A=
	this._dayOverClass =3D "ui-datepicker-days-cell-over"; // The name of =
the day hover marker class=0A=
	this.regional =3D []; // Available regional settings, indexed by =
language code=0A=
	this.regional[""] =3D { // Default regional settings=0A=
		closeText: "Done", // Display text for close link=0A=
		prevText: "Prev", // Display text for previous month link=0A=
		nextText: "Next", // Display text for next month link=0A=
		currentText: "Today", // Display text for current month link=0A=
		monthNames: ["January","February","March","April","May","June",=0A=
			"July","August","September","October","November","December"], // =
Names of months for drop-down and formatting=0A=
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", =
"Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting=0A=
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", =
"Friday", "Saturday"], // For formatting=0A=
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // =
For formatting=0A=
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings =
for days starting at Sunday=0A=
		weekHeader: "Wk", // Column header for week of the year=0A=
		dateFormat: "mm/dd/yy", // See format options on parseDate=0A=
		firstDay: 0, // The first day of the week, Sun =3D 0, Mon =3D 1, ...=0A=
		isRTL: false, // True if right-to-left language, false if left-to-right=0A=
		showMonthAfterYear: false, // True if the year select precedes month, =
false for month then year=0A=
		yearSuffix: "" // Additional text to append to the year in the month =
headers=0A=
	};=0A=
	this._defaults =3D { // Global defaults for all the date picker =
instances=0A=
		showOn: "focus", // "focus" for popup on focus,=0A=
			// "button" for trigger button, or "both" for either=0A=
		showAnim: "fadeIn", // Name of jQuery animation for popup=0A=
		showOptions: {}, // Options for enhanced animations=0A=
		defaultDate: null, // Used when field is blank: actual date,=0A=
			// +/-number for offset from today, null for today=0A=
		appendText: "", // Display text following the input box, e.g. showing =
the format=0A=
		buttonText: "...", // Text for trigger button=0A=
		buttonImage: "", // URL for trigger button image=0A=
		buttonImageOnly: false, // True if the image appears alone, false if =
it appears on a button=0A=
		hideIfNoPrevNext: false, // True to hide next/previous month links=0A=
			// if not applicable, false to just disable them=0A=
		navigationAsDateFormat: false, // True if date formatting applied to =
prev/today/next links=0A=
		gotoCurrent: false, // True if today link goes back to current =
selection instead=0A=
		changeMonth: false, // True if month can be selected directly, false =
if only prev/next=0A=
		changeYear: false, // True if year can be selected directly, false if =
only prev/next=0A=
		yearRange: "c-10:c+10", // Range of years to display in drop-down,=0A=
			// either relative to today's year (-nn:+nn), relative to currently =
displayed year=0A=
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above =
(nnnn:-n)=0A=
		showOtherMonths: false, // True to show dates in other months, false =
to leave blank=0A=
		selectOtherMonths: false, // True to allow selection of dates in other =
months, false for unselectable=0A=
		showWeek: false, // True to show week of the year, false to not show it=0A=
		calculateWeek: this.iso8601Week, // How to calculate the week of the =
year,=0A=
			// takes a Date and returns the number of the week for it=0A=
		shortYearCutoff: "+10", // Short year values < this are in the current =
century,=0A=
			// > this are in the previous century,=0A=
			// string value starting with "+" for current year + value=0A=
		minDate: null, // The earliest selectable date, or null for no limit=0A=
		maxDate: null, // The latest selectable date, or null for no limit=0A=
		duration: "fast", // Duration of display/closure=0A=
		beforeShowDay: null, // Function that takes a date and returns an =
array with=0A=
			// [0] =3D true if selectable, false if not, [1] =3D custom CSS class =
name(s) or "",=0A=
			// [2] =3D cell title (optional), e.g. $.datepicker.noWeekends=0A=
		beforeShow: null, // Function that takes an input field and=0A=
			// returns a set of custom settings for the date picker=0A=
		onSelect: null, // Define a callback function when a date is selected=0A=
		onChangeMonthYear: null, // Define a callback function when the month =
or year is changed=0A=
		onClose: null, // Define a callback function when the datepicker is =
closed=0A=
		numberOfMonths: 1, // Number of months to show at a time=0A=
		showCurrentAtPos: 0, // The position in multipe months at which to =
show the current month (starting at 0)=0A=
		stepMonths: 1, // Number of months to step back/forward=0A=
		stepBigMonths: 12, // Number of months to step back/forward for the =
big links=0A=
		altField: "", // Selector for an alternate field to store selected =
dates into=0A=
		altFormat: "", // The date format to use for the alternate field=0A=
		constrainInput: true, // The input is constrained by the current date =
format=0A=
		showButtonPanel: false, // True to show button panel, false to not =
show it=0A=
		autoSize: false, // True to size the input for the date format, false =
to leave as is=0A=
		disabled: false // The initial disabled state=0A=
	};=0A=
	$.extend(this._defaults, this.regional[""]);=0A=
	this.regional.en =3D $.extend( true, {}, this.regional[ "" ]);=0A=
	this.regional[ "en-US" ] =3D $.extend( true, {}, this.regional.en );=0A=
	this.dpDiv =3D datepicker_bindHover($("<div id=3D'" + this._mainDivId + =
"' class=3D'ui-datepicker ui-widget ui-widget-content ui-helper-clearfix =
ui-corner-all'></div>"));=0A=
}=0A=
=0A=
$.extend(Datepicker.prototype, {=0A=
	/* Class name added to elements to indicate already configured with a =
date picker. */=0A=
	markerClassName: "hasDatepicker",=0A=
=0A=
	//Keep track of the maximum number of rows displayed (see #7043)=0A=
	maxRows: 4,=0A=
=0A=
	// TODO rename to "widget" when switching to widget factory=0A=
	_widgetDatepicker: function() {=0A=
		return this.dpDiv;=0A=
	},=0A=
=0A=
	/* Override the default settings for all instances of the date picker.=0A=
	 * @param  settings  object - the new settings to use as defaults =
(anonymous object)=0A=
	 * @return the manager object=0A=
	 */=0A=
	setDefaults: function(settings) {=0A=
		datepicker_extendRemove(this._defaults, settings || {});=0A=
		return this;=0A=
	},=0A=
=0A=
	/* Attach the date picker to a jQuery selection.=0A=
	 * @param  target	element - the target input field or division or span=0A=
	 * @param  settings  object - the new settings to use for this date =
picker instance (anonymous)=0A=
	 */=0A=
	_attachDatepicker: function(target, settings) {=0A=
		var nodeName, inline, inst;=0A=
		nodeName =3D target.nodeName.toLowerCase();=0A=
		inline =3D (nodeName =3D=3D=3D "div" || nodeName =3D=3D=3D "span");=0A=
		if (!target.id) {=0A=
			this.uuid +=3D 1;=0A=
			target.id =3D "dp" + this.uuid;=0A=
		}=0A=
		inst =3D this._newInst($(target), inline);=0A=
		inst.settings =3D $.extend({}, settings || {});=0A=
		if (nodeName =3D=3D=3D "input") {=0A=
			this._connectDatepicker(target, inst);=0A=
		} else if (inline) {=0A=
			this._inlineDatepicker(target, inst);=0A=
		}=0A=
	},=0A=
=0A=
	/* Create a new instance object. */=0A=
	_newInst: function(target, inline) {=0A=
		var id =3D target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // =
escape jQuery meta chars=0A=
		return {id: id, input: target, // associated target=0A=
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current =
selection=0A=
			drawMonth: 0, drawYear: 0, // month being drawn=0A=
			inline: inline, // is datepicker inline or not=0A=
			dpDiv: (!inline ? this.dpDiv : // presentation div=0A=
			datepicker_bindHover($("<div class=3D'" + this._inlineClass + " =
ui-datepicker ui-widget ui-widget-content ui-helper-clearfix =
ui-corner-all'></div>")))};=0A=
	},=0A=
=0A=
	/* Attach the date picker to an input field. */=0A=
	_connectDatepicker: function(target, inst) {=0A=
		var input =3D $(target);=0A=
		inst.append =3D $([]);=0A=
		inst.trigger =3D $([]);=0A=
		if (input.hasClass(this.markerClassName)) {=0A=
			return;=0A=
		}=0A=
		this._attachments(input, inst);=0A=
		input.addClass(this.markerClassName).keydown(this._doKeyDown).=0A=
			keypress(this._doKeyPress).keyup(this._doKeyUp);=0A=
		this._autoSize(inst);=0A=
		$.data(target, "datepicker", inst);=0A=
		//If disabled option is true, disable the datepicker once it has been =
attached to the input (see ticket #5665)=0A=
		if( inst.settings.disabled ) {=0A=
			this._disableDatepicker( target );=0A=
		}=0A=
	},=0A=
=0A=
	/* Make attachments based on settings. */=0A=
	_attachments: function(input, inst) {=0A=
		var showOn, buttonText, buttonImage,=0A=
			appendText =3D this._get(inst, "appendText"),=0A=
			isRTL =3D this._get(inst, "isRTL");=0A=
=0A=
		if (inst.append) {=0A=
			inst.append.remove();=0A=
		}=0A=
		if (appendText) {=0A=
			inst.append =3D $("<span class=3D'" + this._appendClass + "'>" + =
appendText + "</span>");=0A=
			input[isRTL ? "before" : "after"](inst.append);=0A=
		}=0A=
=0A=
		input.unbind("focus", this._showDatepicker);=0A=
=0A=
		if (inst.trigger) {=0A=
			inst.trigger.remove();=0A=
		}=0A=
=0A=
		showOn =3D this._get(inst, "showOn");=0A=
		if (showOn =3D=3D=3D "focus" || showOn =3D=3D=3D "both") { // pop-up =
date picker when in the marked field=0A=
			input.focus(this._showDatepicker);=0A=
		}=0A=
		if (showOn =3D=3D=3D "button" || showOn =3D=3D=3D "both") { // pop-up =
date picker when button clicked=0A=
			buttonText =3D this._get(inst, "buttonText");=0A=
			buttonImage =3D this._get(inst, "buttonImage");=0A=
			inst.trigger =3D $(this._get(inst, "buttonImageOnly") ?=0A=
				$("<img/>").addClass(this._triggerClass).=0A=
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :=0A=
				$("<button type=3D'button'></button>").addClass(this._triggerClass).=0A=
					html(!buttonImage ? buttonText : $("<img/>").attr(=0A=
					{ src:buttonImage, alt:buttonText, title:buttonText })));=0A=
			input[isRTL ? "before" : "after"](inst.trigger);=0A=
			inst.trigger.click(function() {=0A=
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput =
=3D=3D=3D input[0]) {=0A=
					$.datepicker._hideDatepicker();=0A=
				} else if ($.datepicker._datepickerShowing && =
$.datepicker._lastInput !=3D=3D input[0]) {=0A=
					$.datepicker._hideDatepicker();=0A=
					$.datepicker._showDatepicker(input[0]);=0A=
				} else {=0A=
					$.datepicker._showDatepicker(input[0]);=0A=
				}=0A=
				return false;=0A=
			});=0A=
		}=0A=
	},=0A=
=0A=
	/* Apply the maximum length for the date format. */=0A=
	_autoSize: function(inst) {=0A=
		if (this._get(inst, "autoSize") && !inst.inline) {=0A=
			var findMax, max, maxI, i,=0A=
				date =3D new Date(2009, 12 - 1, 20), // Ensure double digits=0A=
				dateFormat =3D this._get(inst, "dateFormat");=0A=
=0A=
			if (dateFormat.match(/[DM]/)) {=0A=
				findMax =3D function(names) {=0A=
					max =3D 0;=0A=
					maxI =3D 0;=0A=
					for (i =3D 0; i < names.length; i++) {=0A=
						if (names[i].length > max) {=0A=
							max =3D names[i].length;=0A=
							maxI =3D i;=0A=
						}=0A=
					}=0A=
					return maxI;=0A=
				};=0A=
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?=0A=
					"monthNames" : "monthNamesShort"))));=0A=
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?=0A=
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());=0A=
			}=0A=
			inst.input.attr("size", this._formatDate(inst, date).length);=0A=
		}=0A=
	},=0A=
=0A=
	/* Attach an inline date picker to a div. */=0A=
	_inlineDatepicker: function(target, inst) {=0A=
		var divSpan =3D $(target);=0A=
		if (divSpan.hasClass(this.markerClassName)) {=0A=
			return;=0A=
		}=0A=
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);=0A=
		$.data(target, "datepicker", inst);=0A=
		this._setDate(inst, this._getDefaultDate(inst), true);=0A=
		this._updateDatepicker(inst);=0A=
		this._updateAlternate(inst);=0A=
		//If disabled option is true, disable the datepicker before showing it =
(see ticket #5665)=0A=
		if( inst.settings.disabled ) {=0A=
			this._disableDatepicker( target );=0A=
		}=0A=
		// Set display:block in place of inst.dpDiv.show() which won't work on =
disconnected elements=0A=
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a =
detached div has zero height=0A=
		inst.dpDiv.css( "display", "block" );=0A=
	},=0A=
=0A=
	/* Pop-up the date picker in a "dialog" box.=0A=
	 * @param  input element - ignored=0A=
	 * @param  date	string or Date - the initial date to display=0A=
	 * @param  onSelect  function - the function to call when a date is =
selected=0A=
	 * @param  settings  object - update the dialog date picker instance's =
settings (anonymous object)=0A=
	 * @param  pos int[2] - coordinates for the dialog's position within =
the screen or=0A=
	 *					event - with x/y coordinates or=0A=
	 *					leave empty for default (screen centre)=0A=
	 * @return the manager object=0A=
	 */=0A=
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {=0A=
		var id, browserWidth, browserHeight, scrollX, scrollY,=0A=
			inst =3D this._dialogInst; // internal instance=0A=
=0A=
		if (!inst) {=0A=
			this.uuid +=3D 1;=0A=
			id =3D "dp" + this.uuid;=0A=
			this._dialogInput =3D $("<input type=3D'text' id=3D'" + id +=0A=
				"' style=3D'position: absolute; top: -100px; width: 0px;'/>");=0A=
			this._dialogInput.keydown(this._doKeyDown);=0A=
			$("body").append(this._dialogInput);=0A=
			inst =3D this._dialogInst =3D this._newInst(this._dialogInput, false);=0A=
			inst.settings =3D {};=0A=
			$.data(this._dialogInput[0], "datepicker", inst);=0A=
		}=0A=
		datepicker_extendRemove(inst.settings, settings || {});=0A=
		date =3D (date && date.constructor =3D=3D=3D Date ? =
this._formatDate(inst, date) : date);=0A=
		this._dialogInput.val(date);=0A=
=0A=
		this._pos =3D (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : =
null);=0A=
		if (!this._pos) {=0A=
			browserWidth =3D document.documentElement.clientWidth;=0A=
			browserHeight =3D document.documentElement.clientHeight;=0A=
			scrollX =3D document.documentElement.scrollLeft || =
document.body.scrollLeft;=0A=
			scrollY =3D document.documentElement.scrollTop || =
document.body.scrollTop;=0A=
			this._pos =3D // should use actual width/height below=0A=
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + =
scrollY];=0A=
		}=0A=
=0A=
		// move input on screen for focus, but hidden behind dialog=0A=
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", =
this._pos[1] + "px");=0A=
		inst.settings.onSelect =3D onSelect;=0A=
		this._inDialog =3D true;=0A=
		this.dpDiv.addClass(this._dialogClass);=0A=
		this._showDatepicker(this._dialogInput[0]);=0A=
		if ($.blockUI) {=0A=
			$.blockUI(this.dpDiv);=0A=
		}=0A=
		$.data(this._dialogInput[0], "datepicker", inst);=0A=
		return this;=0A=
	},=0A=
=0A=
	/* Detach a datepicker from its control.=0A=
	 * @param  target	element - the target input field or division or span=0A=
	 */=0A=
	_destroyDatepicker: function(target) {=0A=
		var nodeName,=0A=
			$target =3D $(target),=0A=
			inst =3D $.data(target, "datepicker");=0A=
=0A=
		if (!$target.hasClass(this.markerClassName)) {=0A=
			return;=0A=
		}=0A=
=0A=
		nodeName =3D target.nodeName.toLowerCase();=0A=
		$.removeData(target, "datepicker");=0A=
		if (nodeName =3D=3D=3D "input") {=0A=
			inst.append.remove();=0A=
			inst.trigger.remove();=0A=
			$target.removeClass(this.markerClassName).=0A=
				unbind("focus", this._showDatepicker).=0A=
				unbind("keydown", this._doKeyDown).=0A=
				unbind("keypress", this._doKeyPress).=0A=
				unbind("keyup", this._doKeyUp);=0A=
		} else if (nodeName =3D=3D=3D "div" || nodeName =3D=3D=3D "span") {=0A=
			$target.removeClass(this.markerClassName).empty();=0A=
		}=0A=
	},=0A=
=0A=
	/* Enable the date picker to a jQuery selection.=0A=
	 * @param  target	element - the target input field or division or span=0A=
	 */=0A=
	_enableDatepicker: function(target) {=0A=
		var nodeName, inline,=0A=
			$target =3D $(target),=0A=
			inst =3D $.data(target, "datepicker");=0A=
=0A=
		if (!$target.hasClass(this.markerClassName)) {=0A=
			return;=0A=
		}=0A=
=0A=
		nodeName =3D target.nodeName.toLowerCase();=0A=
		if (nodeName =3D=3D=3D "input") {=0A=
			target.disabled =3D false;=0A=
			inst.trigger.filter("button").=0A=
				each(function() { this.disabled =3D false; }).end().=0A=
				filter("img").css({opacity: "1.0", cursor: ""});=0A=
		} else if (nodeName =3D=3D=3D "div" || nodeName =3D=3D=3D "span") {=0A=
			inline =3D $target.children("." + this._inlineClass);=0A=
			inline.children().removeClass("ui-state-disabled");=0A=
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").=0A=
				prop("disabled", false);=0A=
		}=0A=
		this._disabledInputs =3D $.map(this._disabledInputs,=0A=
			function(value) { return (value =3D=3D=3D target ? null : value); }); =
// delete entry=0A=
	},=0A=
=0A=
	/* Disable the date picker to a jQuery selection.=0A=
	 * @param  target	element - the target input field or division or span=0A=
	 */=0A=
	_disableDatepicker: function(target) {=0A=
		var nodeName, inline,=0A=
			$target =3D $(target),=0A=
			inst =3D $.data(target, "datepicker");=0A=
=0A=
		if (!$target.hasClass(this.markerClassName)) {=0A=
			return;=0A=
		}=0A=
=0A=
		nodeName =3D target.nodeName.toLowerCase();=0A=
		if (nodeName =3D=3D=3D "input") {=0A=
			target.disabled =3D true;=0A=
			inst.trigger.filter("button").=0A=
				each(function() { this.disabled =3D true; }).end().=0A=
				filter("img").css({opacity: "0.5", cursor: "default"});=0A=
		} else if (nodeName =3D=3D=3D "div" || nodeName =3D=3D=3D "span") {=0A=
			inline =3D $target.children("." + this._inlineClass);=0A=
			inline.children().addClass("ui-state-disabled");=0A=
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").=0A=
				prop("disabled", true);=0A=
		}=0A=
		this._disabledInputs =3D $.map(this._disabledInputs,=0A=
			function(value) { return (value =3D=3D=3D target ? null : value); }); =
// delete entry=0A=
		this._disabledInputs[this._disabledInputs.length] =3D target;=0A=
	},=0A=
=0A=
	/* Is the first field in a jQuery collection disabled as a datepicker?=0A=
	 * @param  target	element - the target input field or division or span=0A=
	 * @return boolean - true if disabled, false if enabled=0A=
	 */=0A=
	_isDisabledDatepicker: function(target) {=0A=
		if (!target) {=0A=
			return false;=0A=
		}=0A=
		for (var i =3D 0; i < this._disabledInputs.length; i++) {=0A=
			if (this._disabledInputs[i] =3D=3D=3D target) {=0A=
				return true;=0A=
			}=0A=
		}=0A=
		return false;=0A=
	},=0A=
=0A=
	/* Retrieve the instance data for the target control.=0A=
	 * @param  target  element - the target input field or division or span=0A=
	 * @return  object - the associated instance data=0A=
	 * @throws  error if a jQuery problem getting data=0A=
	 */=0A=
	_getInst: function(target) {=0A=
		try {=0A=
			return $.data(target, "datepicker");=0A=
		}=0A=
		catch (err) {=0A=
			throw "Missing instance data for this datepicker";=0A=
		}=0A=
	},=0A=
=0A=
	/* Update or retrieve the settings for a date picker attached to an =
input field or division.=0A=
	 * @param  target  element - the target input field or division or span=0A=
	 * @param  name	object - the new settings to update or=0A=
	 *				string - the name of the setting to change or retrieve,=0A=
	 *				when retrieving also "all" for all instance settings or=0A=
	 *				"defaults" for all global defaults=0A=
	 * @param  value   any - the new value for the setting=0A=
	 *				(omit if above is an object or to retrieve a value)=0A=
	 */=0A=
	_optionDatepicker: function(target, name, value) {=0A=
		var settings, date, minDate, maxDate,=0A=
			inst =3D this._getInst(target);=0A=
=0A=
		if (arguments.length =3D=3D=3D 2 && typeof name =3D=3D=3D "string") {=0A=
			return (name =3D=3D=3D "defaults" ? $.extend({}, =
$.datepicker._defaults) :=0A=
				(inst ? (name =3D=3D=3D "all" ? $.extend({}, inst.settings) :=0A=
				this._get(inst, name)) : null));=0A=
		}=0A=
=0A=
		settings =3D name || {};=0A=
		if (typeof name =3D=3D=3D "string") {=0A=
			settings =3D {};=0A=
			settings[name] =3D value;=0A=
		}=0A=
=0A=
		if (inst) {=0A=
			if (this._curInst =3D=3D=3D inst) {=0A=
				this._hideDatepicker();=0A=
			}=0A=
=0A=
			date =3D this._getDateDatepicker(target, true);=0A=
			minDate =3D this._getMinMaxDate(inst, "min");=0A=
			maxDate =3D this._getMinMaxDate(inst, "max");=0A=
			datepicker_extendRemove(inst.settings, settings);=0A=
			// reformat the old minDate/maxDate values if dateFormat changes and =
a new minDate/maxDate isn't provided=0A=
			if (minDate !=3D=3D null && settings.dateFormat !=3D=3D undefined && =
settings.minDate =3D=3D=3D undefined) {=0A=
				inst.settings.minDate =3D this._formatDate(inst, minDate);=0A=
			}=0A=
			if (maxDate !=3D=3D null && settings.dateFormat !=3D=3D undefined && =
settings.maxDate =3D=3D=3D undefined) {=0A=
				inst.settings.maxDate =3D this._formatDate(inst, maxDate);=0A=
			}=0A=
			if ( "disabled" in settings ) {=0A=
				if ( settings.disabled ) {=0A=
					this._disableDatepicker(target);=0A=
				} else {=0A=
					this._enableDatepicker(target);=0A=
				}=0A=
			}=0A=
			this._attachments($(target), inst);=0A=
			this._autoSize(inst);=0A=
			this._setDate(inst, date);=0A=
			this._updateAlternate(inst);=0A=
			this._updateDatepicker(inst);=0A=
		}=0A=
	},=0A=
=0A=
	// change method deprecated=0A=
	_changeDatepicker: function(target, name, value) {=0A=
		this._optionDatepicker(target, name, value);=0A=
	},=0A=
=0A=
	/* Redraw the date picker attached to an input field or division.=0A=
	 * @param  target  element - the target input field or division or span=0A=
	 */=0A=
	_refreshDatepicker: function(target) {=0A=
		var inst =3D this._getInst(target);=0A=
		if (inst) {=0A=
			this._updateDatepicker(inst);=0A=
		}=0A=
	},=0A=
=0A=
	/* Set the dates for a jQuery selection.=0A=
	 * @param  target element - the target input field or division or span=0A=
	 * @param  date	Date - the new date=0A=
	 */=0A=
	_setDateDatepicker: function(target, date) {=0A=
		var inst =3D this._getInst(target);=0A=
		if (inst) {=0A=
			this._setDate(inst, date);=0A=
			this._updateDatepicker(inst);=0A=
			this._updateAlternate(inst);=0A=
		}=0A=
	},=0A=
=0A=
	/* Get the date(s) for the first entry in a jQuery selection.=0A=
	 * @param  target element - the target input field or division or span=0A=
	 * @param  noDefault boolean - true if no default date is to be used=0A=
	 * @return Date - the current date=0A=
	 */=0A=
	_getDateDatepicker: function(target, noDefault) {=0A=
		var inst =3D this._getInst(target);=0A=
		if (inst && !inst.inline) {=0A=
			this._setDateFromField(inst, noDefault);=0A=
		}=0A=
		return (inst ? this._getDate(inst) : null);=0A=
	},=0A=
=0A=
	/* Handle keystrokes. */=0A=
	_doKeyDown: function(event) {=0A=
		var onSelect, dateStr, sel,=0A=
			inst =3D $.datepicker._getInst(event.target),=0A=
			handled =3D true,=0A=
			isRTL =3D inst.dpDiv.is(".ui-datepicker-rtl");=0A=
=0A=
		inst._keyEvent =3D true;=0A=
		if ($.datepicker._datepickerShowing) {=0A=
			switch (event.keyCode) {=0A=
				case 9: $.datepicker._hideDatepicker();=0A=
						handled =3D false;=0A=
						break; // hide on tab out=0A=
				case 13: sel =3D $("td." + $.datepicker._dayOverClass + ":not(." +=0A=
									$.datepicker._currentClass + ")", inst.dpDiv);=0A=
						if (sel[0]) {=0A=
							$.datepicker._selectDay(event.target, inst.selectedMonth, =
inst.selectedYear, sel[0]);=0A=
						}=0A=
=0A=
						onSelect =3D $.datepicker._get(inst, "onSelect");=0A=
						if (onSelect) {=0A=
							dateStr =3D $.datepicker._formatDate(inst);=0A=
=0A=
							// trigger custom callback=0A=
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, =
inst]);=0A=
						} else {=0A=
							$.datepicker._hideDatepicker();=0A=
						}=0A=
=0A=
						return false; // don't submit the form=0A=
				case 27: $.datepicker._hideDatepicker();=0A=
						break; // hide on escape=0A=
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?=0A=
							-$.datepicker._get(inst, "stepBigMonths") :=0A=
							-$.datepicker._get(inst, "stepMonths")), "M");=0A=
						break; // previous month/year on page up/+ ctrl=0A=
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?=0A=
							+$.datepicker._get(inst, "stepBigMonths") :=0A=
							+$.datepicker._get(inst, "stepMonths")), "M");=0A=
						break; // next month/year on page down/+ ctrl=0A=
				case 35: if (event.ctrlKey || event.metaKey) {=0A=
							$.datepicker._clearDate(event.target);=0A=
						}=0A=
						handled =3D event.ctrlKey || event.metaKey;=0A=
						break; // clear on ctrl or command +end=0A=
				case 36: if (event.ctrlKey || event.metaKey) {=0A=
							$.datepicker._gotoToday(event.target);=0A=
						}=0A=
						handled =3D event.ctrlKey || event.metaKey;=0A=
						break; // current on ctrl or command +home=0A=
				case 37: if (event.ctrlKey || event.metaKey) {=0A=
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");=0A=
						}=0A=
						handled =3D event.ctrlKey || event.metaKey;=0A=
						// -1 day on ctrl or command +left=0A=
						if (event.originalEvent.altKey) {=0A=
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?=0A=
								-$.datepicker._get(inst, "stepBigMonths") :=0A=
								-$.datepicker._get(inst, "stepMonths")), "M");=0A=
						}=0A=
						// next month/year on alt +left on Mac=0A=
						break;=0A=
				case 38: if (event.ctrlKey || event.metaKey) {=0A=
							$.datepicker._adjustDate(event.target, -7, "D");=0A=
						}=0A=
						handled =3D event.ctrlKey || event.metaKey;=0A=
						break; // -1 week on ctrl or command +up=0A=
				case 39: if (event.ctrlKey || event.metaKey) {=0A=
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");=0A=
						}=0A=
						handled =3D event.ctrlKey || event.metaKey;=0A=
						// +1 day on ctrl or command +right=0A=
						if (event.originalEvent.altKey) {=0A=
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?=0A=
								+$.datepicker._get(inst, "stepBigMonths") :=0A=
								+$.datepicker._get(inst, "stepMonths")), "M");=0A=
						}=0A=
						// next month/year on alt +right=0A=
						break;=0A=
				case 40: if (event.ctrlKey || event.metaKey) {=0A=
							$.datepicker._adjustDate(event.target, +7, "D");=0A=
						}=0A=
						handled =3D event.ctrlKey || event.metaKey;=0A=
						break; // +1 week on ctrl or command +down=0A=
				default: handled =3D false;=0A=
			}=0A=
		} else if (event.keyCode =3D=3D=3D 36 && event.ctrlKey) { // display =
the date picker on ctrl+home=0A=
			$.datepicker._showDatepicker(this);=0A=
		} else {=0A=
			handled =3D false;=0A=
		}=0A=
=0A=
		if (handled) {=0A=
			event.preventDefault();=0A=
			event.stopPropagation();=0A=
		}=0A=
	},=0A=
=0A=
	/* Filter entered characters - based on date format. */=0A=
	_doKeyPress: function(event) {=0A=
		var chars, chr,=0A=
			inst =3D $.datepicker._getInst(event.target);=0A=
=0A=
		if ($.datepicker._get(inst, "constrainInput")) {=0A=
			chars =3D $.datepicker._possibleChars($.datepicker._get(inst, =
"dateFormat"));=0A=
			chr =3D String.fromCharCode(event.charCode =3D=3D null ? =
event.keyCode : event.charCode);=0A=
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || =
chars.indexOf(chr) > -1);=0A=
		}=0A=
	},=0A=
=0A=
	/* Synchronise manual entry and field/alternate field. */=0A=
	_doKeyUp: function(event) {=0A=
		var date,=0A=
			inst =3D $.datepicker._getInst(event.target);=0A=
=0A=
		if (inst.input.val() !=3D=3D inst.lastVal) {=0A=
			try {=0A=
				date =3D $.datepicker.parseDate($.datepicker._get(inst, =
"dateFormat"),=0A=
					(inst.input ? inst.input.val() : null),=0A=
					$.datepicker._getFormatConfig(inst));=0A=
=0A=
				if (date) { // only if valid=0A=
					$.datepicker._setDateFromField(inst);=0A=
					$.datepicker._updateAlternate(inst);=0A=
					$.datepicker._updateDatepicker(inst);=0A=
				}=0A=
			}=0A=
			catch (err) {=0A=
			}=0A=
		}=0A=
		return true;=0A=
	},=0A=
=0A=
	/* Pop-up the date picker for a given input field.=0A=
	 * If false returned from beforeShow event handler do not show.=0A=
	 * @param  input  element - the input field attached to the date picker =
or=0A=
	 *					event - if triggered by focus=0A=
	 */=0A=
	_showDatepicker: function(input) {=0A=
		input =3D input.target || input;=0A=
		if (input.nodeName.toLowerCase() !=3D=3D "input") { // find from =
button/image trigger=0A=
			input =3D $("input", input.parentNode)[0];=0A=
		}=0A=
=0A=
		if ($.datepicker._isDisabledDatepicker(input) || =
$.datepicker._lastInput =3D=3D=3D input) { // already here=0A=
			return;=0A=
		}=0A=
=0A=
		var inst, beforeShow, beforeShowSettings, isFixed,=0A=
			offset, showAnim, duration;=0A=
=0A=
		inst =3D $.datepicker._getInst(input);=0A=
		if ($.datepicker._curInst && $.datepicker._curInst !=3D=3D inst) {=0A=
			$.datepicker._curInst.dpDiv.stop(true, true);=0A=
			if ( inst && $.datepicker._datepickerShowing ) {=0A=
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );=0A=
			}=0A=
		}=0A=
=0A=
		beforeShow =3D $.datepicker._get(inst, "beforeShow");=0A=
		beforeShowSettings =3D beforeShow ? beforeShow.apply(input, [input, =
inst]) : {};=0A=
		if(beforeShowSettings =3D=3D=3D false){=0A=
			return;=0A=
		}=0A=
		datepicker_extendRemove(inst.settings, beforeShowSettings);=0A=
=0A=
		inst.lastVal =3D null;=0A=
		$.datepicker._lastInput =3D input;=0A=
		$.datepicker._setDateFromField(inst);=0A=
=0A=
		if ($.datepicker._inDialog) { // hide cursor=0A=
			input.value =3D "";=0A=
		}=0A=
		if (!$.datepicker._pos) { // position below input=0A=
			$.datepicker._pos =3D $.datepicker._findPos(input);=0A=
			$.datepicker._pos[1] +=3D input.offsetHeight; // add the height=0A=
		}=0A=
=0A=
		isFixed =3D false;=0A=
		$(input).parents().each(function() {=0A=
			isFixed |=3D $(this).css("position") =3D=3D=3D "fixed";=0A=
			return !isFixed;=0A=
		});=0A=
=0A=
		offset =3D {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};=0A=
		$.datepicker._pos =3D null;=0A=
		//to avoid flashes on Firefox=0A=
		inst.dpDiv.empty();=0A=
		// determine sizing offscreen=0A=
		inst.dpDiv.css({position: "absolute", display: "block", top: =
"-1000px"});=0A=
		$.datepicker._updateDatepicker(inst);=0A=
		// fix width for dynamic number of date pickers=0A=
		// and adjust position before showing=0A=
		offset =3D $.datepicker._checkOffset(inst, offset, isFixed);=0A=
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?=0A=
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",=0A=
			left: offset.left + "px", top: offset.top + "px"});=0A=
=0A=
		if (!inst.inline) {=0A=
			showAnim =3D $.datepicker._get(inst, "showAnim");=0A=
			duration =3D $.datepicker._get(inst, "duration");=0A=
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );=0A=
			$.datepicker._datepickerShowing =3D true;=0A=
=0A=
			if ( $.effects && $.effects.effect[ showAnim ] ) {=0A=
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), =
duration);=0A=
			} else {=0A=
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);=0A=
			}=0A=
=0A=
			if ( $.datepicker._shouldFocusInput( inst ) ) {=0A=
				inst.input.focus();=0A=
			}=0A=
=0A=
			$.datepicker._curInst =3D inst;=0A=
		}=0A=
	},=0A=
=0A=
	/* Generate the date picker content. */=0A=
	_updateDatepicker: function(inst) {=0A=
		this.maxRows =3D 4; //Reset the max number of rows being displayed =
(see #7043)=0A=
		datepicker_instActive =3D inst; // for delegate hover events=0A=
		inst.dpDiv.empty().append(this._generateHTML(inst));=0A=
		this._attachHandlers(inst);=0A=
=0A=
		var origyearshtml,=0A=
			numMonths =3D this._getNumberOfMonths(inst),=0A=
			cols =3D numMonths[1],=0A=
			width =3D 17,=0A=
			activeCell =3D inst.dpDiv.find( "." + this._dayOverClass + " a" );=0A=
=0A=
		if ( activeCell.length > 0 ) {=0A=
			datepicker_handleMouseover.apply( activeCell.get( 0 ) );=0A=
		}=0A=
=0A=
		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 =
ui-datepicker-multi-4").width("");=0A=
		if (cols > 1) {=0A=
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", =
(width * cols) + "em");=0A=
		}=0A=
		inst.dpDiv[(numMonths[0] !=3D=3D 1 || numMonths[1] !=3D=3D 1 ? "add" : =
"remove") +=0A=
			"Class"]("ui-datepicker-multi");=0A=
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +=0A=
			"Class"]("ui-datepicker-rtl");=0A=
=0A=
		if (inst =3D=3D=3D $.datepicker._curInst && =
$.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst =
) ) {=0A=
			inst.input.focus();=0A=
		}=0A=
=0A=
		// deffered render of the years select (to avoid flashes on Firefox)=0A=
		if( inst.yearshtml ){=0A=
			origyearshtml =3D inst.yearshtml;=0A=
			setTimeout(function(){=0A=
				//assure that inst.yearshtml didn't change.=0A=
				if( origyearshtml =3D=3D=3D inst.yearshtml && inst.yearshtml ){=0A=
					=
inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.years=
html);=0A=
				}=0A=
				origyearshtml =3D inst.yearshtml =3D null;=0A=
			}, 0);=0A=
		}=0A=
	},=0A=
=0A=
	// #6694 - don't focus the input if it's already focused=0A=
	// this breaks the change event in IE=0A=
	// Support: IE and jQuery <1.9=0A=
	_shouldFocusInput: function( inst ) {=0A=
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( =
":disabled" ) && !inst.input.is( ":focus" );=0A=
	},=0A=
=0A=
	/* Check positioning to remain on screen. */=0A=
	_checkOffset: function(inst, offset, isFixed) {=0A=
		var dpWidth =3D inst.dpDiv.outerWidth(),=0A=
			dpHeight =3D inst.dpDiv.outerHeight(),=0A=
			inputWidth =3D inst.input ? inst.input.outerWidth() : 0,=0A=
			inputHeight =3D inst.input ? inst.input.outerHeight() : 0,=0A=
			viewWidth =3D document.documentElement.clientWidth + (isFixed ? 0 : =
$(document).scrollLeft()),=0A=
			viewHeight =3D document.documentElement.clientHeight + (isFixed ? 0 : =
$(document).scrollTop());=0A=
=0A=
		offset.left -=3D (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : =
0);=0A=
		offset.left -=3D (isFixed && offset.left =3D=3D=3D =
inst.input.offset().left) ? $(document).scrollLeft() : 0;=0A=
		offset.top -=3D (isFixed && offset.top =3D=3D=3D =
(inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;=0A=
=0A=
		// now check if datepicker is showing outside window viewport - move =
to a better place if so.=0A=
		offset.left -=3D Math.min(offset.left, (offset.left + dpWidth > =
viewWidth && viewWidth > dpWidth) ?=0A=
			Math.abs(offset.left + dpWidth - viewWidth) : 0);=0A=
		offset.top -=3D Math.min(offset.top, (offset.top + dpHeight > =
viewHeight && viewHeight > dpHeight) ?=0A=
			Math.abs(dpHeight + inputHeight) : 0);=0A=
=0A=
		return offset;=0A=
	},=0A=
=0A=
	/* Find an object's position on the screen. */=0A=
	_findPos: function(obj) {=0A=
		var position,=0A=
			inst =3D this._getInst(obj),=0A=
			isRTL =3D this._get(inst, "isRTL");=0A=
=0A=
		while (obj && (obj.type =3D=3D=3D "hidden" || obj.nodeType !=3D=3D 1 =
|| $.expr.filters.hidden(obj))) {=0A=
			obj =3D obj[isRTL ? "previousSibling" : "nextSibling"];=0A=
		}=0A=
=0A=
		position =3D $(obj).offset();=0A=
		return [position.left, position.top];=0A=
	},=0A=
=0A=
	/* Hide the date picker from view.=0A=
	 * @param  input  element - the input field attached to the date picker=0A=
	 */=0A=
	_hideDatepicker: function(input) {=0A=
		var showAnim, duration, postProcess, onClose,=0A=
			inst =3D this._curInst;=0A=
=0A=
		if (!inst || (input && inst !=3D=3D $.data(input, "datepicker"))) {=0A=
			return;=0A=
		}=0A=
=0A=
		if (this._datepickerShowing) {=0A=
			showAnim =3D this._get(inst, "showAnim");=0A=
			duration =3D this._get(inst, "duration");=0A=
			postProcess =3D function() {=0A=
				$.datepicker._tidyDialog(inst);=0A=
			};=0A=
=0A=
			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed=0A=
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ =
showAnim ] ) ) {=0A=
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), =
duration, postProcess);=0A=
			} else {=0A=
				inst.dpDiv[(showAnim =3D=3D=3D "slideDown" ? "slideUp" :=0A=
					(showAnim =3D=3D=3D "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? =
duration : null), postProcess);=0A=
			}=0A=
=0A=
			if (!showAnim) {=0A=
				postProcess();=0A=
			}=0A=
			this._datepickerShowing =3D false;=0A=
=0A=
			onClose =3D this._get(inst, "onClose");=0A=
			if (onClose) {=0A=
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? =
inst.input.val() : ""), inst]);=0A=
			}=0A=
=0A=
			this._lastInput =3D null;=0A=
			if (this._inDialog) {=0A=
				this._dialogInput.css({ position: "absolute", left: "0", top: =
"-100px" });=0A=
				if ($.blockUI) {=0A=
					$.unblockUI();=0A=
					$("body").append(this.dpDiv);=0A=
				}=0A=
			}=0A=
			this._inDialog =3D false;=0A=
		}=0A=
	},=0A=
=0A=
	/* Tidy up after a dialog display. */=0A=
	_tidyDialog: function(inst) {=0A=
		=
inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar=
");=0A=
	},=0A=
=0A=
	/* Close date picker if clicked elsewhere. */=0A=
	_checkExternalClick: function(event) {=0A=
		if (!$.datepicker._curInst) {=0A=
			return;=0A=
		}=0A=
=0A=
		var $target =3D $(event.target),=0A=
			inst =3D $.datepicker._getInst($target[0]);=0A=
=0A=
		if ( ( ( $target[0].id !=3D=3D $.datepicker._mainDivId &&=0A=
				$target.parents("#" + $.datepicker._mainDivId).length =3D=3D=3D 0 &&=0A=
				!$target.hasClass($.datepicker.markerClassName) &&=0A=
				!$target.closest("." + $.datepicker._triggerClass).length &&=0A=
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && =
$.blockUI) ) ) ||=0A=
			( $target.hasClass($.datepicker.markerClassName) && =
$.datepicker._curInst !=3D=3D inst ) ) {=0A=
				$.datepicker._hideDatepicker();=0A=
		}=0A=
	},=0A=
=0A=
	/* Adjust one of the date sub-fields. */=0A=
	_adjustDate: function(id, offset, period) {=0A=
		var target =3D $(id),=0A=
			inst =3D this._getInst(target[0]);=0A=
=0A=
		if (this._isDisabledDatepicker(target[0])) {=0A=
			return;=0A=
		}=0A=
		this._adjustInstDate(inst, offset +=0A=
			(period =3D=3D=3D "M" ? this._get(inst, "showCurrentAtPos") : 0), // =
undo positioning=0A=
			period);=0A=
		this._updateDatepicker(inst);=0A=
	},=0A=
=0A=
	/* Action for current link. */=0A=
	_gotoToday: function(id) {=0A=
		var date,=0A=
			target =3D $(id),=0A=
			inst =3D this._getInst(target[0]);=0A=
=0A=
		if (this._get(inst, "gotoCurrent") && inst.currentDay) {=0A=
			inst.selectedDay =3D inst.currentDay;=0A=
			inst.drawMonth =3D inst.selectedMonth =3D inst.currentMonth;=0A=
			inst.drawYear =3D inst.selectedYear =3D inst.currentYear;=0A=
		} else {=0A=
			date =3D new Date();=0A=
			inst.selectedDay =3D date.getDate();=0A=
			inst.drawMonth =3D inst.selectedMonth =3D date.getMonth();=0A=
			inst.drawYear =3D inst.selectedYear =3D date.getFullYear();=0A=
		}=0A=
		this._notifyChange(inst);=0A=
		this._adjustDate(target);=0A=
	},=0A=
=0A=
	/* Action for selecting a new month/year. */=0A=
	_selectMonthYear: function(id, select, period) {=0A=
		var target =3D $(id),=0A=
			inst =3D this._getInst(target[0]);=0A=
=0A=
		inst["selected" + (period =3D=3D=3D "M" ? "Month" : "Year")] =3D=0A=
		inst["draw" + (period =3D=3D=3D "M" ? "Month" : "Year")] =3D=0A=
			parseInt(select.options[select.selectedIndex].value,10);=0A=
=0A=
		this._notifyChange(inst);=0A=
		this._adjustDate(target);=0A=
	},=0A=
=0A=
	/* Action for selecting a day. */=0A=
	_selectDay: function(id, month, year, td) {=0A=
		var inst,=0A=
			target =3D $(id);=0A=
=0A=
		if ($(td).hasClass(this._unselectableClass) || =
this._isDisabledDatepicker(target[0])) {=0A=
			return;=0A=
		}=0A=
=0A=
		inst =3D this._getInst(target[0]);=0A=
		inst.selectedDay =3D inst.currentDay =3D $("a", td).html();=0A=
		inst.selectedMonth =3D inst.currentMonth =3D month;=0A=
		inst.selectedYear =3D inst.currentYear =3D year;=0A=
		this._selectDate(id, this._formatDate(inst,=0A=
			inst.currentDay, inst.currentMonth, inst.currentYear));=0A=
	},=0A=
=0A=
	/* Erase the input field and hide the date picker. */=0A=
	_clearDate: function(id) {=0A=
		var target =3D $(id);=0A=
		this._selectDate(target, "");=0A=
	},=0A=
=0A=
	/* Update the input field with the selected date. */=0A=
	_selectDate: function(id, dateStr) {=0A=
		var onSelect,=0A=
			target =3D $(id),=0A=
			inst =3D this._getInst(target[0]);=0A=
=0A=
		dateStr =3D (dateStr !=3D null ? dateStr : this._formatDate(inst));=0A=
		if (inst.input) {=0A=
			inst.input.val(dateStr);=0A=
		}=0A=
		this._updateAlternate(inst);=0A=
=0A=
		onSelect =3D this._get(inst, "onSelect");=0A=
		if (onSelect) {=0A=
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]); =
 // trigger custom callback=0A=
		} else if (inst.input) {=0A=
			inst.input.trigger("change"); // fire the change event=0A=
		}=0A=
=0A=
		if (inst.inline){=0A=
			this._updateDatepicker(inst);=0A=
		} else {=0A=
			this._hideDatepicker();=0A=
			this._lastInput =3D inst.input[0];=0A=
			if (typeof(inst.input[0]) !=3D=3D "object") {=0A=
				inst.input.focus(); // restore focus=0A=
			}=0A=
			this._lastInput =3D null;=0A=
		}=0A=
	},=0A=
=0A=
	/* Update any alternate field to synchronise with the main field. */=0A=
	_updateAlternate: function(inst) {=0A=
		var altFormat, date, dateStr,=0A=
			altField =3D this._get(inst, "altField");=0A=
=0A=
		if (altField) { // update alternate field too=0A=
			altFormat =3D this._get(inst, "altFormat") || this._get(inst, =
"dateFormat");=0A=
			date =3D this._getDate(inst);=0A=
			dateStr =3D this.formatDate(altFormat, date, =
this._getFormatConfig(inst));=0A=
			$(altField).each(function() { $(this).val(dateStr); });=0A=
		}=0A=
	},=0A=
=0A=
	/* Set as beforeShowDay function to prevent selection of weekends.=0A=
	 * @param  date  Date - the date to customise=0A=
	 * @return [boolean, string] - is this date selectable?, what is its =
CSS class?=0A=
	 */=0A=
	noWeekends: function(date) {=0A=
		var day =3D date.getDay();=0A=
		return [(day > 0 && day < 6), ""];=0A=
	},=0A=
=0A=
	/* Set as calculateWeek to determine the week of the year based on the =
ISO 8601 definition.=0A=
	 * @param  date  Date - the date to get the week for=0A=
	 * @return  number - the number of the week within the year that =
contains this date=0A=
	 */=0A=
	iso8601Week: function(date) {=0A=
		var time,=0A=
			checkDate =3D new Date(date.getTime());=0A=
=0A=
		// Find Thursday of this week starting on Monday=0A=
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));=0A=
=0A=
		time =3D checkDate.getTime();=0A=
		checkDate.setMonth(0); // Compare with Jan 1=0A=
		checkDate.setDate(1);=0A=
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;=0A=
	},=0A=
=0A=
	/* Parse a string value into a date object.=0A=
	 * See formatDate below for the possible formats.=0A=
	 *=0A=
	 * @param  format string - the expected format of the date=0A=
	 * @param  value string - the date in the above format=0A=
	 * @param  settings Object - attributes include:=0A=
	 *					shortYearCutoff  number - the cutoff year for determining the =
century (optional)=0A=
	 *					dayNamesShort	string[7] - abbreviated names of the days from =
Sunday (optional)=0A=
	 *					dayNames		string[7] - names of the days from Sunday (optional)=0A=
	 *					monthNamesShort string[12] - abbreviated names of the months =
(optional)=0A=
	 *					monthNames		string[12] - names of the months (optional)=0A=
	 * @return  Date - the extracted date value or null if value is blank=0A=
	 */=0A=
	parseDate: function (format, value, settings) {=0A=
		if (format =3D=3D null || value =3D=3D null) {=0A=
			throw "Invalid arguments";=0A=
		}=0A=
=0A=
		value =3D (typeof value =3D=3D=3D "object" ? value.toString() : value =
+ "");=0A=
		if (value =3D=3D=3D "") {=0A=
			return null;=0A=
		}=0A=
=0A=
		var iFormat, dim, extra,=0A=
			iValue =3D 0,=0A=
			shortYearCutoffTemp =3D (settings ? settings.shortYearCutoff : null) =
|| this._defaults.shortYearCutoff,=0A=
			shortYearCutoff =3D (typeof shortYearCutoffTemp !=3D=3D "string" ? =
shortYearCutoffTemp :=0A=
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),=0A=
			dayNamesShort =3D (settings ? settings.dayNamesShort : null) || =
this._defaults.dayNamesShort,=0A=
			dayNames =3D (settings ? settings.dayNames : null) || =
this._defaults.dayNames,=0A=
			monthNamesShort =3D (settings ? settings.monthNamesShort : null) || =
this._defaults.monthNamesShort,=0A=
			monthNames =3D (settings ? settings.monthNames : null) || =
this._defaults.monthNames,=0A=
			year =3D -1,=0A=
			month =3D -1,=0A=
			day =3D -1,=0A=
			doy =3D -1,=0A=
			literal =3D false,=0A=
			date,=0A=
			// Check whether a format character is doubled=0A=
			lookAhead =3D function(match) {=0A=
				var matches =3D (iFormat + 1 < format.length && =
format.charAt(iFormat + 1) =3D=3D=3D match);=0A=
				if (matches) {=0A=
					iFormat++;=0A=
				}=0A=
				return matches;=0A=
			},=0A=
			// Extract a number from the string value=0A=
			getNumber =3D function(match) {=0A=
				var isDoubled =3D lookAhead(match),=0A=
					size =3D (match =3D=3D=3D "@" ? 14 : (match =3D=3D=3D "!" ? 20 :=0A=
					(match =3D=3D=3D "y" && isDoubled ? 4 : (match =3D=3D=3D "o" ? 3 : =
2)))),=0A=
					minSize =3D (match =3D=3D=3D "y" ? size : 1),=0A=
					digits =3D new RegExp("^\\d{" + minSize + "," + size + "}"),=0A=
					num =3D value.substring(iValue).match(digits);=0A=
				if (!num) {=0A=
					throw "Missing number at position " + iValue;=0A=
				}=0A=
				iValue +=3D num[0].length;=0A=
				return parseInt(num[0], 10);=0A=
			},=0A=
			// Extract a name from the string value and convert to an index=0A=
			getName =3D function(match, shortNames, longNames) {=0A=
				var index =3D -1,=0A=
					names =3D $.map(lookAhead(match) ? longNames : shortNames, function =
(v, k) {=0A=
						return [ [k, v] ];=0A=
					}).sort(function (a, b) {=0A=
						return -(a[1].length - b[1].length);=0A=
					});=0A=
=0A=
				$.each(names, function (i, pair) {=0A=
					var name =3D pair[1];=0A=
					if (value.substr(iValue, name.length).toLowerCase() =3D=3D=3D =
name.toLowerCase()) {=0A=
						index =3D pair[0];=0A=
						iValue +=3D name.length;=0A=
						return false;=0A=
					}=0A=
				});=0A=
				if (index !=3D=3D -1) {=0A=
					return index + 1;=0A=
				} else {=0A=
					throw "Unknown name at position " + iValue;=0A=
				}=0A=
			},=0A=
			// Confirm that a literal character matches the string value=0A=
			checkLiteral =3D function() {=0A=
				if (value.charAt(iValue) !=3D=3D format.charAt(iFormat)) {=0A=
					throw "Unexpected literal at position " + iValue;=0A=
				}=0A=
				iValue++;=0A=
			};=0A=
=0A=
		for (iFormat =3D 0; iFormat < format.length; iFormat++) {=0A=
			if (literal) {=0A=
				if (format.charAt(iFormat) =3D=3D=3D "'" && !lookAhead("'")) {=0A=
					literal =3D false;=0A=
				} else {=0A=
					checkLiteral();=0A=
				}=0A=
			} else {=0A=
				switch (format.charAt(iFormat)) {=0A=
					case "d":=0A=
						day =3D getNumber("d");=0A=
						break;=0A=
					case "D":=0A=
						getName("D", dayNamesShort, dayNames);=0A=
						break;=0A=
					case "o":=0A=
						doy =3D getNumber("o");=0A=
						break;=0A=
					case "m":=0A=
						month =3D getNumber("m");=0A=
						break;=0A=
					case "M":=0A=
						month =3D getName("M", monthNamesShort, monthNames);=0A=
						break;=0A=
					case "y":=0A=
						year =3D getNumber("y");=0A=
						break;=0A=
					case "@":=0A=
						date =3D new Date(getNumber("@"));=0A=
						year =3D date.getFullYear();=0A=
						month =3D date.getMonth() + 1;=0A=
						day =3D date.getDate();=0A=
						break;=0A=
					case "!":=0A=
						date =3D new Date((getNumber("!") - this._ticksTo1970) / 10000);=0A=
						year =3D date.getFullYear();=0A=
						month =3D date.getMonth() + 1;=0A=
						day =3D date.getDate();=0A=
						break;=0A=
					case "'":=0A=
						if (lookAhead("'")){=0A=
							checkLiteral();=0A=
						} else {=0A=
							literal =3D true;=0A=
						}=0A=
						break;=0A=
					default:=0A=
						checkLiteral();=0A=
				}=0A=
			}=0A=
		}=0A=
=0A=
		if (iValue < value.length){=0A=
			extra =3D value.substr(iValue);=0A=
			if (!/^\s+/.test(extra)) {=0A=
				throw "Extra/unparsed characters found in date: " + extra;=0A=
			}=0A=
		}=0A=
=0A=
		if (year =3D=3D=3D -1) {=0A=
			year =3D new Date().getFullYear();=0A=
		} else if (year < 100) {=0A=
			year +=3D new Date().getFullYear() - new Date().getFullYear() % 100 +=0A=
				(year <=3D shortYearCutoff ? 0 : -100);=0A=
		}=0A=
=0A=
		if (doy > -1) {=0A=
			month =3D 1;=0A=
			day =3D doy;=0A=
			do {=0A=
				dim =3D this._getDaysInMonth(year, month - 1);=0A=
				if (day <=3D dim) {=0A=
					break;=0A=
				}=0A=
				month++;=0A=
				day -=3D dim;=0A=
			} while (true);=0A=
		}=0A=
=0A=
		date =3D this._daylightSavingAdjust(new Date(year, month - 1, day));=0A=
		if (date.getFullYear() !=3D=3D year || date.getMonth() + 1 !=3D=3D =
month || date.getDate() !=3D=3D day) {=0A=
			throw "Invalid date"; // E.g. 31/02/00=0A=
		}=0A=
		return date;=0A=
	},=0A=
=0A=
	/* Standard date formats. */=0A=
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)=0A=
	COOKIE: "D, dd M yy",=0A=
	ISO_8601: "yy-mm-dd",=0A=
	RFC_822: "D, d M y",=0A=
	RFC_850: "DD, dd-M-y",=0A=
	RFC_1036: "D, d M y",=0A=
	RFC_1123: "D, d M yy",=0A=
	RFC_2822: "D, d M yy",=0A=
	RSS: "D, d M y", // RFC 822=0A=
	TICKS: "!",=0A=
	TIMESTAMP: "@",=0A=
	W3C: "yy-mm-dd", // ISO 8601=0A=
=0A=
	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - =
Math.floor(1970 / 100) +=0A=
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),=0A=
=0A=
	/* Format a date object into a string value.=0A=
	 * The format can be combinations of the following:=0A=
	 * d  - day of month (no leading zero)=0A=
	 * dd - day of month (two digit)=0A=
	 * o  - day of year (no leading zeros)=0A=
	 * oo - day of year (three digit)=0A=
	 * D  - day name short=0A=
	 * DD - day name long=0A=
	 * m  - month of year (no leading zero)=0A=
	 * mm - month of year (two digit)=0A=
	 * M  - month name short=0A=
	 * MM - month name long=0A=
	 * y  - year (two digit)=0A=
	 * yy - year (four digit)=0A=
	 * @ - Unix timestamp (ms since 01/01/1970)=0A=
	 * ! - Windows ticks (100ns since 01/01/0001)=0A=
	 * "..." - literal text=0A=
	 * '' - single quote=0A=
	 *=0A=
	 * @param  format string - the desired format of the date=0A=
	 * @param  date Date - the date value to format=0A=
	 * @param  settings Object - attributes include:=0A=
	 *					dayNamesShort	string[7] - abbreviated names of the days from =
Sunday (optional)=0A=
	 *					dayNames		string[7] - names of the days from Sunday (optional)=0A=
	 *					monthNamesShort string[12] - abbreviated names of the months =
(optional)=0A=
	 *					monthNames		string[12] - names of the months (optional)=0A=
	 * @return  string - the date in the above format=0A=
	 */=0A=
	formatDate: function (format, date, settings) {=0A=
		if (!date) {=0A=
			return "";=0A=
		}=0A=
=0A=
		var iFormat,=0A=
			dayNamesShort =3D (settings ? settings.dayNamesShort : null) || =
this._defaults.dayNamesShort,=0A=
			dayNames =3D (settings ? settings.dayNames : null) || =
this._defaults.dayNames,=0A=
			monthNamesShort =3D (settings ? settings.monthNamesShort : null) || =
this._defaults.monthNamesShort,=0A=
			monthNames =3D (settings ? settings.monthNames : null) || =
this._defaults.monthNames,=0A=
			// Check whether a format character is doubled=0A=
			lookAhead =3D function(match) {=0A=
				var matches =3D (iFormat + 1 < format.length && =
format.charAt(iFormat + 1) =3D=3D=3D match);=0A=
				if (matches) {=0A=
					iFormat++;=0A=
				}=0A=
				return matches;=0A=
			},=0A=
			// Format a number, with leading zero if necessary=0A=
			formatNumber =3D function(match, value, len) {=0A=
				var num =3D "" + value;=0A=
				if (lookAhead(match)) {=0A=
					while (num.length < len) {=0A=
						num =3D "0" + num;=0A=
					}=0A=
				}=0A=
				return num;=0A=
			},=0A=
			// Format a name, short or long as requested=0A=
			formatName =3D function(match, value, shortNames, longNames) {=0A=
				return (lookAhead(match) ? longNames[value] : shortNames[value]);=0A=
			},=0A=
			output =3D "",=0A=
			literal =3D false;=0A=
=0A=
		if (date) {=0A=
			for (iFormat =3D 0; iFormat < format.length; iFormat++) {=0A=
				if (literal) {=0A=
					if (format.charAt(iFormat) =3D=3D=3D "'" && !lookAhead("'")) {=0A=
						literal =3D false;=0A=
					} else {=0A=
						output +=3D format.charAt(iFormat);=0A=
					}=0A=
				} else {=0A=
					switch (format.charAt(iFormat)) {=0A=
						case "d":=0A=
							output +=3D formatNumber("d", date.getDate(), 2);=0A=
							break;=0A=
						case "D":=0A=
							output +=3D formatName("D", date.getDay(), dayNamesShort, =
dayNames);=0A=
							break;=0A=
						case "o":=0A=
							output +=3D formatNumber("o",=0A=
								Math.round((new Date(date.getFullYear(), date.getMonth(), =
date.getDate()).getTime() - new Date(date.getFullYear(), 0, =
0).getTime()) / 86400000), 3);=0A=
							break;=0A=
						case "m":=0A=
							output +=3D formatNumber("m", date.getMonth() + 1, 2);=0A=
							break;=0A=
						case "M":=0A=
							output +=3D formatName("M", date.getMonth(), monthNamesShort, =
monthNames);=0A=
							break;=0A=
						case "y":=0A=
							output +=3D (lookAhead("y") ? date.getFullYear() :=0A=
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);=0A=
							break;=0A=
						case "@":=0A=
							output +=3D date.getTime();=0A=
							break;=0A=
						case "!":=0A=
							output +=3D date.getTime() * 10000 + this._ticksTo1970;=0A=
							break;=0A=
						case "'":=0A=
							if (lookAhead("'")) {=0A=
								output +=3D "'";=0A=
							} else {=0A=
								literal =3D true;=0A=
							}=0A=
							break;=0A=
						default:=0A=
							output +=3D format.charAt(iFormat);=0A=
					}=0A=
				}=0A=
			}=0A=
		}=0A=
		return output;=0A=
	},=0A=
=0A=
	/* Extract all possible characters from the date format. */=0A=
	_possibleChars: function (format) {=0A=
		var iFormat,=0A=
			chars =3D "",=0A=
			literal =3D false,=0A=
			// Check whether a format character is doubled=0A=
			lookAhead =3D function(match) {=0A=
				var matches =3D (iFormat + 1 < format.length && =
format.charAt(iFormat + 1) =3D=3D=3D match);=0A=
				if (matches) {=0A=
					iFormat++;=0A=
				}=0A=
				return matches;=0A=
			};=0A=
=0A=
		for (iFormat =3D 0; iFormat < format.length; iFormat++) {=0A=
			if (literal) {=0A=
				if (format.charAt(iFormat) =3D=3D=3D "'" && !lookAhead("'")) {=0A=
					literal =3D false;=0A=
				} else {=0A=
					chars +=3D format.charAt(iFormat);=0A=
				}=0A=
			} else {=0A=
				switch (format.charAt(iFormat)) {=0A=
					case "d": case "m": case "y": case "@":=0A=
						chars +=3D "0123456789";=0A=
						break;=0A=
					case "D": case "M":=0A=
						return null; // Accept anything=0A=
					case "'":=0A=
						if (lookAhead("'")) {=0A=
							chars +=3D "'";=0A=
						} else {=0A=
							literal =3D true;=0A=
						}=0A=
						break;=0A=
					default:=0A=
						chars +=3D format.charAt(iFormat);=0A=
				}=0A=
			}=0A=
		}=0A=
		return chars;=0A=
	},=0A=
=0A=
	/* Get a setting value, defaulting if necessary. */=0A=
	_get: function(inst, name) {=0A=
		return inst.settings[name] !=3D=3D undefined ?=0A=
			inst.settings[name] : this._defaults[name];=0A=
	},=0A=
=0A=
	/* Parse existing date and initialise date picker. */=0A=
	_setDateFromField: function(inst, noDefault) {=0A=
		if (inst.input.val() =3D=3D=3D inst.lastVal) {=0A=
			return;=0A=
		}=0A=
=0A=
		var dateFormat =3D this._get(inst, "dateFormat"),=0A=
			dates =3D inst.lastVal =3D inst.input ? inst.input.val() : null,=0A=
			defaultDate =3D this._getDefaultDate(inst),=0A=
			date =3D defaultDate,=0A=
			settings =3D this._getFormatConfig(inst);=0A=
=0A=
		try {=0A=
			date =3D this.parseDate(dateFormat, dates, settings) || defaultDate;=0A=
		} catch (event) {=0A=
			dates =3D (noDefault ? "" : dates);=0A=
		}=0A=
		inst.selectedDay =3D date.getDate();=0A=
		inst.drawMonth =3D inst.selectedMonth =3D date.getMonth();=0A=
		inst.drawYear =3D inst.selectedYear =3D date.getFullYear();=0A=
		inst.currentDay =3D (dates ? date.getDate() : 0);=0A=
		inst.currentMonth =3D (dates ? date.getMonth() : 0);=0A=
		inst.currentYear =3D (dates ? date.getFullYear() : 0);=0A=
		this._adjustInstDate(inst);=0A=
	},=0A=
=0A=
	/* Retrieve the default date shown on opening. */=0A=
	_getDefaultDate: function(inst) {=0A=
		return this._restrictMinMax(inst,=0A=
			this._determineDate(inst, this._get(inst, "defaultDate"), new =
Date()));=0A=
	},=0A=
=0A=
	/* A date may be specified as an exact value or a relative one. */=0A=
	_determineDate: function(inst, date, defaultDate) {=0A=
		var offsetNumeric =3D function(offset) {=0A=
				var date =3D new Date();=0A=
				date.setDate(date.getDate() + offset);=0A=
				return date;=0A=
			},=0A=
			offsetString =3D function(offset) {=0A=
				try {=0A=
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),=0A=
						offset, $.datepicker._getFormatConfig(inst));=0A=
				}=0A=
				catch (e) {=0A=
					// Ignore=0A=
				}=0A=
=0A=
				var date =3D (offset.toLowerCase().match(/^c/) ?=0A=
					$.datepicker._getDate(inst) : null) || new Date(),=0A=
					year =3D date.getFullYear(),=0A=
					month =3D date.getMonth(),=0A=
					day =3D date.getDate(),=0A=
					pattern =3D /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,=0A=
					matches =3D pattern.exec(offset);=0A=
=0A=
				while (matches) {=0A=
					switch (matches[2] || "d") {=0A=
						case "d" : case "D" :=0A=
							day +=3D parseInt(matches[1],10); break;=0A=
						case "w" : case "W" :=0A=
							day +=3D parseInt(matches[1],10) * 7; break;=0A=
						case "m" : case "M" :=0A=
							month +=3D parseInt(matches[1],10);=0A=
							day =3D Math.min(day, $.datepicker._getDaysInMonth(year, month));=0A=
							break;=0A=
						case "y": case "Y" :=0A=
							year +=3D parseInt(matches[1],10);=0A=
							day =3D Math.min(day, $.datepicker._getDaysInMonth(year, month));=0A=
							break;=0A=
					}=0A=
					matches =3D pattern.exec(offset);=0A=
				}=0A=
				return new Date(year, month, day);=0A=
			},=0A=
			newDate =3D (date =3D=3D null || date =3D=3D=3D "" ? defaultDate : =
(typeof date =3D=3D=3D "string" ? offsetString(date) :=0A=
				(typeof date =3D=3D=3D "number" ? (isNaN(date) ? defaultDate : =
offsetNumeric(date)) : new Date(date.getTime()))));=0A=
=0A=
		newDate =3D (newDate && newDate.toString() =3D=3D=3D "Invalid Date" ? =
defaultDate : newDate);=0A=
		if (newDate) {=0A=
			newDate.setHours(0);=0A=
			newDate.setMinutes(0);=0A=
			newDate.setSeconds(0);=0A=
			newDate.setMilliseconds(0);=0A=
		}=0A=
		return this._daylightSavingAdjust(newDate);=0A=
	},=0A=
=0A=
	/* Handle switch to/from daylight saving.=0A=
	 * Hours may be non-zero on daylight saving cut-over:=0A=
	 * > 12 when midnight changeover, but then cannot generate=0A=
	 * midnight datetime, so jump to 1AM, otherwise reset.=0A=
	 * @param  date  (Date) the date to check=0A=
	 * @return  (Date) the corrected date=0A=
	 */=0A=
	_daylightSavingAdjust: function(date) {=0A=
		if (!date) {=0A=
			return null;=0A=
		}=0A=
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);=0A=
		return date;=0A=
	},=0A=
=0A=
	/* Set the date(s) directly. */=0A=
	_setDate: function(inst, date, noChange) {=0A=
		var clear =3D !date,=0A=
			origMonth =3D inst.selectedMonth,=0A=
			origYear =3D inst.selectedYear,=0A=
			newDate =3D this._restrictMinMax(inst, this._determineDate(inst, =
date, new Date()));=0A=
=0A=
		inst.selectedDay =3D inst.currentDay =3D newDate.getDate();=0A=
		inst.drawMonth =3D inst.selectedMonth =3D inst.currentMonth =3D =
newDate.getMonth();=0A=
		inst.drawYear =3D inst.selectedYear =3D inst.currentYear =3D =
newDate.getFullYear();=0A=
		if ((origMonth !=3D=3D inst.selectedMonth || origYear !=3D=3D =
inst.selectedYear) && !noChange) {=0A=
			this._notifyChange(inst);=0A=
		}=0A=
		this._adjustInstDate(inst);=0A=
		if (inst.input) {=0A=
			inst.input.val(clear ? "" : this._formatDate(inst));=0A=
		}=0A=
	},=0A=
=0A=
	/* Retrieve the date(s) directly. */=0A=
	_getDate: function(inst) {=0A=
		var startDate =3D (!inst.currentYear || (inst.input && =
inst.input.val() =3D=3D=3D "") ? null :=0A=
			this._daylightSavingAdjust(new Date(=0A=
			inst.currentYear, inst.currentMonth, inst.currentDay)));=0A=
			return startDate;=0A=
	},=0A=
=0A=
	/* Attach the onxxx handlers.  These are declared statically so=0A=
	 * they work with static code transformers like Caja.=0A=
	 */=0A=
	_attachHandlers: function(inst) {=0A=
		var stepMonths =3D this._get(inst, "stepMonths"),=0A=
			id =3D "#" + inst.id.replace( /\\\\/g, "\\" );=0A=
		inst.dpDiv.find("[data-handler]").map(function () {=0A=
			var handler =3D {=0A=
				prev: function () {=0A=
					$.datepicker._adjustDate(id, -stepMonths, "M");=0A=
				},=0A=
				next: function () {=0A=
					$.datepicker._adjustDate(id, +stepMonths, "M");=0A=
				},=0A=
				hide: function () {=0A=
					$.datepicker._hideDatepicker();=0A=
				},=0A=
				today: function () {=0A=
					$.datepicker._gotoToday(id);=0A=
				},=0A=
				selectDay: function () {=0A=
					$.datepicker._selectDay(id, +this.getAttribute("data-month"), =
+this.getAttribute("data-year"), this);=0A=
					return false;=0A=
				},=0A=
				selectMonth: function () {=0A=
					$.datepicker._selectMonthYear(id, this, "M");=0A=
					return false;=0A=
				},=0A=
				selectYear: function () {=0A=
					$.datepicker._selectMonthYear(id, this, "Y");=0A=
					return false;=0A=
				}=0A=
			};=0A=
			$(this).bind(this.getAttribute("data-event"), =
handler[this.getAttribute("data-handler")]);=0A=
		});=0A=
	},=0A=
=0A=
	/* Generate the HTML for the current state of the date picker. */=0A=
	_generateHTML: function(inst) {=0A=
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,=0A=
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,=0A=
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,=0A=
			selectOtherMonths, defaultDate, html, dow, row, group, col, =
selectedDate,=0A=
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, =
numRows,=0A=
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,=0A=
			tempDate =3D new Date(),=0A=
			today =3D this._daylightSavingAdjust(=0A=
				new Date(tempDate.getFullYear(), tempDate.getMonth(), =
tempDate.getDate())), // clear time=0A=
			isRTL =3D this._get(inst, "isRTL"),=0A=
			showButtonPanel =3D this._get(inst, "showButtonPanel"),=0A=
			hideIfNoPrevNext =3D this._get(inst, "hideIfNoPrevNext"),=0A=
			navigationAsDateFormat =3D this._get(inst, "navigationAsDateFormat"),=0A=
			numMonths =3D this._getNumberOfMonths(inst),=0A=
			showCurrentAtPos =3D this._get(inst, "showCurrentAtPos"),=0A=
			stepMonths =3D this._get(inst, "stepMonths"),=0A=
			isMultiMonth =3D (numMonths[0] !=3D=3D 1 || numMonths[1] !=3D=3D 1),=0A=
			currentDate =3D this._daylightSavingAdjust((!inst.currentDay ? new =
Date(9999, 9, 9) :=0A=
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),=0A=
			minDate =3D this._getMinMaxDate(inst, "min"),=0A=
			maxDate =3D this._getMinMaxDate(inst, "max"),=0A=
			drawMonth =3D inst.drawMonth - showCurrentAtPos,=0A=
			drawYear =3D inst.drawYear;=0A=
=0A=
		if (drawMonth < 0) {=0A=
			drawMonth +=3D 12;=0A=
			drawYear--;=0A=
		}=0A=
		if (maxDate) {=0A=
			maxDraw =3D this._daylightSavingAdjust(new Date(maxDate.getFullYear(),=0A=
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, =
maxDate.getDate()));=0A=
			maxDraw =3D (minDate && maxDraw < minDate ? minDate : maxDraw);=0A=
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > =
maxDraw) {=0A=
				drawMonth--;=0A=
				if (drawMonth < 0) {=0A=
					drawMonth =3D 11;=0A=
					drawYear--;=0A=
				}=0A=
			}=0A=
		}=0A=
		inst.drawMonth =3D drawMonth;=0A=
		inst.drawYear =3D drawYear;=0A=
=0A=
		prevText =3D this._get(inst, "prevText");=0A=
		prevText =3D (!navigationAsDateFormat ? prevText : =
this.formatDate(prevText,=0A=
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, =
1)),=0A=
			this._getFormatConfig(inst)));=0A=
=0A=
		prev =3D (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?=0A=
			"<a class=3D'ui-datepicker-prev ui-corner-all' data-handler=3D'prev' =
data-event=3D'click'" +=0A=
			" title=3D'" + prevText + "'><span class=3D'ui-icon =
ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + =
"</span></a>" :=0A=
			(hideIfNoPrevNext ? "" : "<a class=3D'ui-datepicker-prev =
ui-corner-all ui-state-disabled' title=3D'"+ prevText +"'><span =
class=3D'ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" =
+ prevText + "</span></a>"));=0A=
=0A=
		nextText =3D this._get(inst, "nextText");=0A=
		nextText =3D (!navigationAsDateFormat ? nextText : =
this.formatDate(nextText,=0A=
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, =
1)),=0A=
			this._getFormatConfig(inst)));=0A=
=0A=
		next =3D (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?=0A=
			"<a class=3D'ui-datepicker-next ui-corner-all' data-handler=3D'next' =
data-event=3D'click'" +=0A=
			" title=3D'" + nextText + "'><span class=3D'ui-icon =
ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + =
"</span></a>" :=0A=
			(hideIfNoPrevNext ? "" : "<a class=3D'ui-datepicker-next =
ui-corner-all ui-state-disabled' title=3D'"+ nextText + "'><span =
class=3D'ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" =
+ nextText + "</span></a>"));=0A=
=0A=
		currentText =3D this._get(inst, "currentText");=0A=
		gotoDate =3D (this._get(inst, "gotoCurrent") && inst.currentDay ? =
currentDate : today);=0A=
		currentText =3D (!navigationAsDateFormat ? currentText :=0A=
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));=0A=
=0A=
		controls =3D (!inst.inline ? "<button type=3D'button' =
class=3D'ui-datepicker-close ui-state-default ui-priority-primary =
ui-corner-all' data-handler=3D'hide' data-event=3D'click'>" +=0A=
			this._get(inst, "closeText") + "</button>" : "");=0A=
=0A=
		buttonPanel =3D (showButtonPanel) ? "<div =
class=3D'ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? =
controls : "") +=0A=
			(this._isInRange(inst, gotoDate) ? "<button type=3D'button' =
class=3D'ui-datepicker-current ui-state-default ui-priority-secondary =
ui-corner-all' data-handler=3D'today' data-event=3D'click'" +=0A=
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + =
"</div>" : "";=0A=
=0A=
		firstDay =3D parseInt(this._get(inst, "firstDay"),10);=0A=
		firstDay =3D (isNaN(firstDay) ? 0 : firstDay);=0A=
=0A=
		showWeek =3D this._get(inst, "showWeek");=0A=
		dayNames =3D this._get(inst, "dayNames");=0A=
		dayNamesMin =3D this._get(inst, "dayNamesMin");=0A=
		monthNames =3D this._get(inst, "monthNames");=0A=
		monthNamesShort =3D this._get(inst, "monthNamesShort");=0A=
		beforeShowDay =3D this._get(inst, "beforeShowDay");=0A=
		showOtherMonths =3D this._get(inst, "showOtherMonths");=0A=
		selectOtherMonths =3D this._get(inst, "selectOtherMonths");=0A=
		defaultDate =3D this._getDefaultDate(inst);=0A=
		html =3D "";=0A=
		dow;=0A=
		for (row =3D 0; row < numMonths[0]; row++) {=0A=
			group =3D "";=0A=
			this.maxRows =3D 4;=0A=
			for (col =3D 0; col < numMonths[1]; col++) {=0A=
				selectedDate =3D this._daylightSavingAdjust(new Date(drawYear, =
drawMonth, inst.selectedDay));=0A=
				cornerClass =3D " ui-corner-all";=0A=
				calender =3D "";=0A=
				if (isMultiMonth) {=0A=
					calender +=3D "<div class=3D'ui-datepicker-group";=0A=
					if (numMonths[1] > 1) {=0A=
						switch (col) {=0A=
							case 0: calender +=3D " ui-datepicker-group-first";=0A=
								cornerClass =3D " ui-corner-" + (isRTL ? "right" : "left"); =
break;=0A=
							case numMonths[1]-1: calender +=3D " ui-datepicker-group-last";=0A=
								cornerClass =3D " ui-corner-" + (isRTL ? "left" : "right"); =
break;=0A=
							default: calender +=3D " ui-datepicker-group-middle"; cornerClass =
=3D ""; break;=0A=
						}=0A=
					}=0A=
					calender +=3D "'>";=0A=
				}=0A=
				calender +=3D "<div class=3D'ui-datepicker-header ui-widget-header =
ui-helper-clearfix" + cornerClass + "'>" +=0A=
					(/all|left/.test(cornerClass) && row =3D=3D=3D 0 ? (isRTL ? next : =
prev) : "") +=0A=
					(/all|right/.test(cornerClass) && row =3D=3D=3D 0 ? (isRTL ? prev : =
next) : "") +=0A=
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, =
maxDate,=0A=
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month =
headers=0A=
					"</div><table class=3D'ui-datepicker-calendar'><thead>" +=0A=
					"<tr>";=0A=
				thead =3D (showWeek ? "<th class=3D'ui-datepicker-week-col'>" + =
this._get(inst, "weekHeader") + "</th>" : "");=0A=
				for (dow =3D 0; dow < 7; dow++) { // days of the week=0A=
					day =3D (dow + firstDay) % 7;=0A=
					thead +=3D "<th scope=3D'col'" + ((dow + firstDay + 6) % 7 >=3D 5 ? =
" class=3D'ui-datepicker-week-end'" : "") + ">" +=0A=
						"<span title=3D'" + dayNames[day] + "'>" + dayNamesMin[day] + =
"</span></th>";=0A=
				}=0A=
				calender +=3D thead + "</tr></thead><tbody>";=0A=
				daysInMonth =3D this._getDaysInMonth(drawYear, drawMonth);=0A=
				if (drawYear =3D=3D=3D inst.selectedYear && drawMonth =3D=3D=3D =
inst.selectedMonth) {=0A=
					inst.selectedDay =3D Math.min(inst.selectedDay, daysInMonth);=0A=
				}=0A=
				leadDays =3D (this._getFirstDayOfMonth(drawYear, drawMonth) - =
firstDay + 7) % 7;=0A=
				curRows =3D Math.ceil((leadDays + daysInMonth) / 7); // calculate =
the number of rows to generate=0A=
				numRows =3D (isMultiMonth ? this.maxRows > curRows ? this.maxRows : =
curRows : curRows); //If multiple months, use the higher number of rows =
(see #7043)=0A=
				this.maxRows =3D numRows;=0A=
				printDate =3D this._daylightSavingAdjust(new Date(drawYear, =
drawMonth, 1 - leadDays));=0A=
				for (dRow =3D 0; dRow < numRows; dRow++) { // create date picker rows=0A=
					calender +=3D "<tr>";=0A=
					tbody =3D (!showWeek ? "" : "<td class=3D'ui-datepicker-week-col'>" =
+=0A=
						this._get(inst, "calculateWeek")(printDate) + "</td>");=0A=
					for (dow =3D 0; dow < 7; dow++) { // create date picker days=0A=
						daySettings =3D (beforeShowDay ?=0A=
							beforeShowDay.apply((inst.input ? inst.input[0] : null), =
[printDate]) : [true, ""]);=0A=
						otherMonth =3D (printDate.getMonth() !=3D=3D drawMonth);=0A=
						unselectable =3D (otherMonth && !selectOtherMonths) || =
!daySettings[0] ||=0A=
							(minDate && printDate < minDate) || (maxDate && printDate > =
maxDate);=0A=
						tbody +=3D "<td class=3D'" +=0A=
							((dow + firstDay + 6) % 7 >=3D 5 ? " ui-datepicker-week-end" : =
"") + // highlight weekends=0A=
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight =
days from other months=0A=
							((printDate.getTime() =3D=3D=3D selectedDate.getTime() && =
drawMonth =3D=3D=3D inst.selectedMonth && inst._keyEvent) || // user =
pressed key=0A=
							(defaultDate.getTime() =3D=3D=3D printDate.getTime() && =
defaultDate.getTime() =3D=3D=3D selectedDate.getTime()) ?=0A=
							// or defaultDate is current printedDate and defaultDate is =
selectedDate=0A=
							" " + this._dayOverClass : "") + // highlight selected day=0A=
							(unselectable ? " " + this._unselectableClass + " =
ui-state-disabled": "") +  // highlight unselectable days=0A=
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // =
highlight custom dates=0A=
							(printDate.getTime() =3D=3D=3D currentDate.getTime() ? " " + =
this._currentClass : "") + // highlight selected day=0A=
							(printDate.getTime() =3D=3D=3D today.getTime() ? " =
ui-datepicker-today" : "")) + "'" + // highlight today (if different)=0A=
							((!otherMonth || showOtherMonths) && daySettings[2] ? " =
title=3D'" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell =
title=0A=
							(unselectable ? "" : " data-handler=3D'selectDay' =
data-event=3D'click' data-month=3D'" + printDate.getMonth() + "' =
data-year=3D'" + printDate.getFullYear() + "'") + ">" + // actions=0A=
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other =
months=0A=
							(unselectable ? "<span class=3D'ui-state-default'>" + =
printDate.getDate() + "</span>" : "<a class=3D'ui-state-default" +=0A=
							(printDate.getTime() =3D=3D=3D today.getTime() ? " =
ui-state-highlight" : "") +=0A=
							(printDate.getTime() =3D=3D=3D currentDate.getTime() ? " =
ui-state-active" : "") + // highlight selected day=0A=
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish =
dates from other months=0A=
							"' href=3D'#'>" + printDate.getDate() + "</a>")) + "</td>"; // =
display selectable date=0A=
						printDate.setDate(printDate.getDate() + 1);=0A=
						printDate =3D this._daylightSavingAdjust(printDate);=0A=
					}=0A=
					calender +=3D tbody + "</tr>";=0A=
				}=0A=
				drawMonth++;=0A=
				if (drawMonth > 11) {=0A=
					drawMonth =3D 0;=0A=
					drawYear++;=0A=
				}=0A=
				calender +=3D "</tbody></table>" + (isMultiMonth ? "</div>" +=0A=
							((numMonths[0] > 0 && col =3D=3D=3D numMonths[1]-1) ? "<div =
class=3D'ui-datepicker-row-break'></div>" : "") : "");=0A=
				group +=3D calender;=0A=
			}=0A=
			html +=3D group;=0A=
		}=0A=
		html +=3D buttonPanel;=0A=
		inst._keyEvent =3D false;=0A=
		return html;=0A=
	},=0A=
=0A=
	/* Generate the month and year header. */=0A=
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, =
maxDate,=0A=
			secondary, monthNames, monthNamesShort) {=0A=
=0A=
		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, =
endYear,=0A=
			changeMonth =3D this._get(inst, "changeMonth"),=0A=
			changeYear =3D this._get(inst, "changeYear"),=0A=
			showMonthAfterYear =3D this._get(inst, "showMonthAfterYear"),=0A=
			html =3D "<div class=3D'ui-datepicker-title'>",=0A=
			monthHtml =3D "";=0A=
=0A=
		// month selection=0A=
		if (secondary || !changeMonth) {=0A=
			monthHtml +=3D "<span class=3D'ui-datepicker-month'>" + =
monthNames[drawMonth] + "</span>";=0A=
		} else {=0A=
			inMinYear =3D (minDate && minDate.getFullYear() =3D=3D=3D drawYear);=0A=
			inMaxYear =3D (maxDate && maxDate.getFullYear() =3D=3D=3D drawYear);=0A=
			monthHtml +=3D "<select class=3D'ui-datepicker-month' =
data-handler=3D'selectMonth' data-event=3D'change'>";=0A=
			for ( month =3D 0; month < 12; month++) {=0A=
				if ((!inMinYear || month >=3D minDate.getMonth()) && (!inMaxYear || =
month <=3D maxDate.getMonth())) {=0A=
					monthHtml +=3D "<option value=3D'" + month + "'" +=0A=
						(month =3D=3D=3D drawMonth ? " selected=3D'selected'" : "") +=0A=
						">" + monthNamesShort[month] + "</option>";=0A=
				}=0A=
			}=0A=
			monthHtml +=3D "</select>";=0A=
		}=0A=
=0A=
		if (!showMonthAfterYear) {=0A=
			html +=3D monthHtml + (secondary || !(changeMonth && changeYear) ? =
"&#xa0;" : "");=0A=
		}=0A=
=0A=
		// year selection=0A=
		if ( !inst.yearshtml ) {=0A=
			inst.yearshtml =3D "";=0A=
			if (secondary || !changeYear) {=0A=
				html +=3D "<span class=3D'ui-datepicker-year'>" + drawYear + =
"</span>";=0A=
			} else {=0A=
				// determine range of years to display=0A=
				years =3D this._get(inst, "yearRange").split(":");=0A=
				thisYear =3D new Date().getFullYear();=0A=
				determineYear =3D function(value) {=0A=
					var year =3D (value.match(/c[+\-].*/) ? drawYear + =
parseInt(value.substring(1), 10) :=0A=
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :=0A=
						parseInt(value, 10)));=0A=
					return (isNaN(year) ? thisYear : year);=0A=
				};=0A=
				year =3D determineYear(years[0]);=0A=
				endYear =3D Math.max(year, determineYear(years[1] || ""));=0A=
				year =3D (minDate ? Math.max(year, minDate.getFullYear()) : year);=0A=
				endYear =3D (maxDate ? Math.min(endYear, maxDate.getFullYear()) : =
endYear);=0A=
				inst.yearshtml +=3D "<select class=3D'ui-datepicker-year' =
data-handler=3D'selectYear' data-event=3D'change'>";=0A=
				for (; year <=3D endYear; year++) {=0A=
					inst.yearshtml +=3D "<option value=3D'" + year + "'" +=0A=
						(year =3D=3D=3D drawYear ? " selected=3D'selected'" : "") +=0A=
						">" + year + "</option>";=0A=
				}=0A=
				inst.yearshtml +=3D "</select>";=0A=
=0A=
				html +=3D inst.yearshtml;=0A=
				inst.yearshtml =3D null;=0A=
			}=0A=
		}=0A=
=0A=
		html +=3D this._get(inst, "yearSuffix");=0A=
		if (showMonthAfterYear) {=0A=
			html +=3D (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") =
+ monthHtml;=0A=
		}=0A=
		html +=3D "</div>"; // Close datepicker_header=0A=
		return html;=0A=
	},=0A=
=0A=
	/* Adjust one of the date sub-fields. */=0A=
	_adjustInstDate: function(inst, offset, period) {=0A=
		var year =3D inst.drawYear + (period =3D=3D=3D "Y" ? offset : 0),=0A=
			month =3D inst.drawMonth + (period =3D=3D=3D "M" ? offset : 0),=0A=
			day =3D Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) =
+ (period =3D=3D=3D "D" ? offset : 0),=0A=
			date =3D this._restrictMinMax(inst, this._daylightSavingAdjust(new =
Date(year, month, day)));=0A=
=0A=
		inst.selectedDay =3D date.getDate();=0A=
		inst.drawMonth =3D inst.selectedMonth =3D date.getMonth();=0A=
		inst.drawYear =3D inst.selectedYear =3D date.getFullYear();=0A=
		if (period =3D=3D=3D "M" || period =3D=3D=3D "Y") {=0A=
			this._notifyChange(inst);=0A=
		}=0A=
	},=0A=
=0A=
	/* Ensure a date is within any min/max bounds. */=0A=
	_restrictMinMax: function(inst, date) {=0A=
		var minDate =3D this._getMinMaxDate(inst, "min"),=0A=
			maxDate =3D this._getMinMaxDate(inst, "max"),=0A=
			newDate =3D (minDate && date < minDate ? minDate : date);=0A=
		return (maxDate && newDate > maxDate ? maxDate : newDate);=0A=
	},=0A=
=0A=
	/* Notify change of month/year. */=0A=
	_notifyChange: function(inst) {=0A=
		var onChange =3D this._get(inst, "onChangeMonthYear");=0A=
		if (onChange) {=0A=
			onChange.apply((inst.input ? inst.input[0] : null),=0A=
				[inst.selectedYear, inst.selectedMonth + 1, inst]);=0A=
		}=0A=
	},=0A=
=0A=
	/* Determine the number of months to show. */=0A=
	_getNumberOfMonths: function(inst) {=0A=
		var numMonths =3D this._get(inst, "numberOfMonths");=0A=
		return (numMonths =3D=3D null ? [1, 1] : (typeof numMonths =3D=3D=3D =
"number" ? [1, numMonths] : numMonths));=0A=
	},=0A=
=0A=
	/* Determine the current maximum date - ensure no time components are =
set. */=0A=
	_getMinMaxDate: function(inst, minMax) {=0A=
		return this._determineDate(inst, this._get(inst, minMax + "Date"), =
null);=0A=
	},=0A=
=0A=
	/* Find the number of days in a given month. */=0A=
	_getDaysInMonth: function(year, month) {=0A=
		return 32 - this._daylightSavingAdjust(new Date(year, month, =
32)).getDate();=0A=
	},=0A=
=0A=
	/* Find the day of the week of the first of a month. */=0A=
	_getFirstDayOfMonth: function(year, month) {=0A=
		return new Date(year, month, 1).getDay();=0A=
	},=0A=
=0A=
	/* Determines if we should allow a "next/prev" month display change. */=0A=
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {=0A=
		var numMonths =3D this._getNumberOfMonths(inst),=0A=
			date =3D this._daylightSavingAdjust(new Date(curYear,=0A=
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));=0A=
=0A=
		if (offset < 0) {=0A=
			date.setDate(this._getDaysInMonth(date.getFullYear(), =
date.getMonth()));=0A=
		}=0A=
		return this._isInRange(inst, date);=0A=
	},=0A=
=0A=
	/* Is the given date in the accepted range? */=0A=
	_isInRange: function(inst, date) {=0A=
		var yearSplit, currentYear,=0A=
			minDate =3D this._getMinMaxDate(inst, "min"),=0A=
			maxDate =3D this._getMinMaxDate(inst, "max"),=0A=
			minYear =3D null,=0A=
			maxYear =3D null,=0A=
			years =3D this._get(inst, "yearRange");=0A=
			if (years){=0A=
				yearSplit =3D years.split(":");=0A=
				currentYear =3D new Date().getFullYear();=0A=
				minYear =3D parseInt(yearSplit[0], 10);=0A=
				maxYear =3D parseInt(yearSplit[1], 10);=0A=
				if ( yearSplit[0].match(/[+\-].*/) ) {=0A=
					minYear +=3D currentYear;=0A=
				}=0A=
				if ( yearSplit[1].match(/[+\-].*/) ) {=0A=
					maxYear +=3D currentYear;=0A=
				}=0A=
			}=0A=
=0A=
		return ((!minDate || date.getTime() >=3D minDate.getTime()) &&=0A=
			(!maxDate || date.getTime() <=3D maxDate.getTime()) &&=0A=
			(!minYear || date.getFullYear() >=3D minYear) &&=0A=
			(!maxYear || date.getFullYear() <=3D maxYear));=0A=
	},=0A=
=0A=
	/* Provide the configuration settings for formatting/parsing. */=0A=
	_getFormatConfig: function(inst) {=0A=
		var shortYearCutoff =3D this._get(inst, "shortYearCutoff");=0A=
		shortYearCutoff =3D (typeof shortYearCutoff !=3D=3D "string" ? =
shortYearCutoff :=0A=
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));=0A=
		return {shortYearCutoff: shortYearCutoff,=0A=
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: =
this._get(inst, "dayNames"),=0A=
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: =
this._get(inst, "monthNames")};=0A=
	},=0A=
=0A=
	/* Format the given date for display. */=0A=
	_formatDate: function(inst, day, month, year) {=0A=
		if (!day) {=0A=
			inst.currentDay =3D inst.selectedDay;=0A=
			inst.currentMonth =3D inst.selectedMonth;=0A=
			inst.currentYear =3D inst.selectedYear;=0A=
		}=0A=
		var date =3D (day ? (typeof day =3D=3D=3D "object" ? day :=0A=
			this._daylightSavingAdjust(new Date(year, month, day))) :=0A=
			this._daylightSavingAdjust(new Date(inst.currentYear, =
inst.currentMonth, inst.currentDay)));=0A=
		return this.formatDate(this._get(inst, "dateFormat"), date, =
this._getFormatConfig(inst));=0A=
	}=0A=
});=0A=
=0A=
/*=0A=
 * Bind hover events for datepicker elements.=0A=
 * Done via delegate so the binding only occurs once in the lifetime of =
the parent div.=0A=
 * Global datepicker_instActive, set by _updateDatepicker allows the =
handlers to find their way back to the active picker.=0A=
 */=0A=
function datepicker_bindHover(dpDiv) {=0A=
	var selector =3D "button, .ui-datepicker-prev, .ui-datepicker-next, =
.ui-datepicker-calendar td a";=0A=
	return dpDiv.delegate(selector, "mouseout", function() {=0A=
			$(this).removeClass("ui-state-hover");=0A=
			if (this.className.indexOf("ui-datepicker-prev") !=3D=3D -1) {=0A=
				$(this).removeClass("ui-datepicker-prev-hover");=0A=
			}=0A=
			if (this.className.indexOf("ui-datepicker-next") !=3D=3D -1) {=0A=
				$(this).removeClass("ui-datepicker-next-hover");=0A=
			}=0A=
		})=0A=
		.delegate( selector, "mouseover", datepicker_handleMouseover );=0A=
}=0A=
=0A=
function datepicker_handleMouseover() {=0A=
	if (!$.datepicker._isDisabledDatepicker( datepicker_instActive.inline? =
datepicker_instActive.dpDiv.parent()[0] : =
datepicker_instActive.input[0])) {=0A=
		=
$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-stat=
e-hover");=0A=
		$(this).addClass("ui-state-hover");=0A=
		if (this.className.indexOf("ui-datepicker-prev") !=3D=3D -1) {=0A=
			$(this).addClass("ui-datepicker-prev-hover");=0A=
		}=0A=
		if (this.className.indexOf("ui-datepicker-next") !=3D=3D -1) {=0A=
			$(this).addClass("ui-datepicker-next-hover");=0A=
		}=0A=
	}=0A=
}=0A=
=0A=
/* jQuery extend now ignores nulls! */=0A=
function datepicker_extendRemove(target, props) {=0A=
	$.extend(target, props);=0A=
	for (var name in props) {=0A=
		if (props[name] =3D=3D null) {=0A=
			target[name] =3D props[name];=0A=
		}=0A=
	}=0A=
	return target;=0A=
}=0A=
=0A=
/* Invoke the datepicker functionality.=0A=
   @param  options  string - a command, optionally followed by =
additional parameters or=0A=
					Object - settings for attaching new datepicker functionality=0A=
   @return  jQuery object */=0A=
$.fn.datepicker =3D function(options){=0A=
=0A=
	/* Verify an empty collection wasn't passed - Fixes #6976 */=0A=
	if ( !this.length ) {=0A=
		return this;=0A=
	}=0A=
=0A=
	/* Initialise the date picker. */=0A=
	if (!$.datepicker.initialized) {=0A=
		$(document).mousedown($.datepicker._checkExternalClick);=0A=
		$.datepicker.initialized =3D true;=0A=
	}=0A=
=0A=
	/* Append datepicker main container to body if not exist. */=0A=
	if ($("#"+$.datepicker._mainDivId).length =3D=3D=3D 0) {=0A=
		$("body").append($.datepicker.dpDiv);=0A=
	}=0A=
=0A=
	var otherArgs =3D Array.prototype.slice.call(arguments, 1);=0A=
	if (typeof options =3D=3D=3D "string" && (options =3D=3D=3D =
"isDisabled" || options =3D=3D=3D "getDate" || options =3D=3D=3D =
"widget")) {=0A=
		return $.datepicker["_" + options + "Datepicker"].=0A=
			apply($.datepicker, [this[0]].concat(otherArgs));=0A=
	}=0A=
	if (options =3D=3D=3D "option" && arguments.length =3D=3D=3D 2 && =
typeof arguments[1] =3D=3D=3D "string") {=0A=
		return $.datepicker["_" + options + "Datepicker"].=0A=
			apply($.datepicker, [this[0]].concat(otherArgs));=0A=
	}=0A=
	return this.each(function() {=0A=
		typeof options =3D=3D=3D "string" ?=0A=
			$.datepicker["_" + options + "Datepicker"].=0A=
				apply($.datepicker, [this].concat(otherArgs)) :=0A=
			$.datepicker._attachDatepicker(this, options);=0A=
	});=0A=
};=0A=
=0A=
$.datepicker =3D new Datepicker(); // singleton instance=0A=
$.datepicker.initialized =3D false;=0A=
$.datepicker.uuid =3D new Date().getTime();=0A=
$.datepicker.version =3D "1.11.1";=0A=
=0A=
var datepicker =3D $.datepicker;=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Dialog 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/dialog/=0A=
 */=0A=
=0A=
=0A=
var dialog =3D $.widget( "ui.dialog", {=0A=
	version: "1.11.1",=0A=
	options: {=0A=
		appendTo: "body",=0A=
		autoOpen: true,=0A=
		buttons: [],=0A=
		closeOnEscape: true,=0A=
		closeText: "Close",=0A=
		dialogClass: "",=0A=
		draggable: true,=0A=
		hide: null,=0A=
		height: "auto",=0A=
		maxHeight: null,=0A=
		maxWidth: null,=0A=
		minHeight: 150,=0A=
		minWidth: 150,=0A=
		modal: false,=0A=
		position: {=0A=
			my: "center",=0A=
			at: "center",=0A=
			of: window,=0A=
			collision: "fit",=0A=
			// Ensure the titlebar is always visible=0A=
			using: function( pos ) {=0A=
				var topOffset =3D $( this ).css( pos ).offset().top;=0A=
				if ( topOffset < 0 ) {=0A=
					$( this ).css( "top", pos.top - topOffset );=0A=
				}=0A=
			}=0A=
		},=0A=
		resizable: true,=0A=
		show: null,=0A=
		title: null,=0A=
		width: 300,=0A=
=0A=
		// callbacks=0A=
		beforeClose: null,=0A=
		close: null,=0A=
		drag: null,=0A=
		dragStart: null,=0A=
		dragStop: null,=0A=
		focus: null,=0A=
		open: null,=0A=
		resize: null,=0A=
		resizeStart: null,=0A=
		resizeStop: null=0A=
	},=0A=
=0A=
	sizeRelatedOptions: {=0A=
		buttons: true,=0A=
		height: true,=0A=
		maxHeight: true,=0A=
		maxWidth: true,=0A=
		minHeight: true,=0A=
		minWidth: true,=0A=
		width: true=0A=
	},=0A=
=0A=
	resizableRelatedOptions: {=0A=
		maxHeight: true,=0A=
		maxWidth: true,=0A=
		minHeight: true,=0A=
		minWidth: true=0A=
	},=0A=
=0A=
	_create: function() {=0A=
		this.originalCss =3D {=0A=
			display: this.element[ 0 ].style.display,=0A=
			width: this.element[ 0 ].style.width,=0A=
			minHeight: this.element[ 0 ].style.minHeight,=0A=
			maxHeight: this.element[ 0 ].style.maxHeight,=0A=
			height: this.element[ 0 ].style.height=0A=
		};=0A=
		this.originalPosition =3D {=0A=
			parent: this.element.parent(),=0A=
			index: this.element.parent().children().index( this.element )=0A=
		};=0A=
		this.originalTitle =3D this.element.attr( "title" );=0A=
		this.options.title =3D this.options.title || this.originalTitle;=0A=
=0A=
		this._createWrapper();=0A=
=0A=
		this.element=0A=
			.show()=0A=
			.removeAttr( "title" )=0A=
			.addClass( "ui-dialog-content ui-widget-content" )=0A=
			.appendTo( this.uiDialog );=0A=
=0A=
		this._createTitlebar();=0A=
		this._createButtonPane();=0A=
=0A=
		if ( this.options.draggable && $.fn.draggable ) {=0A=
			this._makeDraggable();=0A=
		}=0A=
		if ( this.options.resizable && $.fn.resizable ) {=0A=
			this._makeResizable();=0A=
		}=0A=
=0A=
		this._isOpen =3D false;=0A=
=0A=
		this._trackFocus();=0A=
	},=0A=
=0A=
	_init: function() {=0A=
		if ( this.options.autoOpen ) {=0A=
			this.open();=0A=
		}=0A=
	},=0A=
=0A=
	_appendTo: function() {=0A=
		var element =3D this.options.appendTo;=0A=
		if ( element && (element.jquery || element.nodeType) ) {=0A=
			return $( element );=0A=
		}=0A=
		return this.document.find( element || "body" ).eq( 0 );=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		var next,=0A=
			originalPosition =3D this.originalPosition;=0A=
=0A=
		this._destroyOverlay();=0A=
=0A=
		this.element=0A=
			.removeUniqueId()=0A=
			.removeClass( "ui-dialog-content ui-widget-content" )=0A=
			.css( this.originalCss )=0A=
			// Without detaching first, the following becomes really slow=0A=
			.detach();=0A=
=0A=
		this.uiDialog.stop( true, true ).remove();=0A=
=0A=
		if ( this.originalTitle ) {=0A=
			this.element.attr( "title", this.originalTitle );=0A=
		}=0A=
=0A=
		next =3D originalPosition.parent.children().eq( originalPosition.index =
);=0A=
		// Don't try to place the dialog next to itself (#8613)=0A=
		if ( next.length && next[ 0 ] !=3D=3D this.element[ 0 ] ) {=0A=
			next.before( this.element );=0A=
		} else {=0A=
			originalPosition.parent.append( this.element );=0A=
		}=0A=
	},=0A=
=0A=
	widget: function() {=0A=
		return this.uiDialog;=0A=
	},=0A=
=0A=
	disable: $.noop,=0A=
	enable: $.noop,=0A=
=0A=
	close: function( event ) {=0A=
		var activeElement,=0A=
			that =3D this;=0A=
=0A=
		if ( !this._isOpen || this._trigger( "beforeClose", event ) =3D=3D=3D =
false ) {=0A=
			return;=0A=
		}=0A=
=0A=
		this._isOpen =3D false;=0A=
		this._focusedElement =3D null;=0A=
		this._destroyOverlay();=0A=
		this._untrackInstance();=0A=
=0A=
		if ( !this.opener.filter( ":focusable" ).focus().length ) {=0A=
=0A=
			// support: IE9=0A=
			// IE9 throws an "Unspecified error" accessing document.activeElement =
from an <iframe>=0A=
			try {=0A=
				activeElement =3D this.document[ 0 ].activeElement;=0A=
=0A=
				// Support: IE9, IE10=0A=
				// If the <body> is blurred, IE will switch windows, see #4520=0A=
				if ( activeElement && activeElement.nodeName.toLowerCase() !=3D=3D =
"body" ) {=0A=
=0A=
					// Hiding a focused element doesn't trigger blur in WebKit=0A=
					// so in case we have nothing to focus on, explicitly blur the =
active element=0A=
					// https://bugs.webkit.org/show_bug.cgi?id=3D47182=0A=
					$( activeElement ).blur();=0A=
				}=0A=
			} catch ( error ) {}=0A=
		}=0A=
=0A=
		this._hide( this.uiDialog, this.options.hide, function() {=0A=
			that._trigger( "close", event );=0A=
		});=0A=
	},=0A=
=0A=
	isOpen: function() {=0A=
		return this._isOpen;=0A=
	},=0A=
=0A=
	moveToTop: function() {=0A=
		this._moveToTop();=0A=
	},=0A=
=0A=
	_moveToTop: function( event, silent ) {=0A=
		var moved =3D false,=0A=
			zIndicies =3D this.uiDialog.siblings( ".ui-front:visible" =
).map(function() {=0A=
				return +$( this ).css( "z-index" );=0A=
			}).get(),=0A=
			zIndexMax =3D Math.max.apply( null, zIndicies );=0A=
=0A=
		if ( zIndexMax >=3D +this.uiDialog.css( "z-index" ) ) {=0A=
			this.uiDialog.css( "z-index", zIndexMax + 1 );=0A=
			moved =3D true;=0A=
		}=0A=
=0A=
		if ( moved && !silent ) {=0A=
			this._trigger( "focus", event );=0A=
		}=0A=
		return moved;=0A=
	},=0A=
=0A=
	open: function() {=0A=
		var that =3D this;=0A=
		if ( this._isOpen ) {=0A=
			if ( this._moveToTop() ) {=0A=
				this._focusTabbable();=0A=
			}=0A=
			return;=0A=
		}=0A=
=0A=
		this._isOpen =3D true;=0A=
		this.opener =3D $( this.document[ 0 ].activeElement );=0A=
=0A=
		this._size();=0A=
		this._position();=0A=
		this._createOverlay();=0A=
		this._moveToTop( null, true );=0A=
=0A=
		// Ensure the overlay is moved to the top with the dialog, but only =
when=0A=
		// opening. The overlay shouldn't move after the dialog is open so that=0A=
		// modeless dialogs opened after the modal dialog stack properly.=0A=
		if ( this.overlay ) {=0A=
			this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );=0A=
		}=0A=
=0A=
		this._show( this.uiDialog, this.options.show, function() {=0A=
			that._focusTabbable();=0A=
			that._trigger( "focus" );=0A=
		});=0A=
=0A=
		// Track the dialog immediately upon openening in case a focus event=0A=
		// somehow occurs outside of the dialog before an element inside the=0A=
		// dialog is focused (#10152)=0A=
		this._makeFocusTarget();=0A=
=0A=
		this._trigger( "open" );=0A=
	},=0A=
=0A=
	_focusTabbable: function() {=0A=
		// Set focus to the first match:=0A=
		// 1. An element that was focused previously=0A=
		// 2. First element inside the dialog matching [autofocus]=0A=
		// 3. Tabbable element inside the content element=0A=
		// 4. Tabbable element inside the buttonpane=0A=
		// 5. The close button=0A=
		// 6. The dialog itself=0A=
		var hasFocus =3D this._focusedElement;=0A=
		if ( !hasFocus ) {=0A=
			hasFocus =3D this.element.find( "[autofocus]" );=0A=
		}=0A=
		if ( !hasFocus.length ) {=0A=
			hasFocus =3D this.element.find( ":tabbable" );=0A=
		}=0A=
		if ( !hasFocus.length ) {=0A=
			hasFocus =3D this.uiDialogButtonPane.find( ":tabbable" );=0A=
		}=0A=
		if ( !hasFocus.length ) {=0A=
			hasFocus =3D this.uiDialogTitlebarClose.filter( ":tabbable" );=0A=
		}=0A=
		if ( !hasFocus.length ) {=0A=
			hasFocus =3D this.uiDialog;=0A=
		}=0A=
		hasFocus.eq( 0 ).focus();=0A=
	},=0A=
=0A=
	_keepFocus: function( event ) {=0A=
		function checkFocus() {=0A=
			var activeElement =3D this.document[0].activeElement,=0A=
				isActive =3D this.uiDialog[0] =3D=3D=3D activeElement ||=0A=
					$.contains( this.uiDialog[0], activeElement );=0A=
			if ( !isActive ) {=0A=
				this._focusTabbable();=0A=
			}=0A=
		}=0A=
		event.preventDefault();=0A=
		checkFocus.call( this );=0A=
		// support: IE=0A=
		// IE <=3D 8 doesn't prevent moving focus even with =
event.preventDefault()=0A=
		// so we check again later=0A=
		this._delay( checkFocus );=0A=
	},=0A=
=0A=
	_createWrapper: function() {=0A=
		this.uiDialog =3D $("<div>")=0A=
			.addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all =
ui-front " +=0A=
				this.options.dialogClass )=0A=
			.hide()=0A=
			.attr({=0A=
				// Setting tabIndex makes the div focusable=0A=
				tabIndex: -1,=0A=
				role: "dialog"=0A=
			})=0A=
			.appendTo( this._appendTo() );=0A=
=0A=
		this._on( this.uiDialog, {=0A=
			keydown: function( event ) {=0A=
				if ( this.options.closeOnEscape && !event.isDefaultPrevented() && =
event.keyCode &&=0A=
						event.keyCode =3D=3D=3D $.ui.keyCode.ESCAPE ) {=0A=
					event.preventDefault();=0A=
					this.close( event );=0A=
					return;=0A=
				}=0A=
=0A=
				// prevent tabbing out of dialogs=0A=
				if ( event.keyCode !=3D=3D $.ui.keyCode.TAB || =
event.isDefaultPrevented() ) {=0A=
					return;=0A=
				}=0A=
				var tabbables =3D this.uiDialog.find( ":tabbable" ),=0A=
					first =3D tabbables.filter( ":first" ),=0A=
					last =3D tabbables.filter( ":last" );=0A=
=0A=
				if ( ( event.target =3D=3D=3D last[0] || event.target =3D=3D=3D =
this.uiDialog[0] ) && !event.shiftKey ) {=0A=
					this._delay(function() {=0A=
						first.focus();=0A=
					});=0A=
					event.preventDefault();=0A=
				} else if ( ( event.target =3D=3D=3D first[0] || event.target =
=3D=3D=3D this.uiDialog[0] ) && event.shiftKey ) {=0A=
					this._delay(function() {=0A=
						last.focus();=0A=
					});=0A=
					event.preventDefault();=0A=
				}=0A=
			},=0A=
			mousedown: function( event ) {=0A=
				if ( this._moveToTop( event ) ) {=0A=
					this._focusTabbable();=0A=
				}=0A=
			}=0A=
		});=0A=
=0A=
		// We assume that any existing aria-describedby attribute means=0A=
		// that the dialog content is marked up properly=0A=
		// otherwise we brute force the content as the description=0A=
		if ( !this.element.find( "[aria-describedby]" ).length ) {=0A=
			this.uiDialog.attr({=0A=
				"aria-describedby": this.element.uniqueId().attr( "id" )=0A=
			});=0A=
		}=0A=
	},=0A=
=0A=
	_createTitlebar: function() {=0A=
		var uiDialogTitle;=0A=
=0A=
		this.uiDialogTitlebar =3D $( "<div>" )=0A=
			.addClass( "ui-dialog-titlebar ui-widget-header ui-corner-all =
ui-helper-clearfix" )=0A=
			.prependTo( this.uiDialog );=0A=
		this._on( this.uiDialogTitlebar, {=0A=
			mousedown: function( event ) {=0A=
				// Don't prevent click on close button (#8838)=0A=
				// Focusing a dialog that is partially scrolled out of view=0A=
				// causes the browser to scroll it into view, preventing the click =
event=0A=
				if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {=0A=
					// Dialog isn't getting focus when dragging (#8063)=0A=
					this.uiDialog.focus();=0A=
				}=0A=
			}=0A=
		});=0A=
=0A=
		// support: IE=0A=
		// Use type=3D"button" to prevent enter keypresses in textboxes from =
closing the=0A=
		// dialog in IE (#9312)=0A=
		this.uiDialogTitlebarClose =3D $( "<button type=3D'button'></button>" )=0A=
			.button({=0A=
				label: this.options.closeText,=0A=
				icons: {=0A=
					primary: "ui-icon-closethick"=0A=
				},=0A=
				text: false=0A=
			})=0A=
			.addClass( "ui-dialog-titlebar-close" )=0A=
			.appendTo( this.uiDialogTitlebar );=0A=
		this._on( this.uiDialogTitlebarClose, {=0A=
			click: function( event ) {=0A=
				event.preventDefault();=0A=
				this.close( event );=0A=
			}=0A=
		});=0A=
=0A=
		uiDialogTitle =3D $( "<span>" )=0A=
			.uniqueId()=0A=
			.addClass( "ui-dialog-title" )=0A=
			.prependTo( this.uiDialogTitlebar );=0A=
		this._title( uiDialogTitle );=0A=
=0A=
		this.uiDialog.attr({=0A=
			"aria-labelledby": uiDialogTitle.attr( "id" )=0A=
		});=0A=
	},=0A=
=0A=
	_title: function( title ) {=0A=
		if ( !this.options.title ) {=0A=
			title.html( "&#160;" );=0A=
		}=0A=
		title.text( this.options.title );=0A=
	},=0A=
=0A=
	_createButtonPane: function() {=0A=
		this.uiDialogButtonPane =3D $( "<div>" )=0A=
			.addClass( "ui-dialog-buttonpane ui-widget-content =
ui-helper-clearfix" );=0A=
=0A=
		this.uiButtonSet =3D $( "<div>" )=0A=
			.addClass( "ui-dialog-buttonset" )=0A=
			.appendTo( this.uiDialogButtonPane );=0A=
=0A=
		this._createButtons();=0A=
	},=0A=
=0A=
	_createButtons: function() {=0A=
		var that =3D this,=0A=
			buttons =3D this.options.buttons;=0A=
=0A=
		// if we already have a button pane, remove it=0A=
		this.uiDialogButtonPane.remove();=0A=
		this.uiButtonSet.empty();=0A=
=0A=
		if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && =
!buttons.length) ) {=0A=
			this.uiDialog.removeClass( "ui-dialog-buttons" );=0A=
			return;=0A=
		}=0A=
=0A=
		$.each( buttons, function( name, props ) {=0A=
			var click, buttonOptions;=0A=
			props =3D $.isFunction( props ) ?=0A=
				{ click: props, text: name } :=0A=
				props;=0A=
			// Default to a non-submitting button=0A=
			props =3D $.extend( { type: "button" }, props );=0A=
			// Change the context for the click callback to be the main element=0A=
			click =3D props.click;=0A=
			props.click =3D function() {=0A=
				click.apply( that.element[ 0 ], arguments );=0A=
			};=0A=
			buttonOptions =3D {=0A=
				icons: props.icons,=0A=
				text: props.showText=0A=
			};=0A=
			delete props.icons;=0A=
			delete props.showText;=0A=
			$( "<button></button>", props )=0A=
				.button( buttonOptions )=0A=
				.appendTo( that.uiButtonSet );=0A=
		});=0A=
		this.uiDialog.addClass( "ui-dialog-buttons" );=0A=
		this.uiDialogButtonPane.appendTo( this.uiDialog );=0A=
	},=0A=
=0A=
	_makeDraggable: function() {=0A=
		var that =3D this,=0A=
			options =3D this.options;=0A=
=0A=
		function filteredUi( ui ) {=0A=
			return {=0A=
				position: ui.position,=0A=
				offset: ui.offset=0A=
			};=0A=
		}=0A=
=0A=
		this.uiDialog.draggable({=0A=
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",=0A=
			handle: ".ui-dialog-titlebar",=0A=
			containment: "document",=0A=
			start: function( event, ui ) {=0A=
				$( this ).addClass( "ui-dialog-dragging" );=0A=
				that._blockFrames();=0A=
				that._trigger( "dragStart", event, filteredUi( ui ) );=0A=
			},=0A=
			drag: function( event, ui ) {=0A=
				that._trigger( "drag", event, filteredUi( ui ) );=0A=
			},=0A=
			stop: function( event, ui ) {=0A=
				var left =3D ui.offset.left - that.document.scrollLeft(),=0A=
					top =3D ui.offset.top - that.document.scrollTop();=0A=
=0A=
				options.position =3D {=0A=
					my: "left top",=0A=
					at: "left" + (left >=3D 0 ? "+" : "") + left + " " +=0A=
						"top" + (top >=3D 0 ? "+" : "") + top,=0A=
					of: that.window=0A=
				};=0A=
				$( this ).removeClass( "ui-dialog-dragging" );=0A=
				that._unblockFrames();=0A=
				that._trigger( "dragStop", event, filteredUi( ui ) );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	_makeResizable: function() {=0A=
		var that =3D this,=0A=
			options =3D this.options,=0A=
			handles =3D options.resizable,=0A=
			// .ui-resizable has position: relative defined in the stylesheet=0A=
			// but dialogs have to use absolute or fixed positioning=0A=
			position =3D this.uiDialog.css("position"),=0A=
			resizeHandles =3D typeof handles =3D=3D=3D "string" ?=0A=
				handles	:=0A=
				"n,e,s,w,se,sw,ne,nw";=0A=
=0A=
		function filteredUi( ui ) {=0A=
			return {=0A=
				originalPosition: ui.originalPosition,=0A=
				originalSize: ui.originalSize,=0A=
				position: ui.position,=0A=
				size: ui.size=0A=
			};=0A=
		}=0A=
=0A=
		this.uiDialog.resizable({=0A=
			cancel: ".ui-dialog-content",=0A=
			containment: "document",=0A=
			alsoResize: this.element,=0A=
			maxWidth: options.maxWidth,=0A=
			maxHeight: options.maxHeight,=0A=
			minWidth: options.minWidth,=0A=
			minHeight: this._minHeight(),=0A=
			handles: resizeHandles,=0A=
			start: function( event, ui ) {=0A=
				$( this ).addClass( "ui-dialog-resizing" );=0A=
				that._blockFrames();=0A=
				that._trigger( "resizeStart", event, filteredUi( ui ) );=0A=
			},=0A=
			resize: function( event, ui ) {=0A=
				that._trigger( "resize", event, filteredUi( ui ) );=0A=
			},=0A=
			stop: function( event, ui ) {=0A=
				var offset =3D that.uiDialog.offset(),=0A=
					left =3D offset.left - that.document.scrollLeft(),=0A=
					top =3D offset.top - that.document.scrollTop();=0A=
=0A=
				options.height =3D that.uiDialog.height();=0A=
				options.width =3D that.uiDialog.width();=0A=
				options.position =3D {=0A=
					my: "left top",=0A=
					at: "left" + (left >=3D 0 ? "+" : "") + left + " " +=0A=
						"top" + (top >=3D 0 ? "+" : "") + top,=0A=
					of: that.window=0A=
				};=0A=
				$( this ).removeClass( "ui-dialog-resizing" );=0A=
				that._unblockFrames();=0A=
				that._trigger( "resizeStop", event, filteredUi( ui ) );=0A=
			}=0A=
		})=0A=
		.css( "position", position );=0A=
	},=0A=
=0A=
	_trackFocus: function() {=0A=
		this._on( this.widget(), {=0A=
			focusin: function( event ) {=0A=
				this._makeFocusTarget();=0A=
				this._focusedElement =3D $( event.target );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	_makeFocusTarget: function() {=0A=
		this._untrackInstance();=0A=
		this._trackingInstances().unshift( this );=0A=
	},=0A=
=0A=
	_untrackInstance: function() {=0A=
		var instances =3D this._trackingInstances(),=0A=
			exists =3D $.inArray( this, instances );=0A=
		if ( exists !=3D=3D -1 ) {=0A=
			instances.splice( exists, 1 );=0A=
		}=0A=
	},=0A=
=0A=
	_trackingInstances: function() {=0A=
		var instances =3D this.document.data( "ui-dialog-instances" );=0A=
		if ( !instances ) {=0A=
			instances =3D [];=0A=
			this.document.data( "ui-dialog-instances", instances );=0A=
		}=0A=
		return instances;=0A=
	},=0A=
=0A=
	_minHeight: function() {=0A=
		var options =3D this.options;=0A=
=0A=
		return options.height =3D=3D=3D "auto" ?=0A=
			options.minHeight :=0A=
			Math.min( options.minHeight, options.height );=0A=
	},=0A=
=0A=
	_position: function() {=0A=
		// Need to show the dialog to get the actual offset in the position =
plugin=0A=
		var isVisible =3D this.uiDialog.is( ":visible" );=0A=
		if ( !isVisible ) {=0A=
			this.uiDialog.show();=0A=
		}=0A=
		this.uiDialog.position( this.options.position );=0A=
		if ( !isVisible ) {=0A=
			this.uiDialog.hide();=0A=
		}=0A=
	},=0A=
=0A=
	_setOptions: function( options ) {=0A=
		var that =3D this,=0A=
			resize =3D false,=0A=
			resizableOptions =3D {};=0A=
=0A=
		$.each( options, function( key, value ) {=0A=
			that._setOption( key, value );=0A=
=0A=
			if ( key in that.sizeRelatedOptions ) {=0A=
				resize =3D true;=0A=
			}=0A=
			if ( key in that.resizableRelatedOptions ) {=0A=
				resizableOptions[ key ] =3D value;=0A=
			}=0A=
		});=0A=
=0A=
		if ( resize ) {=0A=
			this._size();=0A=
			this._position();=0A=
		}=0A=
		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {=0A=
			this.uiDialog.resizable( "option", resizableOptions );=0A=
		}=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		var isDraggable, isResizable,=0A=
			uiDialog =3D this.uiDialog;=0A=
=0A=
		if ( key =3D=3D=3D "dialogClass" ) {=0A=
			uiDialog=0A=
				.removeClass( this.options.dialogClass )=0A=
				.addClass( value );=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			return;=0A=
		}=0A=
=0A=
		this._super( key, value );=0A=
=0A=
		if ( key =3D=3D=3D "appendTo" ) {=0A=
			this.uiDialog.appendTo( this._appendTo() );=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "buttons" ) {=0A=
			this._createButtons();=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "closeText" ) {=0A=
			this.uiDialogTitlebarClose.button({=0A=
				// Ensure that we always pass a string=0A=
				label: "" + value=0A=
			});=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "draggable" ) {=0A=
			isDraggable =3D uiDialog.is( ":data(ui-draggable)" );=0A=
			if ( isDraggable && !value ) {=0A=
				uiDialog.draggable( "destroy" );=0A=
			}=0A=
=0A=
			if ( !isDraggable && value ) {=0A=
				this._makeDraggable();=0A=
			}=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "position" ) {=0A=
			this._position();=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "resizable" ) {=0A=
			// currently resizable, becoming non-resizable=0A=
			isResizable =3D uiDialog.is( ":data(ui-resizable)" );=0A=
			if ( isResizable && !value ) {=0A=
				uiDialog.resizable( "destroy" );=0A=
			}=0A=
=0A=
			// currently resizable, changing handles=0A=
			if ( isResizable && typeof value =3D=3D=3D "string" ) {=0A=
				uiDialog.resizable( "option", "handles", value );=0A=
			}=0A=
=0A=
			// currently non-resizable, becoming resizable=0A=
			if ( !isResizable && value !=3D=3D false ) {=0A=
				this._makeResizable();=0A=
			}=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "title" ) {=0A=
			this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );=0A=
		}=0A=
	},=0A=
=0A=
	_size: function() {=0A=
		// If the user has resized the dialog, the .ui-dialog and =
.ui-dialog-content=0A=
		// divs will both have width and height set, so we need to reset them=0A=
		var nonContentHeight, minContentHeight, maxContentHeight,=0A=
			options =3D this.options;=0A=
=0A=
		// Reset content sizing=0A=
		this.element.show().css({=0A=
			width: "auto",=0A=
			minHeight: 0,=0A=
			maxHeight: "none",=0A=
			height: 0=0A=
		});=0A=
=0A=
		if ( options.minWidth > options.width ) {=0A=
			options.width =3D options.minWidth;=0A=
		}=0A=
=0A=
		// reset wrapper sizing=0A=
		// determine the height of all the non-content elements=0A=
		nonContentHeight =3D this.uiDialog.css({=0A=
				height: "auto",=0A=
				width: options.width=0A=
			})=0A=
			.outerHeight();=0A=
		minContentHeight =3D Math.max( 0, options.minHeight - nonContentHeight =
);=0A=
		maxContentHeight =3D typeof options.maxHeight =3D=3D=3D "number" ?=0A=
			Math.max( 0, options.maxHeight - nonContentHeight ) :=0A=
			"none";=0A=
=0A=
		if ( options.height =3D=3D=3D "auto" ) {=0A=
			this.element.css({=0A=
				minHeight: minContentHeight,=0A=
				maxHeight: maxContentHeight,=0A=
				height: "auto"=0A=
			});=0A=
		} else {=0A=
			this.element.height( Math.max( 0, options.height - nonContentHeight ) =
);=0A=
		}=0A=
=0A=
		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {=0A=
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );=0A=
		}=0A=
	},=0A=
=0A=
	_blockFrames: function() {=0A=
		this.iframeBlocks =3D this.document.find( "iframe" ).map(function() {=0A=
			var iframe =3D $( this );=0A=
=0A=
			return $( "<div>" )=0A=
				.css({=0A=
					position: "absolute",=0A=
					width: iframe.outerWidth(),=0A=
					height: iframe.outerHeight()=0A=
				})=0A=
				.appendTo( iframe.parent() )=0A=
				.offset( iframe.offset() )[0];=0A=
		});=0A=
	},=0A=
=0A=
	_unblockFrames: function() {=0A=
		if ( this.iframeBlocks ) {=0A=
			this.iframeBlocks.remove();=0A=
			delete this.iframeBlocks;=0A=
		}=0A=
	},=0A=
=0A=
	_allowInteraction: function( event ) {=0A=
		if ( $( event.target ).closest( ".ui-dialog" ).length ) {=0A=
			return true;=0A=
		}=0A=
=0A=
		// TODO: Remove hack when datepicker implements=0A=
		// the .ui-front logic (#8989)=0A=
		return !!$( event.target ).closest( ".ui-datepicker" ).length;=0A=
	},=0A=
=0A=
	_createOverlay: function() {=0A=
		if ( !this.options.modal ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// We use a delay in case the overlay is created from an=0A=
		// event that we're going to be cancelling (#2804)=0A=
		var isOpening =3D true;=0A=
		this._delay(function() {=0A=
			isOpening =3D false;=0A=
		});=0A=
=0A=
		if ( !this.document.data( "ui-dialog-overlays" ) ) {=0A=
=0A=
			// Prevent use of anchors and inputs=0A=
			// Using _on() for an event handler shared across many instances is=0A=
			// safe because the dialogs stack and must be closed in reverse order=0A=
			this._on( this.document, {=0A=
				focusin: function( event ) {=0A=
					if ( isOpening ) {=0A=
						return;=0A=
					}=0A=
=0A=
					if ( !this._allowInteraction( event ) ) {=0A=
						event.preventDefault();=0A=
						this._trackingInstances()[ 0 ]._focusTabbable();=0A=
					}=0A=
				}=0A=
			});=0A=
		}=0A=
=0A=
		this.overlay =3D $( "<div>" )=0A=
			.addClass( "ui-widget-overlay ui-front" )=0A=
			.appendTo( this._appendTo() );=0A=
		this._on( this.overlay, {=0A=
			mousedown: "_keepFocus"=0A=
		});=0A=
		this.document.data( "ui-dialog-overlays",=0A=
			(this.document.data( "ui-dialog-overlays" ) || 0) + 1 );=0A=
	},=0A=
=0A=
	_destroyOverlay: function() {=0A=
		if ( !this.options.modal ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( this.overlay ) {=0A=
			var overlays =3D this.document.data( "ui-dialog-overlays" ) - 1;=0A=
=0A=
			if ( !overlays ) {=0A=
				this.document=0A=
					.unbind( "focusin" )=0A=
					.removeData( "ui-dialog-overlays" );=0A=
			} else {=0A=
				this.document.data( "ui-dialog-overlays", overlays );=0A=
			}=0A=
=0A=
			this.overlay.remove();=0A=
			this.overlay =3D null;=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Progressbar 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/progressbar/=0A=
 */=0A=
=0A=
=0A=
var progressbar =3D $.widget( "ui.progressbar", {=0A=
	version: "1.11.1",=0A=
	options: {=0A=
		max: 100,=0A=
		value: 0,=0A=
=0A=
		change: null,=0A=
		complete: null=0A=
	},=0A=
=0A=
	min: 0,=0A=
=0A=
	_create: function() {=0A=
		// Constrain initial value=0A=
		this.oldValue =3D this.options.value =3D this._constrainedValue();=0A=
=0A=
		this.element=0A=
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" =
)=0A=
			.attr({=0A=
				// Only set static values, aria-valuenow and aria-valuemax are=0A=
				// set inside _refreshValue()=0A=
				role: "progressbar",=0A=
				"aria-valuemin": this.min=0A=
			});=0A=
=0A=
		this.valueDiv =3D $( "<div class=3D'ui-progressbar-value =
ui-widget-header ui-corner-left'></div>" )=0A=
			.appendTo( this.element );=0A=
=0A=
		this._refreshValue();=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		this.element=0A=
			.removeClass( "ui-progressbar ui-widget ui-widget-content =
ui-corner-all" )=0A=
			.removeAttr( "role" )=0A=
			.removeAttr( "aria-valuemin" )=0A=
			.removeAttr( "aria-valuemax" )=0A=
			.removeAttr( "aria-valuenow" );=0A=
=0A=
		this.valueDiv.remove();=0A=
	},=0A=
=0A=
	value: function( newValue ) {=0A=
		if ( newValue =3D=3D=3D undefined ) {=0A=
			return this.options.value;=0A=
		}=0A=
=0A=
		this.options.value =3D this._constrainedValue( newValue );=0A=
		this._refreshValue();=0A=
	},=0A=
=0A=
	_constrainedValue: function( newValue ) {=0A=
		if ( newValue =3D=3D=3D undefined ) {=0A=
			newValue =3D this.options.value;=0A=
		}=0A=
=0A=
		this.indeterminate =3D newValue =3D=3D=3D false;=0A=
=0A=
		// sanitize value=0A=
		if ( typeof newValue !=3D=3D "number" ) {=0A=
			newValue =3D 0;=0A=
		}=0A=
=0A=
		return this.indeterminate ? false :=0A=
			Math.min( this.options.max, Math.max( this.min, newValue ) );=0A=
	},=0A=
=0A=
	_setOptions: function( options ) {=0A=
		// Ensure "value" option is set after other values (like max)=0A=
		var value =3D options.value;=0A=
		delete options.value;=0A=
=0A=
		this._super( options );=0A=
=0A=
		this.options.value =3D this._constrainedValue( value );=0A=
		this._refreshValue();=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		if ( key =3D=3D=3D "max" ) {=0A=
			// Don't allow a max less than min=0A=
			value =3D Math.max( this.min, value );=0A=
		}=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			this.element=0A=
				.toggleClass( "ui-state-disabled", !!value )=0A=
				.attr( "aria-disabled", value );=0A=
		}=0A=
		this._super( key, value );=0A=
	},=0A=
=0A=
	_percentage: function() {=0A=
		return this.indeterminate ? 100 : 100 * ( this.options.value - =
this.min ) / ( this.options.max - this.min );=0A=
	},=0A=
=0A=
	_refreshValue: function() {=0A=
		var value =3D this.options.value,=0A=
			percentage =3D this._percentage();=0A=
=0A=
		this.valueDiv=0A=
			.toggle( this.indeterminate || value > this.min )=0A=
			.toggleClass( "ui-corner-right", value =3D=3D=3D this.options.max )=0A=
			.width( percentage.toFixed(0) + "%" );=0A=
=0A=
		this.element.toggleClass( "ui-progressbar-indeterminate", =
this.indeterminate );=0A=
=0A=
		if ( this.indeterminate ) {=0A=
			this.element.removeAttr( "aria-valuenow" );=0A=
			if ( !this.overlayDiv ) {=0A=
				this.overlayDiv =3D $( "<div =
class=3D'ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );=0A=
			}=0A=
		} else {=0A=
			this.element.attr({=0A=
				"aria-valuemax": this.options.max,=0A=
				"aria-valuenow": value=0A=
			});=0A=
			if ( this.overlayDiv ) {=0A=
				this.overlayDiv.remove();=0A=
				this.overlayDiv =3D null;=0A=
			}=0A=
		}=0A=
=0A=
		if ( this.oldValue !=3D=3D value ) {=0A=
			this.oldValue =3D value;=0A=
			this._trigger( "change" );=0A=
		}=0A=
		if ( value =3D=3D=3D this.options.max ) {=0A=
			this._trigger( "complete" );=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Selectmenu 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/selectmenu=0A=
 */=0A=
=0A=
=0A=
var selectmenu =3D $.widget( "ui.selectmenu", {=0A=
	version: "1.11.1",=0A=
	defaultElement: "<select>",=0A=
	options: {=0A=
		appendTo: null,=0A=
		disabled: null,=0A=
		icons: {=0A=
			button: "ui-icon-triangle-1-s"=0A=
		},=0A=
		position: {=0A=
			my: "left top",=0A=
			at: "left bottom",=0A=
			collision: "none"=0A=
		},=0A=
		width: null,=0A=
=0A=
		// callbacks=0A=
		change: null,=0A=
		close: null,=0A=
		focus: null,=0A=
		open: null,=0A=
		select: null=0A=
	},=0A=
=0A=
	_create: function() {=0A=
		var selectmenuId =3D this.element.uniqueId().attr( "id" );=0A=
		this.ids =3D {=0A=
			element: selectmenuId,=0A=
			button: selectmenuId + "-button",=0A=
			menu: selectmenuId + "-menu"=0A=
		};=0A=
=0A=
		this._drawButton();=0A=
		this._drawMenu();=0A=
=0A=
		if ( this.options.disabled ) {=0A=
			this.disable();=0A=
		}=0A=
	},=0A=
=0A=
	_drawButton: function() {=0A=
		var that =3D this,=0A=
			tabindex =3D this.element.attr( "tabindex" );=0A=
=0A=
		// Associate existing label with the new button=0A=
		this.label =3D $( "label[for=3D'" + this.ids.element + "']" ).attr( =
"for", this.ids.button );=0A=
		this._on( this.label, {=0A=
			click: function( event ) {=0A=
				this.button.focus();=0A=
				event.preventDefault();=0A=
			}=0A=
		});=0A=
=0A=
		// Hide original select element=0A=
		this.element.hide();=0A=
=0A=
		// Create button=0A=
		this.button =3D $( "<span>", {=0A=
			"class": "ui-selectmenu-button ui-widget ui-state-default =
ui-corner-all",=0A=
			tabindex: tabindex || this.options.disabled ? -1 : 0,=0A=
			id: this.ids.button,=0A=
			role: "combobox",=0A=
			"aria-expanded": "false",=0A=
			"aria-autocomplete": "list",=0A=
			"aria-owns": this.ids.menu,=0A=
			"aria-haspopup": "true"=0A=
		})=0A=
			.insertAfter( this.element );=0A=
=0A=
		$( "<span>", {=0A=
			"class": "ui-icon " + this.options.icons.button=0A=
		})=0A=
			.prependTo( this.button );=0A=
=0A=
		this.buttonText =3D $( "<span>", {=0A=
			"class": "ui-selectmenu-text"=0A=
		})=0A=
			.appendTo( this.button );=0A=
=0A=
		this._setText( this.buttonText, this.element.find( "option:selected" =
).text() );=0A=
		this._resizeButton();=0A=
=0A=
		this._on( this.button, this._buttonEvents );=0A=
		this.button.one( "focusin", function() {=0A=
=0A=
			// Delay rendering the menu items until the button receives focus.=0A=
			// The menu may have already been rendered via a programmatic open.=0A=
			if ( !that.menuItems ) {=0A=
				that._refreshMenu();=0A=
			}=0A=
		});=0A=
		this._hoverable( this.button );=0A=
		this._focusable( this.button );=0A=
	},=0A=
=0A=
	_drawMenu: function() {=0A=
		var that =3D this;=0A=
=0A=
		// Create menu=0A=
		this.menu =3D $( "<ul>", {=0A=
			"aria-hidden": "true",=0A=
			"aria-labelledby": this.ids.button,=0A=
			id: this.ids.menu=0A=
		});=0A=
=0A=
		// Wrap menu=0A=
		this.menuWrap =3D $( "<div>", {=0A=
			"class": "ui-selectmenu-menu ui-front"=0A=
		})=0A=
			.append( this.menu )=0A=
			.appendTo( this._appendTo() );=0A=
=0A=
		// Initialize menu widget=0A=
		this.menuInstance =3D this.menu=0A=
			.menu({=0A=
				role: "listbox",=0A=
				select: function( event, ui ) {=0A=
					event.preventDefault();=0A=
					that._select( ui.item.data( "ui-selectmenu-item" ), event );=0A=
				},=0A=
				focus: function( event, ui ) {=0A=
					var item =3D ui.item.data( "ui-selectmenu-item" );=0A=
=0A=
					// Prevent inital focus from firing and check if its a newly =
focused item=0A=
					if ( that.focusIndex !=3D null && item.index !=3D=3D =
that.focusIndex ) {=0A=
						that._trigger( "focus", event, { item: item } );=0A=
						if ( !that.isOpen ) {=0A=
							that._select( item, event );=0A=
						}=0A=
					}=0A=
					that.focusIndex =3D item.index;=0A=
=0A=
					that.button.attr( "aria-activedescendant",=0A=
						that.menuItems.eq( item.index ).attr( "id" ) );=0A=
				}=0A=
			})=0A=
			.menu( "instance" );=0A=
=0A=
		// Adjust menu styles to dropdown=0A=
		this.menu=0A=
			.addClass( "ui-corner-bottom" )=0A=
			.removeClass( "ui-corner-all" );=0A=
=0A=
		// Don't close the menu on mouseleave=0A=
		this.menuInstance._off( this.menu, "mouseleave" );=0A=
=0A=
		// Cancel the menu's collapseAll on document click=0A=
		this.menuInstance._closeOnDocumentClick =3D function() {=0A=
			return false;=0A=
		};=0A=
=0A=
		// Selects often contain empty items, but never contain dividers=0A=
		this.menuInstance._isDivider =3D function() {=0A=
			return false;=0A=
		};=0A=
	},=0A=
=0A=
	refresh: function() {=0A=
		this._refreshMenu();=0A=
		this._setText( this.buttonText, this._getSelectedItem().text() );=0A=
		if ( !this.options.width ) {=0A=
			this._resizeButton();=0A=
		}=0A=
	},=0A=
=0A=
	_refreshMenu: function() {=0A=
		this.menu.empty();=0A=
=0A=
		var item,=0A=
			options =3D this.element.find( "option" );=0A=
=0A=
		if ( !options.length ) {=0A=
			return;=0A=
		}=0A=
=0A=
		this._parseOptions( options );=0A=
		this._renderMenu( this.menu, this.items );=0A=
=0A=
		this.menuInstance.refresh();=0A=
		this.menuItems =3D this.menu.find( "li" ).not( =
".ui-selectmenu-optgroup" );=0A=
=0A=
		item =3D this._getSelectedItem();=0A=
=0A=
		// Update the menu to have the correct item focused=0A=
		this.menuInstance.focus( null, item );=0A=
		this._setAria( item.data( "ui-selectmenu-item" ) );=0A=
=0A=
		// Set disabled state=0A=
		this._setOption( "disabled", this.element.prop( "disabled" ) );=0A=
	},=0A=
=0A=
	open: function( event ) {=0A=
		if ( this.options.disabled ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// If this is the first time the menu is being opened, render the items=0A=
		if ( !this.menuItems ) {=0A=
			this._refreshMenu();=0A=
		} else {=0A=
=0A=
			// Menu clears focus on close, reset focus to selected item=0A=
			this.menu.find( ".ui-state-focus" ).removeClass( "ui-state-focus" );=0A=
			this.menuInstance.focus( null, this._getSelectedItem() );=0A=
		}=0A=
=0A=
		this.isOpen =3D true;=0A=
		this._toggleAttr();=0A=
		this._resizeMenu();=0A=
		this._position();=0A=
=0A=
		this._on( this.document, this._documentClick );=0A=
=0A=
		this._trigger( "open", event );=0A=
	},=0A=
=0A=
	_position: function() {=0A=
		this.menuWrap.position( $.extend( { of: this.button }, =
this.options.position ) );=0A=
	},=0A=
=0A=
	close: function( event ) {=0A=
		if ( !this.isOpen ) {=0A=
			return;=0A=
		}=0A=
=0A=
		this.isOpen =3D false;=0A=
		this._toggleAttr();=0A=
=0A=
		this._off( this.document );=0A=
=0A=
		this._trigger( "close", event );=0A=
	},=0A=
=0A=
	widget: function() {=0A=
		return this.button;=0A=
	},=0A=
=0A=
	menuWidget: function() {=0A=
		return this.menu;=0A=
	},=0A=
=0A=
	_renderMenu: function( ul, items ) {=0A=
		var that =3D this,=0A=
			currentOptgroup =3D "";=0A=
=0A=
		$.each( items, function( index, item ) {=0A=
			if ( item.optgroup !=3D=3D currentOptgroup ) {=0A=
				$( "<li>", {=0A=
					"class": "ui-selectmenu-optgroup ui-menu-divider" +=0A=
						( item.element.parent( "optgroup" ).prop( "disabled" ) ?=0A=
							" ui-state-disabled" :=0A=
							"" ),=0A=
					text: item.optgroup=0A=
				})=0A=
					.appendTo( ul );=0A=
=0A=
				currentOptgroup =3D item.optgroup;=0A=
			}=0A=
=0A=
			that._renderItemData( ul, item );=0A=
		});=0A=
	},=0A=
=0A=
	_renderItemData: function( ul, item ) {=0A=
		return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );=0A=
	},=0A=
=0A=
	_renderItem: function( ul, item ) {=0A=
		var li =3D $( "<li>" );=0A=
=0A=
		if ( item.disabled ) {=0A=
			li.addClass( "ui-state-disabled" );=0A=
		}=0A=
		this._setText( li, item.label );=0A=
=0A=
		return li.appendTo( ul );=0A=
	},=0A=
=0A=
	_setText: function( element, value ) {=0A=
		if ( value ) {=0A=
			element.text( value );=0A=
		} else {=0A=
			element.html( "&#160;" );=0A=
		}=0A=
	},=0A=
=0A=
	_move: function( direction, event ) {=0A=
		var item, next,=0A=
			filter =3D ".ui-menu-item";=0A=
=0A=
		if ( this.isOpen ) {=0A=
			item =3D this.menuItems.eq( this.focusIndex );=0A=
		} else {=0A=
			item =3D this.menuItems.eq( this.element[ 0 ].selectedIndex );=0A=
			filter +=3D ":not(.ui-state-disabled)";=0A=
		}=0A=
=0A=
		if ( direction =3D=3D=3D "first" || direction =3D=3D=3D "last" ) {=0A=
			next =3D item[ direction =3D=3D=3D "first" ? "prevAll" : "nextAll" ]( =
filter ).eq( -1 );=0A=
		} else {=0A=
			next =3D item[ direction + "All" ]( filter ).eq( 0 );=0A=
		}=0A=
=0A=
		if ( next.length ) {=0A=
			this.menuInstance.focus( event, next );=0A=
		}=0A=
	},=0A=
=0A=
	_getSelectedItem: function() {=0A=
		return this.menuItems.eq( this.element[ 0 ].selectedIndex );=0A=
	},=0A=
=0A=
	_toggle: function( event ) {=0A=
		this[ this.isOpen ? "close" : "open" ]( event );=0A=
	},=0A=
=0A=
	_documentClick: {=0A=
		mousedown: function( event ) {=0A=
			if ( !this.isOpen ) {=0A=
				return;=0A=
			}=0A=
=0A=
			if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" + =
this.ids.button ).length ) {=0A=
				this.close( event );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	_buttonEvents: {=0A=
=0A=
		// Prevent text selection from being reset when interacting with the =
selectmenu (#10144)=0A=
		mousedown: function( event ) {=0A=
			event.preventDefault();=0A=
		},=0A=
=0A=
		click: "_toggle",=0A=
=0A=
		keydown: function( event ) {=0A=
			var preventDefault =3D true;=0A=
			switch ( event.keyCode ) {=0A=
				case $.ui.keyCode.TAB:=0A=
				case $.ui.keyCode.ESCAPE:=0A=
					this.close( event );=0A=
					preventDefault =3D false;=0A=
					break;=0A=
				case $.ui.keyCode.ENTER:=0A=
					if ( this.isOpen ) {=0A=
						this._selectFocusedItem( event );=0A=
					}=0A=
					break;=0A=
				case $.ui.keyCode.UP:=0A=
					if ( event.altKey ) {=0A=
						this._toggle( event );=0A=
					} else {=0A=
						this._move( "prev", event );=0A=
					}=0A=
					break;=0A=
				case $.ui.keyCode.DOWN:=0A=
					if ( event.altKey ) {=0A=
						this._toggle( event );=0A=
					} else {=0A=
						this._move( "next", event );=0A=
					}=0A=
					break;=0A=
				case $.ui.keyCode.SPACE:=0A=
					if ( this.isOpen ) {=0A=
						this._selectFocusedItem( event );=0A=
					} else {=0A=
						this._toggle( event );=0A=
					}=0A=
					break;=0A=
				case $.ui.keyCode.LEFT:=0A=
					this._move( "prev", event );=0A=
					break;=0A=
				case $.ui.keyCode.RIGHT:=0A=
					this._move( "next", event );=0A=
					break;=0A=
				case $.ui.keyCode.HOME:=0A=
				case $.ui.keyCode.PAGE_UP:=0A=
					this._move( "first", event );=0A=
					break;=0A=
				case $.ui.keyCode.END:=0A=
				case $.ui.keyCode.PAGE_DOWN:=0A=
					this._move( "last", event );=0A=
					break;=0A=
				default:=0A=
					this.menu.trigger( event );=0A=
					preventDefault =3D false;=0A=
			}=0A=
=0A=
			if ( preventDefault ) {=0A=
				event.preventDefault();=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	_selectFocusedItem: function( event ) {=0A=
		var item =3D this.menuItems.eq( this.focusIndex );=0A=
		if ( !item.hasClass( "ui-state-disabled" ) ) {=0A=
			this._select( item.data( "ui-selectmenu-item" ), event );=0A=
		}=0A=
	},=0A=
=0A=
	_select: function( item, event ) {=0A=
		var oldIndex =3D this.element[ 0 ].selectedIndex;=0A=
=0A=
		// Change native select element=0A=
		this.element[ 0 ].selectedIndex =3D item.index;=0A=
		this._setText( this.buttonText, item.label );=0A=
		this._setAria( item );=0A=
		this._trigger( "select", event, { item: item } );=0A=
=0A=
		if ( item.index !=3D=3D oldIndex ) {=0A=
			this._trigger( "change", event, { item: item } );=0A=
		}=0A=
=0A=
		this.close( event );=0A=
	},=0A=
=0A=
	_setAria: function( item ) {=0A=
		var id =3D this.menuItems.eq( item.index ).attr( "id" );=0A=
=0A=
		this.button.attr({=0A=
			"aria-labelledby": id,=0A=
			"aria-activedescendant": id=0A=
		});=0A=
		this.menu.attr( "aria-activedescendant", id );=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		if ( key =3D=3D=3D "icons" ) {=0A=
			this.button.find( "span.ui-icon" )=0A=
				.removeClass( this.options.icons.button )=0A=
				.addClass( value.button );=0A=
		}=0A=
=0A=
		this._super( key, value );=0A=
=0A=
		if ( key =3D=3D=3D "appendTo" ) {=0A=
			this.menuWrap.appendTo( this._appendTo() );=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			this.menuInstance.option( "disabled", value );=0A=
			this.button=0A=
				.toggleClass( "ui-state-disabled", value )=0A=
				.attr( "aria-disabled", value );=0A=
=0A=
			this.element.prop( "disabled", value );=0A=
			if ( value ) {=0A=
				this.button.attr( "tabindex", -1 );=0A=
				this.close();=0A=
			} else {=0A=
				this.button.attr( "tabindex", 0 );=0A=
			}=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "width" ) {=0A=
			this._resizeButton();=0A=
		}=0A=
	},=0A=
=0A=
	_appendTo: function() {=0A=
		var element =3D this.options.appendTo;=0A=
=0A=
		if ( element ) {=0A=
			element =3D element.jquery || element.nodeType ?=0A=
				$( element ) :=0A=
				this.document.find( element ).eq( 0 );=0A=
		}=0A=
=0A=
		if ( !element || !element[ 0 ] ) {=0A=
			element =3D this.element.closest( ".ui-front" );=0A=
		}=0A=
=0A=
		if ( !element.length ) {=0A=
			element =3D this.document[ 0 ].body;=0A=
		}=0A=
=0A=
		return element;=0A=
	},=0A=
=0A=
	_toggleAttr: function() {=0A=
		this.button=0A=
			.toggleClass( "ui-corner-top", this.isOpen )=0A=
			.toggleClass( "ui-corner-all", !this.isOpen )=0A=
			.attr( "aria-expanded", this.isOpen );=0A=
		this.menuWrap.toggleClass( "ui-selectmenu-open", this.isOpen );=0A=
		this.menu.attr( "aria-hidden", !this.isOpen );=0A=
	},=0A=
=0A=
	_resizeButton: function() {=0A=
		var width =3D this.options.width;=0A=
=0A=
		if ( !width ) {=0A=
			width =3D this.element.show().outerWidth();=0A=
			this.element.hide();=0A=
		}=0A=
=0A=
		this.button.outerWidth( width );=0A=
	},=0A=
=0A=
	_resizeMenu: function() {=0A=
		this.menu.outerWidth( Math.max(=0A=
			this.button.outerWidth(),=0A=
=0A=
			// support: IE10=0A=
			// IE10 wraps long text (possibly a rounding bug)=0A=
			// so we add 1px to avoid the wrapping=0A=
			this.menu.width( "" ).outerWidth() + 1=0A=
		) );=0A=
	},=0A=
=0A=
	_getCreateOptions: function() {=0A=
		return { disabled: this.element.prop( "disabled" ) };=0A=
	},=0A=
=0A=
	_parseOptions: function( options ) {=0A=
		var data =3D [];=0A=
		options.each(function( index, item ) {=0A=
			var option =3D $( item ),=0A=
				optgroup =3D option.parent( "optgroup" );=0A=
			data.push({=0A=
				element: option,=0A=
				index: index,=0A=
				value: option.attr( "value" ),=0A=
				label: option.text(),=0A=
				optgroup: optgroup.attr( "label" ) || "",=0A=
				disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )=0A=
			});=0A=
		});=0A=
		this.items =3D data;=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		this.menuWrap.remove();=0A=
		this.button.remove();=0A=
		this.element.show();=0A=
		this.element.removeUniqueId();=0A=
		this.label.attr( "for", this.ids.element );=0A=
	}=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Slider 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/slider/=0A=
 */=0A=
=0A=
=0A=
var slider =3D $.widget( "ui.slider", $.ui.mouse, {=0A=
	version: "1.11.1",=0A=
	widgetEventPrefix: "slide",=0A=
=0A=
	options: {=0A=
		animate: false,=0A=
		distance: 0,=0A=
		max: 100,=0A=
		min: 0,=0A=
		orientation: "horizontal",=0A=
		range: false,=0A=
		step: 1,=0A=
		value: 0,=0A=
		values: null,=0A=
=0A=
		// callbacks=0A=
		change: null,=0A=
		slide: null,=0A=
		start: null,=0A=
		stop: null=0A=
	},=0A=
=0A=
	// number of pages in a slider=0A=
	// (how many times can you page up/down to go through the whole range)=0A=
	numPages: 5,=0A=
=0A=
	_create: function() {=0A=
		this._keySliding =3D false;=0A=
		this._mouseSliding =3D false;=0A=
		this._animateOff =3D true;=0A=
		this._handleIndex =3D null;=0A=
		this._detectOrientation();=0A=
		this._mouseInit();=0A=
=0A=
		this.element=0A=
			.addClass( "ui-slider" +=0A=
				" ui-slider-" + this.orientation +=0A=
				" ui-widget" +=0A=
				" ui-widget-content" +=0A=
				" ui-corner-all");=0A=
=0A=
		this._refresh();=0A=
		this._setOption( "disabled", this.options.disabled );=0A=
=0A=
		this._animateOff =3D false;=0A=
	},=0A=
=0A=
	_refresh: function() {=0A=
		this._createRange();=0A=
		this._createHandles();=0A=
		this._setupEvents();=0A=
		this._refreshValue();=0A=
	},=0A=
=0A=
	_createHandles: function() {=0A=
		var i, handleCount,=0A=
			options =3D this.options,=0A=
			existingHandles =3D this.element.find( ".ui-slider-handle" =
).addClass( "ui-state-default ui-corner-all" ),=0A=
			handle =3D "<span class=3D'ui-slider-handle ui-state-default =
ui-corner-all' tabindex=3D'0'></span>",=0A=
			handles =3D [];=0A=
=0A=
		handleCount =3D ( options.values && options.values.length ) || 1;=0A=
=0A=
		if ( existingHandles.length > handleCount ) {=0A=
			existingHandles.slice( handleCount ).remove();=0A=
			existingHandles =3D existingHandles.slice( 0, handleCount );=0A=
		}=0A=
=0A=
		for ( i =3D existingHandles.length; i < handleCount; i++ ) {=0A=
			handles.push( handle );=0A=
		}=0A=
=0A=
		this.handles =3D existingHandles.add( $( handles.join( "" ) =
).appendTo( this.element ) );=0A=
=0A=
		this.handle =3D this.handles.eq( 0 );=0A=
=0A=
		this.handles.each(function( i ) {=0A=
			$( this ).data( "ui-slider-handle-index", i );=0A=
		});=0A=
	},=0A=
=0A=
	_createRange: function() {=0A=
		var options =3D this.options,=0A=
			classes =3D "";=0A=
=0A=
		if ( options.range ) {=0A=
			if ( options.range =3D=3D=3D true ) {=0A=
				if ( !options.values ) {=0A=
					options.values =3D [ this._valueMin(), this._valueMin() ];=0A=
				} else if ( options.values.length && options.values.length !=3D=3D 2 =
) {=0A=
					options.values =3D [ options.values[0], options.values[0] ];=0A=
				} else if ( $.isArray( options.values ) ) {=0A=
					options.values =3D options.values.slice(0);=0A=
				}=0A=
			}=0A=
=0A=
			if ( !this.range || !this.range.length ) {=0A=
				this.range =3D $( "<div></div>" )=0A=
					.appendTo( this.element );=0A=
=0A=
				classes =3D "ui-slider-range" +=0A=
				// note: this isn't the most fittingly semantic framework class for =
this element,=0A=
				// but worked best visually with a variety of themes=0A=
				" ui-widget-header ui-corner-all";=0A=
			} else {=0A=
				this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )=0A=
					// Handle range switching from true to min/max=0A=
					.css({=0A=
						"left": "",=0A=
						"bottom": ""=0A=
					});=0A=
			}=0A=
=0A=
			this.range.addClass( classes +=0A=
				( ( options.range =3D=3D=3D "min" || options.range =3D=3D=3D "max" ) =
? " ui-slider-range-" + options.range : "" ) );=0A=
		} else {=0A=
			if ( this.range ) {=0A=
				this.range.remove();=0A=
			}=0A=
			this.range =3D null;=0A=
		}=0A=
	},=0A=
=0A=
	_setupEvents: function() {=0A=
		this._off( this.handles );=0A=
		this._on( this.handles, this._handleEvents );=0A=
		this._hoverable( this.handles );=0A=
		this._focusable( this.handles );=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		this.handles.remove();=0A=
		if ( this.range ) {=0A=
			this.range.remove();=0A=
		}=0A=
=0A=
		this.element=0A=
			.removeClass( "ui-slider" +=0A=
				" ui-slider-horizontal" +=0A=
				" ui-slider-vertical" +=0A=
				" ui-widget" +=0A=
				" ui-widget-content" +=0A=
				" ui-corner-all" );=0A=
=0A=
		this._mouseDestroy();=0A=
	},=0A=
=0A=
	_mouseCapture: function( event ) {=0A=
		var position, normValue, distance, closestHandle, index, allowed, =
offset, mouseOverHandle,=0A=
			that =3D this,=0A=
			o =3D this.options;=0A=
=0A=
		if ( o.disabled ) {=0A=
			return false;=0A=
		}=0A=
=0A=
		this.elementSize =3D {=0A=
			width: this.element.outerWidth(),=0A=
			height: this.element.outerHeight()=0A=
		};=0A=
		this.elementOffset =3D this.element.offset();=0A=
=0A=
		position =3D { x: event.pageX, y: event.pageY };=0A=
		normValue =3D this._normValueFromMouse( position );=0A=
		distance =3D this._valueMax() - this._valueMin() + 1;=0A=
		this.handles.each(function( i ) {=0A=
			var thisDistance =3D Math.abs( normValue - that.values(i) );=0A=
			if (( distance > thisDistance ) ||=0A=
				( distance =3D=3D=3D thisDistance &&=0A=
					(i =3D=3D=3D that._lastChangedValue || that.values(i) =3D=3D=3D =
o.min ))) {=0A=
				distance =3D thisDistance;=0A=
				closestHandle =3D $( this );=0A=
				index =3D i;=0A=
			}=0A=
		});=0A=
=0A=
		allowed =3D this._start( event, index );=0A=
		if ( allowed =3D=3D=3D false ) {=0A=
			return false;=0A=
		}=0A=
		this._mouseSliding =3D true;=0A=
=0A=
		this._handleIndex =3D index;=0A=
=0A=
		closestHandle=0A=
			.addClass( "ui-state-active" )=0A=
			.focus();=0A=
=0A=
		offset =3D closestHandle.offset();=0A=
		mouseOverHandle =3D !$( event.target ).parents().addBack().is( =
".ui-slider-handle" );=0A=
		this._clickOffset =3D mouseOverHandle ? { left: 0, top: 0 } : {=0A=
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),=0A=
			top: event.pageY - offset.top -=0A=
				( closestHandle.height() / 2 ) -=0A=
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -=0A=
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +=0A=
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)=0A=
		};=0A=
=0A=
		if ( !this.handles.hasClass( "ui-state-hover" ) ) {=0A=
			this._slide( event, index, normValue );=0A=
		}=0A=
		this._animateOff =3D true;=0A=
		return true;=0A=
	},=0A=
=0A=
	_mouseStart: function() {=0A=
		return true;=0A=
	},=0A=
=0A=
	_mouseDrag: function( event ) {=0A=
		var position =3D { x: event.pageX, y: event.pageY },=0A=
			normValue =3D this._normValueFromMouse( position );=0A=
=0A=
		this._slide( event, this._handleIndex, normValue );=0A=
=0A=
		return false;=0A=
	},=0A=
=0A=
	_mouseStop: function( event ) {=0A=
		this.handles.removeClass( "ui-state-active" );=0A=
		this._mouseSliding =3D false;=0A=
=0A=
		this._stop( event, this._handleIndex );=0A=
		this._change( event, this._handleIndex );=0A=
=0A=
		this._handleIndex =3D null;=0A=
		this._clickOffset =3D null;=0A=
		this._animateOff =3D false;=0A=
=0A=
		return false;=0A=
	},=0A=
=0A=
	_detectOrientation: function() {=0A=
		this.orientation =3D ( this.options.orientation =3D=3D=3D "vertical" ) =
? "vertical" : "horizontal";=0A=
	},=0A=
=0A=
	_normValueFromMouse: function( position ) {=0A=
		var pixelTotal,=0A=
			pixelMouse,=0A=
			percentMouse,=0A=
			valueTotal,=0A=
			valueMouse;=0A=
=0A=
		if ( this.orientation =3D=3D=3D "horizontal" ) {=0A=
			pixelTotal =3D this.elementSize.width;=0A=
			pixelMouse =3D position.x - this.elementOffset.left - ( =
this._clickOffset ? this._clickOffset.left : 0 );=0A=
		} else {=0A=
			pixelTotal =3D this.elementSize.height;=0A=
			pixelMouse =3D position.y - this.elementOffset.top - ( =
this._clickOffset ? this._clickOffset.top : 0 );=0A=
		}=0A=
=0A=
		percentMouse =3D ( pixelMouse / pixelTotal );=0A=
		if ( percentMouse > 1 ) {=0A=
			percentMouse =3D 1;=0A=
		}=0A=
		if ( percentMouse < 0 ) {=0A=
			percentMouse =3D 0;=0A=
		}=0A=
		if ( this.orientation =3D=3D=3D "vertical" ) {=0A=
			percentMouse =3D 1 - percentMouse;=0A=
		}=0A=
=0A=
		valueTotal =3D this._valueMax() - this._valueMin();=0A=
		valueMouse =3D this._valueMin() + percentMouse * valueTotal;=0A=
=0A=
		return this._trimAlignValue( valueMouse );=0A=
	},=0A=
=0A=
	_start: function( event, index ) {=0A=
		var uiHash =3D {=0A=
			handle: this.handles[ index ],=0A=
			value: this.value()=0A=
		};=0A=
		if ( this.options.values && this.options.values.length ) {=0A=
			uiHash.value =3D this.values( index );=0A=
			uiHash.values =3D this.values();=0A=
		}=0A=
		return this._trigger( "start", event, uiHash );=0A=
	},=0A=
=0A=
	_slide: function( event, index, newVal ) {=0A=
		var otherVal,=0A=
			newValues,=0A=
			allowed;=0A=
=0A=
		if ( this.options.values && this.options.values.length ) {=0A=
			otherVal =3D this.values( index ? 0 : 1 );=0A=
=0A=
			if ( ( this.options.values.length =3D=3D=3D 2 && this.options.range =
=3D=3D=3D true ) &&=0A=
					( ( index =3D=3D=3D 0 && newVal > otherVal) || ( index =3D=3D=3D 1 =
&& newVal < otherVal ) )=0A=
				) {=0A=
				newVal =3D otherVal;=0A=
			}=0A=
=0A=
			if ( newVal !=3D=3D this.values( index ) ) {=0A=
				newValues =3D this.values();=0A=
				newValues[ index ] =3D newVal;=0A=
				// A slide can be canceled by returning false from the slide callback=0A=
				allowed =3D this._trigger( "slide", event, {=0A=
					handle: this.handles[ index ],=0A=
					value: newVal,=0A=
					values: newValues=0A=
				} );=0A=
				otherVal =3D this.values( index ? 0 : 1 );=0A=
				if ( allowed !=3D=3D false ) {=0A=
					this.values( index, newVal );=0A=
				}=0A=
			}=0A=
		} else {=0A=
			if ( newVal !=3D=3D this.value() ) {=0A=
				// A slide can be canceled by returning false from the slide callback=0A=
				allowed =3D this._trigger( "slide", event, {=0A=
					handle: this.handles[ index ],=0A=
					value: newVal=0A=
				} );=0A=
				if ( allowed !=3D=3D false ) {=0A=
					this.value( newVal );=0A=
				}=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	_stop: function( event, index ) {=0A=
		var uiHash =3D {=0A=
			handle: this.handles[ index ],=0A=
			value: this.value()=0A=
		};=0A=
		if ( this.options.values && this.options.values.length ) {=0A=
			uiHash.value =3D this.values( index );=0A=
			uiHash.values =3D this.values();=0A=
		}=0A=
=0A=
		this._trigger( "stop", event, uiHash );=0A=
	},=0A=
=0A=
	_change: function( event, index ) {=0A=
		if ( !this._keySliding && !this._mouseSliding ) {=0A=
			var uiHash =3D {=0A=
				handle: this.handles[ index ],=0A=
				value: this.value()=0A=
			};=0A=
			if ( this.options.values && this.options.values.length ) {=0A=
				uiHash.value =3D this.values( index );=0A=
				uiHash.values =3D this.values();=0A=
			}=0A=
=0A=
			//store the last changed value index for reference when handles =
overlap=0A=
			this._lastChangedValue =3D index;=0A=
=0A=
			this._trigger( "change", event, uiHash );=0A=
		}=0A=
	},=0A=
=0A=
	value: function( newValue ) {=0A=
		if ( arguments.length ) {=0A=
			this.options.value =3D this._trimAlignValue( newValue );=0A=
			this._refreshValue();=0A=
			this._change( null, 0 );=0A=
			return;=0A=
		}=0A=
=0A=
		return this._value();=0A=
	},=0A=
=0A=
	values: function( index, newValue ) {=0A=
		var vals,=0A=
			newValues,=0A=
			i;=0A=
=0A=
		if ( arguments.length > 1 ) {=0A=
			this.options.values[ index ] =3D this._trimAlignValue( newValue );=0A=
			this._refreshValue();=0A=
			this._change( null, index );=0A=
			return;=0A=
		}=0A=
=0A=
		if ( arguments.length ) {=0A=
			if ( $.isArray( arguments[ 0 ] ) ) {=0A=
				vals =3D this.options.values;=0A=
				newValues =3D arguments[ 0 ];=0A=
				for ( i =3D 0; i < vals.length; i +=3D 1 ) {=0A=
					vals[ i ] =3D this._trimAlignValue( newValues[ i ] );=0A=
					this._change( null, i );=0A=
				}=0A=
				this._refreshValue();=0A=
			} else {=0A=
				if ( this.options.values && this.options.values.length ) {=0A=
					return this._values( index );=0A=
				} else {=0A=
					return this.value();=0A=
				}=0A=
			}=0A=
		} else {=0A=
			return this._values();=0A=
		}=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		var i,=0A=
			valsLength =3D 0;=0A=
=0A=
		if ( key =3D=3D=3D "range" && this.options.range =3D=3D=3D true ) {=0A=
			if ( value =3D=3D=3D "min" ) {=0A=
				this.options.value =3D this._values( 0 );=0A=
				this.options.values =3D null;=0A=
			} else if ( value =3D=3D=3D "max" ) {=0A=
				this.options.value =3D this._values( this.options.values.length - 1 =
);=0A=
				this.options.values =3D null;=0A=
			}=0A=
		}=0A=
=0A=
		if ( $.isArray( this.options.values ) ) {=0A=
			valsLength =3D this.options.values.length;=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			this.element.toggleClass( "ui-state-disabled", !!value );=0A=
		}=0A=
=0A=
		this._super( key, value );=0A=
=0A=
		switch ( key ) {=0A=
			case "orientation":=0A=
				this._detectOrientation();=0A=
				this.element=0A=
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )=0A=
					.addClass( "ui-slider-" + this.orientation );=0A=
				this._refreshValue();=0A=
=0A=
				// Reset positioning from previous orientation=0A=
				this.handles.css( value =3D=3D=3D "horizontal" ? "bottom" : "left", =
"" );=0A=
				break;=0A=
			case "value":=0A=
				this._animateOff =3D true;=0A=
				this._refreshValue();=0A=
				this._change( null, 0 );=0A=
				this._animateOff =3D false;=0A=
				break;=0A=
			case "values":=0A=
				this._animateOff =3D true;=0A=
				this._refreshValue();=0A=
				for ( i =3D 0; i < valsLength; i +=3D 1 ) {=0A=
					this._change( null, i );=0A=
				}=0A=
				this._animateOff =3D false;=0A=
				break;=0A=
			case "min":=0A=
			case "max":=0A=
				this._animateOff =3D true;=0A=
				this._refreshValue();=0A=
				this._animateOff =3D false;=0A=
				break;=0A=
			case "range":=0A=
				this._animateOff =3D true;=0A=
				this._refresh();=0A=
				this._animateOff =3D false;=0A=
				break;=0A=
		}=0A=
	},=0A=
=0A=
	//internal value getter=0A=
	// _value() returns value trimmed by min and max, aligned by step=0A=
	_value: function() {=0A=
		var val =3D this.options.value;=0A=
		val =3D this._trimAlignValue( val );=0A=
=0A=
		return val;=0A=
	},=0A=
=0A=
	//internal values getter=0A=
	// _values() returns array of values trimmed by min and max, aligned by =
step=0A=
	// _values( index ) returns single value trimmed by min and max, =
aligned by step=0A=
	_values: function( index ) {=0A=
		var val,=0A=
			vals,=0A=
			i;=0A=
=0A=
		if ( arguments.length ) {=0A=
			val =3D this.options.values[ index ];=0A=
			val =3D this._trimAlignValue( val );=0A=
=0A=
			return val;=0A=
		} else if ( this.options.values && this.options.values.length ) {=0A=
			// .slice() creates a copy of the array=0A=
			// this copy gets trimmed by min and max and then returned=0A=
			vals =3D this.options.values.slice();=0A=
			for ( i =3D 0; i < vals.length; i+=3D 1) {=0A=
				vals[ i ] =3D this._trimAlignValue( vals[ i ] );=0A=
			}=0A=
=0A=
			return vals;=0A=
		} else {=0A=
			return [];=0A=
		}=0A=
	},=0A=
=0A=
	// returns the step-aligned value that val is closest to, between =
(inclusive) min and max=0A=
	_trimAlignValue: function( val ) {=0A=
		if ( val <=3D this._valueMin() ) {=0A=
			return this._valueMin();=0A=
		}=0A=
		if ( val >=3D this._valueMax() ) {=0A=
			return this._valueMax();=0A=
		}=0A=
		var step =3D ( this.options.step > 0 ) ? this.options.step : 1,=0A=
			valModStep =3D (val - this._valueMin()) % step,=0A=
			alignValue =3D val - valModStep;=0A=
=0A=
		if ( Math.abs(valModStep) * 2 >=3D step ) {=0A=
			alignValue +=3D ( valModStep > 0 ) ? step : ( -step );=0A=
		}=0A=
=0A=
		// Since JavaScript has problems with large floats, round=0A=
		// the final value to 5 digits after the decimal point (see #4124)=0A=
		return parseFloat( alignValue.toFixed(5) );=0A=
	},=0A=
=0A=
	_valueMin: function() {=0A=
		return this.options.min;=0A=
	},=0A=
=0A=
	_valueMax: function() {=0A=
		return this.options.max;=0A=
	},=0A=
=0A=
	_refreshValue: function() {=0A=
		var lastValPercent, valPercent, value, valueMin, valueMax,=0A=
			oRange =3D this.options.range,=0A=
			o =3D this.options,=0A=
			that =3D this,=0A=
			animate =3D ( !this._animateOff ) ? o.animate : false,=0A=
			_set =3D {};=0A=
=0A=
		if ( this.options.values && this.options.values.length ) {=0A=
			this.handles.each(function( i ) {=0A=
				valPercent =3D ( that.values(i) - that._valueMin() ) / ( =
that._valueMax() - that._valueMin() ) * 100;=0A=
				_set[ that.orientation =3D=3D=3D "horizontal" ? "left" : "bottom" ] =
=3D valPercent + "%";=0A=
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, =
o.animate );=0A=
				if ( that.options.range =3D=3D=3D true ) {=0A=
					if ( that.orientation =3D=3D=3D "horizontal" ) {=0A=
						if ( i =3D=3D=3D 0 ) {=0A=
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: =
valPercent + "%" }, o.animate );=0A=
						}=0A=
						if ( i =3D=3D=3D 1 ) {=0A=
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent =
- lastValPercent ) + "%" }, { queue: false, duration: o.animate } );=0A=
						}=0A=
					} else {=0A=
						if ( i =3D=3D=3D 0 ) {=0A=
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: =
( valPercent ) + "%" }, o.animate );=0A=
						}=0A=
						if ( i =3D=3D=3D 1 ) {=0A=
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent =
- lastValPercent ) + "%" }, { queue: false, duration: o.animate } );=0A=
						}=0A=
					}=0A=
				}=0A=
				lastValPercent =3D valPercent;=0A=
			});=0A=
		} else {=0A=
			value =3D this.value();=0A=
			valueMin =3D this._valueMin();=0A=
			valueMax =3D this._valueMax();=0A=
			valPercent =3D ( valueMax !=3D=3D valueMin ) ?=0A=
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :=0A=
					0;=0A=
			_set[ this.orientation =3D=3D=3D "horizontal" ? "left" : "bottom" ] =
=3D valPercent + "%";=0A=
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, =
o.animate );=0A=
=0A=
			if ( oRange =3D=3D=3D "min" && this.orientation =3D=3D=3D =
"horizontal" ) {=0A=
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: =
valPercent + "%" }, o.animate );=0A=
			}=0A=
			if ( oRange =3D=3D=3D "max" && this.orientation =3D=3D=3D =
"horizontal" ) {=0A=
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - =
valPercent ) + "%" }, { queue: false, duration: o.animate } );=0A=
			}=0A=
			if ( oRange =3D=3D=3D "min" && this.orientation =3D=3D=3D "vertical" =
) {=0A=
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: =
valPercent + "%" }, o.animate );=0A=
			}=0A=
			if ( oRange =3D=3D=3D "max" && this.orientation =3D=3D=3D "vertical" =
) {=0A=
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - =
valPercent ) + "%" }, { queue: false, duration: o.animate } );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	_handleEvents: {=0A=
		keydown: function( event ) {=0A=
			var allowed, curVal, newVal, step,=0A=
				index =3D $( event.target ).data( "ui-slider-handle-index" );=0A=
=0A=
			switch ( event.keyCode ) {=0A=
				case $.ui.keyCode.HOME:=0A=
				case $.ui.keyCode.END:=0A=
				case $.ui.keyCode.PAGE_UP:=0A=
				case $.ui.keyCode.PAGE_DOWN:=0A=
				case $.ui.keyCode.UP:=0A=
				case $.ui.keyCode.RIGHT:=0A=
				case $.ui.keyCode.DOWN:=0A=
				case $.ui.keyCode.LEFT:=0A=
					event.preventDefault();=0A=
					if ( !this._keySliding ) {=0A=
						this._keySliding =3D true;=0A=
						$( event.target ).addClass( "ui-state-active" );=0A=
						allowed =3D this._start( event, index );=0A=
						if ( allowed =3D=3D=3D false ) {=0A=
							return;=0A=
						}=0A=
					}=0A=
					break;=0A=
			}=0A=
=0A=
			step =3D this.options.step;=0A=
			if ( this.options.values && this.options.values.length ) {=0A=
				curVal =3D newVal =3D this.values( index );=0A=
			} else {=0A=
				curVal =3D newVal =3D this.value();=0A=
			}=0A=
=0A=
			switch ( event.keyCode ) {=0A=
				case $.ui.keyCode.HOME:=0A=
					newVal =3D this._valueMin();=0A=
					break;=0A=
				case $.ui.keyCode.END:=0A=
					newVal =3D this._valueMax();=0A=
					break;=0A=
				case $.ui.keyCode.PAGE_UP:=0A=
					newVal =3D this._trimAlignValue(=0A=
						curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages =
)=0A=
					);=0A=
					break;=0A=
				case $.ui.keyCode.PAGE_DOWN:=0A=
					newVal =3D this._trimAlignValue(=0A=
						curVal - ( (this._valueMax() - this._valueMin()) / this.numPages ) =
);=0A=
					break;=0A=
				case $.ui.keyCode.UP:=0A=
				case $.ui.keyCode.RIGHT:=0A=
					if ( curVal =3D=3D=3D this._valueMax() ) {=0A=
						return;=0A=
					}=0A=
					newVal =3D this._trimAlignValue( curVal + step );=0A=
					break;=0A=
				case $.ui.keyCode.DOWN:=0A=
				case $.ui.keyCode.LEFT:=0A=
					if ( curVal =3D=3D=3D this._valueMin() ) {=0A=
						return;=0A=
					}=0A=
					newVal =3D this._trimAlignValue( curVal - step );=0A=
					break;=0A=
			}=0A=
=0A=
			this._slide( event, index, newVal );=0A=
		},=0A=
		keyup: function( event ) {=0A=
			var index =3D $( event.target ).data( "ui-slider-handle-index" );=0A=
=0A=
			if ( this._keySliding ) {=0A=
				this._keySliding =3D false;=0A=
				this._stop( event, index );=0A=
				this._change( event, index );=0A=
				$( event.target ).removeClass( "ui-state-active" );=0A=
			}=0A=
		}=0A=
	}=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Spinner 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/spinner/=0A=
 */=0A=
=0A=
=0A=
function spinner_modifier( fn ) {=0A=
	return function() {=0A=
		var previous =3D this.element.val();=0A=
		fn.apply( this, arguments );=0A=
		this._refresh();=0A=
		if ( previous !=3D=3D this.element.val() ) {=0A=
			this._trigger( "change" );=0A=
		}=0A=
	};=0A=
}=0A=
=0A=
var spinner =3D $.widget( "ui.spinner", {=0A=
	version: "1.11.1",=0A=
	defaultElement: "<input>",=0A=
	widgetEventPrefix: "spin",=0A=
	options: {=0A=
		culture: null,=0A=
		icons: {=0A=
			down: "ui-icon-triangle-1-s",=0A=
			up: "ui-icon-triangle-1-n"=0A=
		},=0A=
		incremental: true,=0A=
		max: null,=0A=
		min: null,=0A=
		numberFormat: null,=0A=
		page: 10,=0A=
		step: 1,=0A=
=0A=
		change: null,=0A=
		spin: null,=0A=
		start: null,=0A=
		stop: null=0A=
	},=0A=
=0A=
	_create: function() {=0A=
		// handle string values that need to be parsed=0A=
		this._setOption( "max", this.options.max );=0A=
		this._setOption( "min", this.options.min );=0A=
		this._setOption( "step", this.options.step );=0A=
=0A=
		// Only format if there is a value, prevents the field from being =
marked=0A=
		// as invalid in Firefox, see #9573.=0A=
		if ( this.value() !=3D=3D "" ) {=0A=
			// Format the value, but don't constrain.=0A=
			this._value( this.element.val(), true );=0A=
		}=0A=
=0A=
		this._draw();=0A=
		this._on( this._events );=0A=
		this._refresh();=0A=
=0A=
		// turning off autocomplete prevents the browser from remembering the=0A=
		// value when navigating through history, so we re-enable autocomplete=0A=
		// if the page is unloaded before the widget is destroyed. #7790=0A=
		this._on( this.window, {=0A=
			beforeunload: function() {=0A=
				this.element.removeAttr( "autocomplete" );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	_getCreateOptions: function() {=0A=
		var options =3D {},=0A=
			element =3D this.element;=0A=
=0A=
		$.each( [ "min", "max", "step" ], function( i, option ) {=0A=
			var value =3D element.attr( option );=0A=
			if ( value !=3D=3D undefined && value.length ) {=0A=
				options[ option ] =3D value;=0A=
			}=0A=
		});=0A=
=0A=
		return options;=0A=
	},=0A=
=0A=
	_events: {=0A=
		keydown: function( event ) {=0A=
			if ( this._start( event ) && this._keydown( event ) ) {=0A=
				event.preventDefault();=0A=
			}=0A=
		},=0A=
		keyup: "_stop",=0A=
		focus: function() {=0A=
			this.previous =3D this.element.val();=0A=
		},=0A=
		blur: function( event ) {=0A=
			if ( this.cancelBlur ) {=0A=
				delete this.cancelBlur;=0A=
				return;=0A=
			}=0A=
=0A=
			this._stop();=0A=
			this._refresh();=0A=
			if ( this.previous !=3D=3D this.element.val() ) {=0A=
				this._trigger( "change", event );=0A=
			}=0A=
		},=0A=
		mousewheel: function( event, delta ) {=0A=
			if ( !delta ) {=0A=
				return;=0A=
			}=0A=
			if ( !this.spinning && !this._start( event ) ) {=0A=
				return false;=0A=
			}=0A=
=0A=
			this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );=0A=
			clearTimeout( this.mousewheelTimer );=0A=
			this.mousewheelTimer =3D this._delay(function() {=0A=
				if ( this.spinning ) {=0A=
					this._stop( event );=0A=
				}=0A=
			}, 100 );=0A=
			event.preventDefault();=0A=
		},=0A=
		"mousedown .ui-spinner-button": function( event ) {=0A=
			var previous;=0A=
=0A=
			// We never want the buttons to have focus; whenever the user is=0A=
			// interacting with the spinner, the focus should be on the input.=0A=
			// If the input is focused then this.previous is properly set from=0A=
			// when the input first received focus. If the input is not focused=0A=
			// then we need to set this.previous based on the value before =
spinning.=0A=
			previous =3D this.element[0] =3D=3D=3D this.document[0].activeElement =
?=0A=
				this.previous : this.element.val();=0A=
			function checkFocus() {=0A=
				var isActive =3D this.element[0] =3D=3D=3D =
this.document[0].activeElement;=0A=
				if ( !isActive ) {=0A=
					this.element.focus();=0A=
					this.previous =3D previous;=0A=
					// support: IE=0A=
					// IE sets focus asynchronously, so we need to check if focus=0A=
					// moved off of the input because the user clicked on the button.=0A=
					this._delay(function() {=0A=
						this.previous =3D previous;=0A=
					});=0A=
				}=0A=
			}=0A=
=0A=
			// ensure focus is on (or stays on) the text field=0A=
			event.preventDefault();=0A=
			checkFocus.call( this );=0A=
=0A=
			// support: IE=0A=
			// IE doesn't prevent moving focus even with event.preventDefault()=0A=
			// so we set a flag to know when we should ignore the blur event=0A=
			// and check (again) if focus moved off of the input.=0A=
			this.cancelBlur =3D true;=0A=
			this._delay(function() {=0A=
				delete this.cancelBlur;=0A=
				checkFocus.call( this );=0A=
			});=0A=
=0A=
			if ( this._start( event ) =3D=3D=3D false ) {=0A=
				return;=0A=
			}=0A=
=0A=
			this._repeat( null, $( event.currentTarget ).hasClass( =
"ui-spinner-up" ) ? 1 : -1, event );=0A=
		},=0A=
		"mouseup .ui-spinner-button": "_stop",=0A=
		"mouseenter .ui-spinner-button": function( event ) {=0A=
			// button will add ui-state-active if mouse was down while mouseleave =
and kept down=0A=
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {=0A=
				return;=0A=
			}=0A=
=0A=
			if ( this._start( event ) =3D=3D=3D false ) {=0A=
				return false;=0A=
			}=0A=
			this._repeat( null, $( event.currentTarget ).hasClass( =
"ui-spinner-up" ) ? 1 : -1, event );=0A=
		},=0A=
		// TODO: do we really want to consider this a stop?=0A=
		// shouldn't we just stop the repeater and wait until mouseup before=0A=
		// we trigger the stop event?=0A=
		"mouseleave .ui-spinner-button": "_stop"=0A=
	},=0A=
=0A=
	_draw: function() {=0A=
		var uiSpinner =3D this.uiSpinner =3D this.element=0A=
			.addClass( "ui-spinner-input" )=0A=
			.attr( "autocomplete", "off" )=0A=
			.wrap( this._uiSpinnerHtml() )=0A=
			.parent()=0A=
				// add buttons=0A=
				.append( this._buttonHtml() );=0A=
=0A=
		this.element.attr( "role", "spinbutton" );=0A=
=0A=
		// button bindings=0A=
		this.buttons =3D uiSpinner.find( ".ui-spinner-button" )=0A=
			.attr( "tabIndex", -1 )=0A=
			.button()=0A=
			.removeClass( "ui-corner-all" );=0A=
=0A=
		// IE 6 doesn't understand height: 50% for the buttons=0A=
		// unless the wrapper has an explicit height=0A=
		if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&=0A=
				uiSpinner.height() > 0 ) {=0A=
			uiSpinner.height( uiSpinner.height() );=0A=
		}=0A=
=0A=
		// disable spinner if element was already disabled=0A=
		if ( this.options.disabled ) {=0A=
			this.disable();=0A=
		}=0A=
	},=0A=
=0A=
	_keydown: function( event ) {=0A=
		var options =3D this.options,=0A=
			keyCode =3D $.ui.keyCode;=0A=
=0A=
		switch ( event.keyCode ) {=0A=
		case keyCode.UP:=0A=
			this._repeat( null, 1, event );=0A=
			return true;=0A=
		case keyCode.DOWN:=0A=
			this._repeat( null, -1, event );=0A=
			return true;=0A=
		case keyCode.PAGE_UP:=0A=
			this._repeat( null, options.page, event );=0A=
			return true;=0A=
		case keyCode.PAGE_DOWN:=0A=
			this._repeat( null, -options.page, event );=0A=
			return true;=0A=
		}=0A=
=0A=
		return false;=0A=
	},=0A=
=0A=
	_uiSpinnerHtml: function() {=0A=
		return "<span class=3D'ui-spinner ui-widget ui-widget-content =
ui-corner-all'></span>";=0A=
	},=0A=
=0A=
	_buttonHtml: function() {=0A=
		return "" +=0A=
			"<a class=3D'ui-spinner-button ui-spinner-up ui-corner-tr'>" +=0A=
				"<span class=3D'ui-icon " + this.options.icons.up + =
"'>&#9650;</span>" +=0A=
			"</a>" +=0A=
			"<a class=3D'ui-spinner-button ui-spinner-down ui-corner-br'>" +=0A=
				"<span class=3D'ui-icon " + this.options.icons.down + =
"'>&#9660;</span>" +=0A=
			"</a>";=0A=
	},=0A=
=0A=
	_start: function( event ) {=0A=
		if ( !this.spinning && this._trigger( "start", event ) =3D=3D=3D false =
) {=0A=
			return false;=0A=
		}=0A=
=0A=
		if ( !this.counter ) {=0A=
			this.counter =3D 1;=0A=
		}=0A=
		this.spinning =3D true;=0A=
		return true;=0A=
	},=0A=
=0A=
	_repeat: function( i, steps, event ) {=0A=
		i =3D i || 500;=0A=
=0A=
		clearTimeout( this.timer );=0A=
		this.timer =3D this._delay(function() {=0A=
			this._repeat( 40, steps, event );=0A=
		}, i );=0A=
=0A=
		this._spin( steps * this.options.step, event );=0A=
	},=0A=
=0A=
	_spin: function( step, event ) {=0A=
		var value =3D this.value() || 0;=0A=
=0A=
		if ( !this.counter ) {=0A=
			this.counter =3D 1;=0A=
		}=0A=
=0A=
		value =3D this._adjustValue( value + step * this._increment( =
this.counter ) );=0A=
=0A=
		if ( !this.spinning || this._trigger( "spin", event, { value: value } =
) !=3D=3D false) {=0A=
			this._value( value );=0A=
			this.counter++;=0A=
		}=0A=
	},=0A=
=0A=
	_increment: function( i ) {=0A=
		var incremental =3D this.options.incremental;=0A=
=0A=
		if ( incremental ) {=0A=
			return $.isFunction( incremental ) ?=0A=
				incremental( i ) :=0A=
				Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );=0A=
		}=0A=
=0A=
		return 1;=0A=
	},=0A=
=0A=
	_precision: function() {=0A=
		var precision =3D this._precisionOf( this.options.step );=0A=
		if ( this.options.min !=3D=3D null ) {=0A=
			precision =3D Math.max( precision, this._precisionOf( =
this.options.min ) );=0A=
		}=0A=
		return precision;=0A=
	},=0A=
=0A=
	_precisionOf: function( num ) {=0A=
		var str =3D num.toString(),=0A=
			decimal =3D str.indexOf( "." );=0A=
		return decimal =3D=3D=3D -1 ? 0 : str.length - decimal - 1;=0A=
	},=0A=
=0A=
	_adjustValue: function( value ) {=0A=
		var base, aboveMin,=0A=
			options =3D this.options;=0A=
=0A=
		// make sure we're at a valid step=0A=
		// - find out where we are relative to the base (min or 0)=0A=
		base =3D options.min !=3D=3D null ? options.min : 0;=0A=
		aboveMin =3D value - base;=0A=
		// - round to the nearest step=0A=
		aboveMin =3D Math.round(aboveMin / options.step) * options.step;=0A=
		// - rounding is based on 0, so adjust back to our base=0A=
		value =3D base + aboveMin;=0A=
=0A=
		// fix precision from bad JS floating point math=0A=
		value =3D parseFloat( value.toFixed( this._precision() ) );=0A=
=0A=
		// clamp the value=0A=
		if ( options.max !=3D=3D null && value > options.max) {=0A=
			return options.max;=0A=
		}=0A=
		if ( options.min !=3D=3D null && value < options.min ) {=0A=
			return options.min;=0A=
		}=0A=
=0A=
		return value;=0A=
	},=0A=
=0A=
	_stop: function( event ) {=0A=
		if ( !this.spinning ) {=0A=
			return;=0A=
		}=0A=
=0A=
		clearTimeout( this.timer );=0A=
		clearTimeout( this.mousewheelTimer );=0A=
		this.counter =3D 0;=0A=
		this.spinning =3D false;=0A=
		this._trigger( "stop", event );=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		if ( key =3D=3D=3D "culture" || key =3D=3D=3D "numberFormat" ) {=0A=
			var prevValue =3D this._parse( this.element.val() );=0A=
			this.options[ key ] =3D value;=0A=
			this.element.val( this._format( prevValue ) );=0A=
			return;=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "max" || key =3D=3D=3D "min" || key =3D=3D=3D =
"step" ) {=0A=
			if ( typeof value =3D=3D=3D "string" ) {=0A=
				value =3D this._parse( value );=0A=
			}=0A=
		}=0A=
		if ( key =3D=3D=3D "icons" ) {=0A=
			this.buttons.first().find( ".ui-icon" )=0A=
				.removeClass( this.options.icons.up )=0A=
				.addClass( value.up );=0A=
			this.buttons.last().find( ".ui-icon" )=0A=
				.removeClass( this.options.icons.down )=0A=
				.addClass( value.down );=0A=
		}=0A=
=0A=
		this._super( key, value );=0A=
=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			this.widget().toggleClass( "ui-state-disabled", !!value );=0A=
			this.element.prop( "disabled", !!value );=0A=
			this.buttons.button( value ? "disable" : "enable" );=0A=
		}=0A=
	},=0A=
=0A=
	_setOptions: spinner_modifier(function( options ) {=0A=
		this._super( options );=0A=
	}),=0A=
=0A=
	_parse: function( val ) {=0A=
		if ( typeof val =3D=3D=3D "string" && val !=3D=3D "" ) {=0A=
			val =3D window.Globalize && this.options.numberFormat ?=0A=
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;=0A=
		}=0A=
		return val =3D=3D=3D "" || isNaN( val ) ? null : val;=0A=
	},=0A=
=0A=
	_format: function( value ) {=0A=
		if ( value =3D=3D=3D "" ) {=0A=
			return "";=0A=
		}=0A=
		return window.Globalize && this.options.numberFormat ?=0A=
			Globalize.format( value, this.options.numberFormat, =
this.options.culture ) :=0A=
			value;=0A=
	},=0A=
=0A=
	_refresh: function() {=0A=
		this.element.attr({=0A=
			"aria-valuemin": this.options.min,=0A=
			"aria-valuemax": this.options.max,=0A=
			// TODO: what should we do with values that can't be parsed?=0A=
			"aria-valuenow": this._parse( this.element.val() )=0A=
		});=0A=
	},=0A=
=0A=
	isValid: function() {=0A=
		var value =3D this.value();=0A=
=0A=
		// null is invalid=0A=
		if ( value =3D=3D=3D null ) {=0A=
			return false;=0A=
		}=0A=
=0A=
		// if value gets adjusted, it's invalid=0A=
		return value =3D=3D=3D this._adjustValue( value );=0A=
	},=0A=
=0A=
	// update the value without triggering change=0A=
	_value: function( value, allowAny ) {=0A=
		var parsed;=0A=
		if ( value !=3D=3D "" ) {=0A=
			parsed =3D this._parse( value );=0A=
			if ( parsed !=3D=3D null ) {=0A=
				if ( !allowAny ) {=0A=
					parsed =3D this._adjustValue( parsed );=0A=
				}=0A=
				value =3D this._format( parsed );=0A=
			}=0A=
		}=0A=
		this.element.val( value );=0A=
		this._refresh();=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		this.element=0A=
			.removeClass( "ui-spinner-input" )=0A=
			.prop( "disabled", false )=0A=
			.removeAttr( "autocomplete" )=0A=
			.removeAttr( "role" )=0A=
			.removeAttr( "aria-valuemin" )=0A=
			.removeAttr( "aria-valuemax" )=0A=
			.removeAttr( "aria-valuenow" );=0A=
		this.uiSpinner.replaceWith( this.element );=0A=
	},=0A=
=0A=
	stepUp: spinner_modifier(function( steps ) {=0A=
		this._stepUp( steps );=0A=
	}),=0A=
	_stepUp: function( steps ) {=0A=
		if ( this._start() ) {=0A=
			this._spin( (steps || 1) * this.options.step );=0A=
			this._stop();=0A=
		}=0A=
	},=0A=
=0A=
	stepDown: spinner_modifier(function( steps ) {=0A=
		this._stepDown( steps );=0A=
	}),=0A=
	_stepDown: function( steps ) {=0A=
		if ( this._start() ) {=0A=
			this._spin( (steps || 1) * -this.options.step );=0A=
			this._stop();=0A=
		}=0A=
	},=0A=
=0A=
	pageUp: spinner_modifier(function( pages ) {=0A=
		this._stepUp( (pages || 1) * this.options.page );=0A=
	}),=0A=
=0A=
	pageDown: spinner_modifier(function( pages ) {=0A=
		this._stepDown( (pages || 1) * this.options.page );=0A=
	}),=0A=
=0A=
	value: function( newVal ) {=0A=
		if ( !arguments.length ) {=0A=
			return this._parse( this.element.val() );=0A=
		}=0A=
		spinner_modifier( this._value ).call( this, newVal );=0A=
	},=0A=
=0A=
	widget: function() {=0A=
		return this.uiSpinner;=0A=
	}=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Tabs 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/tabs/=0A=
 */=0A=
=0A=
=0A=
var tabs =3D $.widget( "ui.tabs", {=0A=
	version: "1.11.1",=0A=
	delay: 300,=0A=
	options: {=0A=
		active: null,=0A=
		collapsible: false,=0A=
		event: "click",=0A=
		heightStyle: "content",=0A=
		hide: null,=0A=
		show: null,=0A=
=0A=
		// callbacks=0A=
		activate: null,=0A=
		beforeActivate: null,=0A=
		beforeLoad: null,=0A=
		load: null=0A=
	},=0A=
=0A=
	_isLocal: (function() {=0A=
		var rhash =3D /#.*$/;=0A=
=0A=
		return function( anchor ) {=0A=
			var anchorUrl, locationUrl;=0A=
=0A=
			// support: IE7=0A=
			// IE7 doesn't normalize the href property when set via script (#9317)=0A=
			anchor =3D anchor.cloneNode( false );=0A=
=0A=
			anchorUrl =3D anchor.href.replace( rhash, "" );=0A=
			locationUrl =3D location.href.replace( rhash, "" );=0A=
=0A=
			// decoding may throw an error if the URL isn't UTF-8 (#9518)=0A=
			try {=0A=
				anchorUrl =3D decodeURIComponent( anchorUrl );=0A=
			} catch ( error ) {}=0A=
			try {=0A=
				locationUrl =3D decodeURIComponent( locationUrl );=0A=
			} catch ( error ) {}=0A=
=0A=
			return anchor.hash.length > 1 && anchorUrl =3D=3D=3D locationUrl;=0A=
		};=0A=
	})(),=0A=
=0A=
	_create: function() {=0A=
		var that =3D this,=0A=
			options =3D this.options;=0A=
=0A=
		this.running =3D false;=0A=
=0A=
		this.element=0A=
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )=0A=
			.toggleClass( "ui-tabs-collapsible", options.collapsible );=0A=
=0A=
		this._processTabs();=0A=
		options.active =3D this._initialActive();=0A=
=0A=
		// Take disabling tabs via class attribute from HTML=0A=
		// into account and update option properly.=0A=
		if ( $.isArray( options.disabled ) ) {=0A=
			options.disabled =3D $.unique( options.disabled.concat(=0A=
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {=0A=
					return that.tabs.index( li );=0A=
				})=0A=
			) ).sort();=0A=
		}=0A=
=0A=
		// check for length avoids error when initializing empty list=0A=
		if ( this.options.active !=3D=3D false && this.anchors.length ) {=0A=
			this.active =3D this._findActive( options.active );=0A=
		} else {=0A=
			this.active =3D $();=0A=
		}=0A=
=0A=
		this._refresh();=0A=
=0A=
		if ( this.active.length ) {=0A=
			this.load( options.active );=0A=
		}=0A=
	},=0A=
=0A=
	_initialActive: function() {=0A=
		var active =3D this.options.active,=0A=
			collapsible =3D this.options.collapsible,=0A=
			locationHash =3D location.hash.substring( 1 );=0A=
=0A=
		if ( active =3D=3D=3D null ) {=0A=
			// check the fragment identifier in the URL=0A=
			if ( locationHash ) {=0A=
				this.tabs.each(function( i, tab ) {=0A=
					if ( $( tab ).attr( "aria-controls" ) =3D=3D=3D locationHash ) {=0A=
						active =3D i;=0A=
						return false;=0A=
					}=0A=
				});=0A=
			}=0A=
=0A=
			// check for a tab marked active via a class=0A=
			if ( active =3D=3D=3D null ) {=0A=
				active =3D this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );=0A=
			}=0A=
=0A=
			// no active tab, set to false=0A=
			if ( active =3D=3D=3D null || active =3D=3D=3D -1 ) {=0A=
				active =3D this.tabs.length ? 0 : false;=0A=
			}=0A=
		}=0A=
=0A=
		// handle numbers: negative, out of range=0A=
		if ( active !=3D=3D false ) {=0A=
			active =3D this.tabs.index( this.tabs.eq( active ) );=0A=
			if ( active =3D=3D=3D -1 ) {=0A=
				active =3D collapsible ? false : 0;=0A=
			}=0A=
		}=0A=
=0A=
		// don't allow collapsible: false and active: false=0A=
		if ( !collapsible && active =3D=3D=3D false && this.anchors.length ) {=0A=
			active =3D 0;=0A=
		}=0A=
=0A=
		return active;=0A=
	},=0A=
=0A=
	_getCreateEventData: function() {=0A=
		return {=0A=
			tab: this.active,=0A=
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )=0A=
		};=0A=
	},=0A=
=0A=
	_tabKeydown: function( event ) {=0A=
		var focusedTab =3D $( this.document[0].activeElement ).closest( "li" ),=0A=
			selectedIndex =3D this.tabs.index( focusedTab ),=0A=
			goingForward =3D true;=0A=
=0A=
		if ( this._handlePageNav( event ) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		switch ( event.keyCode ) {=0A=
			case $.ui.keyCode.RIGHT:=0A=
			case $.ui.keyCode.DOWN:=0A=
				selectedIndex++;=0A=
				break;=0A=
			case $.ui.keyCode.UP:=0A=
			case $.ui.keyCode.LEFT:=0A=
				goingForward =3D false;=0A=
				selectedIndex--;=0A=
				break;=0A=
			case $.ui.keyCode.END:=0A=
				selectedIndex =3D this.anchors.length - 1;=0A=
				break;=0A=
			case $.ui.keyCode.HOME:=0A=
				selectedIndex =3D 0;=0A=
				break;=0A=
			case $.ui.keyCode.SPACE:=0A=
				// Activate only, no collapsing=0A=
				event.preventDefault();=0A=
				clearTimeout( this.activating );=0A=
				this._activate( selectedIndex );=0A=
				return;=0A=
			case $.ui.keyCode.ENTER:=0A=
				// Toggle (cancel delayed activation, allow collapsing)=0A=
				event.preventDefault();=0A=
				clearTimeout( this.activating );=0A=
				// Determine if we should collapse or activate=0A=
				this._activate( selectedIndex =3D=3D=3D this.options.active ? false =
: selectedIndex );=0A=
				return;=0A=
			default:=0A=
				return;=0A=
		}=0A=
=0A=
		// Focus the appropriate tab, based on which key was pressed=0A=
		event.preventDefault();=0A=
		clearTimeout( this.activating );=0A=
		selectedIndex =3D this._focusNextTab( selectedIndex, goingForward );=0A=
=0A=
		// Navigating with control key will prevent automatic activation=0A=
		if ( !event.ctrlKey ) {=0A=
			// Update aria-selected immediately so that AT think the tab is =
already selected.=0A=
			// Otherwise AT may confuse the user by stating that they need to =
activate the tab,=0A=
			// but the tab will already be activated by the time the announcement =
finishes.=0A=
			focusedTab.attr( "aria-selected", "false" );=0A=
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );=0A=
=0A=
			this.activating =3D this._delay(function() {=0A=
				this.option( "active", selectedIndex );=0A=
			}, this.delay );=0A=
		}=0A=
	},=0A=
=0A=
	_panelKeydown: function( event ) {=0A=
		if ( this._handlePageNav( event ) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Ctrl+up moves focus to the current tab=0A=
		if ( event.ctrlKey && event.keyCode =3D=3D=3D $.ui.keyCode.UP ) {=0A=
			event.preventDefault();=0A=
			this.active.focus();=0A=
		}=0A=
	},=0A=
=0A=
	// Alt+page up/down moves focus to the previous/next tab (and activates)=0A=
	_handlePageNav: function( event ) {=0A=
		if ( event.altKey && event.keyCode =3D=3D=3D $.ui.keyCode.PAGE_UP ) {=0A=
			this._activate( this._focusNextTab( this.options.active - 1, false ) =
);=0A=
			return true;=0A=
		}=0A=
		if ( event.altKey && event.keyCode =3D=3D=3D $.ui.keyCode.PAGE_DOWN ) {=0A=
			this._activate( this._focusNextTab( this.options.active + 1, true ) );=0A=
			return true;=0A=
		}=0A=
	},=0A=
=0A=
	_findNextTab: function( index, goingForward ) {=0A=
		var lastTabIndex =3D this.tabs.length - 1;=0A=
=0A=
		function constrain() {=0A=
			if ( index > lastTabIndex ) {=0A=
				index =3D 0;=0A=
			}=0A=
			if ( index < 0 ) {=0A=
				index =3D lastTabIndex;=0A=
			}=0A=
			return index;=0A=
		}=0A=
=0A=
		while ( $.inArray( constrain(), this.options.disabled ) !=3D=3D -1 ) {=0A=
			index =3D goingForward ? index + 1 : index - 1;=0A=
		}=0A=
=0A=
		return index;=0A=
	},=0A=
=0A=
	_focusNextTab: function( index, goingForward ) {=0A=
		index =3D this._findNextTab( index, goingForward );=0A=
		this.tabs.eq( index ).focus();=0A=
		return index;=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		if ( key =3D=3D=3D "active" ) {=0A=
			// _activate() will handle invalid values and update this.options=0A=
			this._activate( value );=0A=
			return;=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			// don't use the widget factory's disabled handling=0A=
			this._setupDisabled( value );=0A=
			return;=0A=
		}=0A=
=0A=
		this._super( key, value);=0A=
=0A=
		if ( key =3D=3D=3D "collapsible" ) {=0A=
			this.element.toggleClass( "ui-tabs-collapsible", value );=0A=
			// Setting collapsible: false while collapsed; open first panel=0A=
			if ( !value && this.options.active =3D=3D=3D false ) {=0A=
				this._activate( 0 );=0A=
			}=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "event" ) {=0A=
			this._setupEvents( value );=0A=
		}=0A=
=0A=
		if ( key =3D=3D=3D "heightStyle" ) {=0A=
			this._setupHeightStyle( value );=0A=
		}=0A=
	},=0A=
=0A=
	_sanitizeSelector: function( hash ) {=0A=
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=3D>?@\[\]\^`{|}~]/g, =
"\\$&" ) : "";=0A=
	},=0A=
=0A=
	refresh: function() {=0A=
		var options =3D this.options,=0A=
			lis =3D this.tablist.children( ":has(a[href])" );=0A=
=0A=
		// get disabled tabs from class attribute from HTML=0A=
		// this will get converted to a boolean if needed in _refresh()=0A=
		options.disabled =3D $.map( lis.filter( ".ui-state-disabled" ), =
function( tab ) {=0A=
			return lis.index( tab );=0A=
		});=0A=
=0A=
		this._processTabs();=0A=
=0A=
		// was collapsed or no tabs=0A=
		if ( options.active =3D=3D=3D false || !this.anchors.length ) {=0A=
			options.active =3D false;=0A=
			this.active =3D $();=0A=
		// was active, but active tab is gone=0A=
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], =
this.active[ 0 ] ) ) {=0A=
			// all remaining tabs are disabled=0A=
			if ( this.tabs.length =3D=3D=3D options.disabled.length ) {=0A=
				options.active =3D false;=0A=
				this.active =3D $();=0A=
			// activate previous tab=0A=
			} else {=0A=
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 =
), false ) );=0A=
			}=0A=
		// was active, active tab still exists=0A=
		} else {=0A=
			// make sure active index is correct=0A=
			options.active =3D this.tabs.index( this.active );=0A=
		}=0A=
=0A=
		this._refresh();=0A=
	},=0A=
=0A=
	_refresh: function() {=0A=
		this._setupDisabled( this.options.disabled );=0A=
		this._setupEvents( this.options.event );=0A=
		this._setupHeightStyle( this.options.heightStyle );=0A=
=0A=
		this.tabs.not( this.active ).attr({=0A=
			"aria-selected": "false",=0A=
			"aria-expanded": "false",=0A=
			tabIndex: -1=0A=
		});=0A=
		this.panels.not( this._getPanelForTab( this.active ) )=0A=
			.hide()=0A=
			.attr({=0A=
				"aria-hidden": "true"=0A=
			});=0A=
=0A=
		// Make sure one tab is in the tab order=0A=
		if ( !this.active.length ) {=0A=
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );=0A=
		} else {=0A=
			this.active=0A=
				.addClass( "ui-tabs-active ui-state-active" )=0A=
				.attr({=0A=
					"aria-selected": "true",=0A=
					"aria-expanded": "true",=0A=
					tabIndex: 0=0A=
				});=0A=
			this._getPanelForTab( this.active )=0A=
				.show()=0A=
				.attr({=0A=
					"aria-hidden": "false"=0A=
				});=0A=
		}=0A=
	},=0A=
=0A=
	_processTabs: function() {=0A=
		var that =3D this;=0A=
=0A=
		this.tablist =3D this._getList()=0A=
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix =
ui-widget-header ui-corner-all" )=0A=
			.attr( "role", "tablist" )=0A=
=0A=
			// Prevent users from focusing disabled tabs via click=0A=
			.delegate( "> li", "mousedown" + this.eventNamespace, function( event =
) {=0A=
				if ( $( this ).is( ".ui-state-disabled" ) ) {=0A=
					event.preventDefault();=0A=
				}=0A=
			})=0A=
=0A=
			// support: IE <9=0A=
			// Preventing the default action in mousedown doesn't prevent IE=0A=
			// from focusing the element, so if the anchor gets focused, blur.=0A=
			// We don't have to worry about focusing the previously focused=0A=
			// element since clicking on a non-focusable element should focus=0A=
			// the body anyway.=0A=
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, =
function() {=0A=
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {=0A=
					this.blur();=0A=
				}=0A=
			});=0A=
=0A=
		this.tabs =3D this.tablist.find( "> li:has(a[href])" )=0A=
			.addClass( "ui-state-default ui-corner-top" )=0A=
			.attr({=0A=
				role: "tab",=0A=
				tabIndex: -1=0A=
			});=0A=
=0A=
		this.anchors =3D this.tabs.map(function() {=0A=
				return $( "a", this )[ 0 ];=0A=
			})=0A=
			.addClass( "ui-tabs-anchor" )=0A=
			.attr({=0A=
				role: "presentation",=0A=
				tabIndex: -1=0A=
			});=0A=
=0A=
		this.panels =3D $();=0A=
=0A=
		this.anchors.each(function( i, anchor ) {=0A=
			var selector, panel, panelId,=0A=
				anchorId =3D $( anchor ).uniqueId().attr( "id" ),=0A=
				tab =3D $( anchor ).closest( "li" ),=0A=
				originalAriaControls =3D tab.attr( "aria-controls" );=0A=
=0A=
			// inline tab=0A=
			if ( that._isLocal( anchor ) ) {=0A=
				selector =3D anchor.hash;=0A=
				panelId =3D selector.substring( 1 );=0A=
				panel =3D that.element.find( that._sanitizeSelector( selector ) );=0A=
			// remote tab=0A=
			} else {=0A=
				// If the tab doesn't already have aria-controls,=0A=
				// generate an id by using a throw-away element=0A=
				panelId =3D tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 =
].id;=0A=
				selector =3D "#" + panelId;=0A=
				panel =3D that.element.find( selector );=0A=
				if ( !panel.length ) {=0A=
					panel =3D that._createPanel( panelId );=0A=
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );=0A=
				}=0A=
				panel.attr( "aria-live", "polite" );=0A=
			}=0A=
=0A=
			if ( panel.length) {=0A=
				that.panels =3D that.panels.add( panel );=0A=
			}=0A=
			if ( originalAriaControls ) {=0A=
				tab.data( "ui-tabs-aria-controls", originalAriaControls );=0A=
			}=0A=
			tab.attr({=0A=
				"aria-controls": panelId,=0A=
				"aria-labelledby": anchorId=0A=
			});=0A=
			panel.attr( "aria-labelledby", anchorId );=0A=
		});=0A=
=0A=
		this.panels=0A=
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )=0A=
			.attr( "role", "tabpanel" );=0A=
	},=0A=
=0A=
	// allow overriding how to find the list for rare usage scenarios =
(#7715)=0A=
	_getList: function() {=0A=
		return this.tablist || this.element.find( "ol,ul" ).eq( 0 );=0A=
	},=0A=
=0A=
	_createPanel: function( id ) {=0A=
		return $( "<div>" )=0A=
			.attr( "id", id )=0A=
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )=0A=
			.data( "ui-tabs-destroy", true );=0A=
	},=0A=
=0A=
	_setupDisabled: function( disabled ) {=0A=
		if ( $.isArray( disabled ) ) {=0A=
			if ( !disabled.length ) {=0A=
				disabled =3D false;=0A=
			} else if ( disabled.length =3D=3D=3D this.anchors.length ) {=0A=
				disabled =3D true;=0A=
			}=0A=
		}=0A=
=0A=
		// disable tabs=0A=
		for ( var i =3D 0, li; ( li =3D this.tabs[ i ] ); i++ ) {=0A=
			if ( disabled =3D=3D=3D true || $.inArray( i, disabled ) !=3D=3D -1 ) =
{=0A=
				$( li )=0A=
					.addClass( "ui-state-disabled" )=0A=
					.attr( "aria-disabled", "true" );=0A=
			} else {=0A=
				$( li )=0A=
					.removeClass( "ui-state-disabled" )=0A=
					.removeAttr( "aria-disabled" );=0A=
			}=0A=
		}=0A=
=0A=
		this.options.disabled =3D disabled;=0A=
	},=0A=
=0A=
	_setupEvents: function( event ) {=0A=
		var events =3D {};=0A=
		if ( event ) {=0A=
			$.each( event.split(" "), function( index, eventName ) {=0A=
				events[ eventName ] =3D "_eventHandler";=0A=
			});=0A=
		}=0A=
=0A=
		this._off( this.anchors.add( this.tabs ).add( this.panels ) );=0A=
		// Always prevent the default action, even when disabled=0A=
		this._on( true, this.anchors, {=0A=
			click: function( event ) {=0A=
				event.preventDefault();=0A=
			}=0A=
		});=0A=
		this._on( this.anchors, events );=0A=
		this._on( this.tabs, { keydown: "_tabKeydown" } );=0A=
		this._on( this.panels, { keydown: "_panelKeydown" } );=0A=
=0A=
		this._focusable( this.tabs );=0A=
		this._hoverable( this.tabs );=0A=
	},=0A=
=0A=
	_setupHeightStyle: function( heightStyle ) {=0A=
		var maxHeight,=0A=
			parent =3D this.element.parent();=0A=
=0A=
		if ( heightStyle =3D=3D=3D "fill" ) {=0A=
			maxHeight =3D parent.height();=0A=
			maxHeight -=3D this.element.outerHeight() - this.element.height();=0A=
=0A=
			this.element.siblings( ":visible" ).each(function() {=0A=
				var elem =3D $( this ),=0A=
					position =3D elem.css( "position" );=0A=
=0A=
				if ( position =3D=3D=3D "absolute" || position =3D=3D=3D "fixed" ) {=0A=
					return;=0A=
				}=0A=
				maxHeight -=3D elem.outerHeight( true );=0A=
			});=0A=
=0A=
			this.element.children().not( this.panels ).each(function() {=0A=
				maxHeight -=3D $( this ).outerHeight( true );=0A=
			});=0A=
=0A=
			this.panels.each(function() {=0A=
				$( this ).height( Math.max( 0, maxHeight -=0A=
					$( this ).innerHeight() + $( this ).height() ) );=0A=
			})=0A=
			.css( "overflow", "auto" );=0A=
		} else if ( heightStyle =3D=3D=3D "auto" ) {=0A=
			maxHeight =3D 0;=0A=
			this.panels.each(function() {=0A=
				maxHeight =3D Math.max( maxHeight, $( this ).height( "" ).height() );=0A=
			}).height( maxHeight );=0A=
		}=0A=
	},=0A=
=0A=
	_eventHandler: function( event ) {=0A=
		var options =3D this.options,=0A=
			active =3D this.active,=0A=
			anchor =3D $( event.currentTarget ),=0A=
			tab =3D anchor.closest( "li" ),=0A=
			clickedIsActive =3D tab[ 0 ] =3D=3D=3D active[ 0 ],=0A=
			collapsing =3D clickedIsActive && options.collapsible,=0A=
			toShow =3D collapsing ? $() : this._getPanelForTab( tab ),=0A=
			toHide =3D !active.length ? $() : this._getPanelForTab( active ),=0A=
			eventData =3D {=0A=
				oldTab: active,=0A=
				oldPanel: toHide,=0A=
				newTab: collapsing ? $() : tab,=0A=
				newPanel: toShow=0A=
			};=0A=
=0A=
		event.preventDefault();=0A=
=0A=
		if ( tab.hasClass( "ui-state-disabled" ) ||=0A=
				// tab is already loading=0A=
				tab.hasClass( "ui-tabs-loading" ) ||=0A=
				// can't switch durning an animation=0A=
				this.running ||=0A=
				// click on active header, but not collapsible=0A=
				( clickedIsActive && !options.collapsible ) ||=0A=
				// allow canceling activation=0A=
				( this._trigger( "beforeActivate", event, eventData ) =3D=3D=3D =
false ) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		options.active =3D collapsing ? false : this.tabs.index( tab );=0A=
=0A=
		this.active =3D clickedIsActive ? $() : tab;=0A=
		if ( this.xhr ) {=0A=
			this.xhr.abort();=0A=
		}=0A=
=0A=
		if ( !toHide.length && !toShow.length ) {=0A=
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );=0A=
		}=0A=
=0A=
		if ( toShow.length ) {=0A=
			this.load( this.tabs.index( tab ), event );=0A=
		}=0A=
		this._toggle( event, eventData );=0A=
	},=0A=
=0A=
	// handles show/hide for selecting tabs=0A=
	_toggle: function( event, eventData ) {=0A=
		var that =3D this,=0A=
			toShow =3D eventData.newPanel,=0A=
			toHide =3D eventData.oldPanel;=0A=
=0A=
		this.running =3D true;=0A=
=0A=
		function complete() {=0A=
			that.running =3D false;=0A=
			that._trigger( "activate", event, eventData );=0A=
		}=0A=
=0A=
		function show() {=0A=
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active =
ui-state-active" );=0A=
=0A=
			if ( toShow.length && that.options.show ) {=0A=
				that._show( toShow, that.options.show, complete );=0A=
			} else {=0A=
				toShow.show();=0A=
				complete();=0A=
			}=0A=
		}=0A=
=0A=
		// start out by hiding, then showing, then completing=0A=
		if ( toHide.length && this.options.hide ) {=0A=
			this._hide( toHide, this.options.hide, function() {=0A=
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active =
ui-state-active" );=0A=
				show();=0A=
			});=0A=
		} else {=0A=
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active =
ui-state-active" );=0A=
			toHide.hide();=0A=
			show();=0A=
		}=0A=
=0A=
		toHide.attr( "aria-hidden", "true" );=0A=
		eventData.oldTab.attr({=0A=
			"aria-selected": "false",=0A=
			"aria-expanded": "false"=0A=
		});=0A=
		// If we're switching tabs, remove the old tab from the tab order.=0A=
		// If we're opening from collapsed state, remove the previous tab from =
the tab order.=0A=
		// If we're collapsing, then keep the collapsing tab in the tab order.=0A=
		if ( toShow.length && toHide.length ) {=0A=
			eventData.oldTab.attr( "tabIndex", -1 );=0A=
		} else if ( toShow.length ) {=0A=
			this.tabs.filter(function() {=0A=
				return $( this ).attr( "tabIndex" ) =3D=3D=3D 0;=0A=
			})=0A=
			.attr( "tabIndex", -1 );=0A=
		}=0A=
=0A=
		toShow.attr( "aria-hidden", "false" );=0A=
		eventData.newTab.attr({=0A=
			"aria-selected": "true",=0A=
			"aria-expanded": "true",=0A=
			tabIndex: 0=0A=
		});=0A=
	},=0A=
=0A=
	_activate: function( index ) {=0A=
		var anchor,=0A=
			active =3D this._findActive( index );=0A=
=0A=
		// trying to activate the already active panel=0A=
		if ( active[ 0 ] =3D=3D=3D this.active[ 0 ] ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// trying to collapse, simulate a click on the current active header=0A=
		if ( !active.length ) {=0A=
			active =3D this.active;=0A=
		}=0A=
=0A=
		anchor =3D active.find( ".ui-tabs-anchor" )[ 0 ];=0A=
		this._eventHandler({=0A=
			target: anchor,=0A=
			currentTarget: anchor,=0A=
			preventDefault: $.noop=0A=
		});=0A=
	},=0A=
=0A=
	_findActive: function( index ) {=0A=
		return index =3D=3D=3D false ? $() : this.tabs.eq( index );=0A=
	},=0A=
=0A=
	_getIndex: function( index ) {=0A=
		// meta-function to give users option to provide a href string instead =
of a numerical index.=0A=
		if ( typeof index =3D=3D=3D "string" ) {=0A=
			index =3D this.anchors.index( this.anchors.filter( "[href$=3D'" + =
index + "']" ) );=0A=
		}=0A=
=0A=
		return index;=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		if ( this.xhr ) {=0A=
			this.xhr.abort();=0A=
		}=0A=
=0A=
		this.element.removeClass( "ui-tabs ui-widget ui-widget-content =
ui-corner-all ui-tabs-collapsible" );=0A=
=0A=
		this.tablist=0A=
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix =
ui-widget-header ui-corner-all" )=0A=
			.removeAttr( "role" );=0A=
=0A=
		this.anchors=0A=
			.removeClass( "ui-tabs-anchor" )=0A=
			.removeAttr( "role" )=0A=
			.removeAttr( "tabIndex" )=0A=
			.removeUniqueId();=0A=
=0A=
		this.tablist.unbind( this.eventNamespace );=0A=
=0A=
		this.tabs.add( this.panels ).each(function() {=0A=
			if ( $.data( this, "ui-tabs-destroy" ) ) {=0A=
				$( this ).remove();=0A=
			} else {=0A=
				$( this )=0A=
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " =
+=0A=
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active =
ui-tabs-panel" )=0A=
					.removeAttr( "tabIndex" )=0A=
					.removeAttr( "aria-live" )=0A=
					.removeAttr( "aria-busy" )=0A=
					.removeAttr( "aria-selected" )=0A=
					.removeAttr( "aria-labelledby" )=0A=
					.removeAttr( "aria-hidden" )=0A=
					.removeAttr( "aria-expanded" )=0A=
					.removeAttr( "role" );=0A=
			}=0A=
		});=0A=
=0A=
		this.tabs.each(function() {=0A=
			var li =3D $( this ),=0A=
				prev =3D li.data( "ui-tabs-aria-controls" );=0A=
			if ( prev ) {=0A=
				li=0A=
					.attr( "aria-controls", prev )=0A=
					.removeData( "ui-tabs-aria-controls" );=0A=
			} else {=0A=
				li.removeAttr( "aria-controls" );=0A=
			}=0A=
		});=0A=
=0A=
		this.panels.show();=0A=
=0A=
		if ( this.options.heightStyle !=3D=3D "content" ) {=0A=
			this.panels.css( "height", "" );=0A=
		}=0A=
	},=0A=
=0A=
	enable: function( index ) {=0A=
		var disabled =3D this.options.disabled;=0A=
		if ( disabled =3D=3D=3D false ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( index =3D=3D=3D undefined ) {=0A=
			disabled =3D false;=0A=
		} else {=0A=
			index =3D this._getIndex( index );=0A=
			if ( $.isArray( disabled ) ) {=0A=
				disabled =3D $.map( disabled, function( num ) {=0A=
					return num !=3D=3D index ? num : null;=0A=
				});=0A=
			} else {=0A=
				disabled =3D $.map( this.tabs, function( li, num ) {=0A=
					return num !=3D=3D index ? num : null;=0A=
				});=0A=
			}=0A=
		}=0A=
		this._setupDisabled( disabled );=0A=
	},=0A=
=0A=
	disable: function( index ) {=0A=
		var disabled =3D this.options.disabled;=0A=
		if ( disabled =3D=3D=3D true ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( index =3D=3D=3D undefined ) {=0A=
			disabled =3D true;=0A=
		} else {=0A=
			index =3D this._getIndex( index );=0A=
			if ( $.inArray( index, disabled ) !=3D=3D -1 ) {=0A=
				return;=0A=
			}=0A=
			if ( $.isArray( disabled ) ) {=0A=
				disabled =3D $.merge( [ index ], disabled ).sort();=0A=
			} else {=0A=
				disabled =3D [ index ];=0A=
			}=0A=
		}=0A=
		this._setupDisabled( disabled );=0A=
	},=0A=
=0A=
	load: function( index, event ) {=0A=
		index =3D this._getIndex( index );=0A=
		var that =3D this,=0A=
			tab =3D this.tabs.eq( index ),=0A=
			anchor =3D tab.find( ".ui-tabs-anchor" ),=0A=
			panel =3D this._getPanelForTab( tab ),=0A=
			eventData =3D {=0A=
				tab: tab,=0A=
				panel: panel=0A=
			};=0A=
=0A=
		// not remote=0A=
		if ( this._isLocal( anchor[ 0 ] ) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		this.xhr =3D $.ajax( this._ajaxSettings( anchor, event, eventData ) );=0A=
=0A=
		// support: jQuery <1.8=0A=
		// jQuery <1.8 returns false if the request is canceled in beforeSend,=0A=
		// but as of 1.8, $.ajax() always returns a jqXHR object.=0A=
		if ( this.xhr && this.xhr.statusText !=3D=3D "canceled" ) {=0A=
			tab.addClass( "ui-tabs-loading" );=0A=
			panel.attr( "aria-busy", "true" );=0A=
=0A=
			this.xhr=0A=
				.success(function( response ) {=0A=
					// support: jQuery <1.8=0A=
					// http://bugs.jquery.com/ticket/11778=0A=
					setTimeout(function() {=0A=
						panel.html( response );=0A=
						that._trigger( "load", event, eventData );=0A=
					}, 1 );=0A=
				})=0A=
				.complete(function( jqXHR, status ) {=0A=
					// support: jQuery <1.8=0A=
					// http://bugs.jquery.com/ticket/11778=0A=
					setTimeout(function() {=0A=
						if ( status =3D=3D=3D "abort" ) {=0A=
							that.panels.stop( false, true );=0A=
						}=0A=
=0A=
						tab.removeClass( "ui-tabs-loading" );=0A=
						panel.removeAttr( "aria-busy" );=0A=
=0A=
						if ( jqXHR =3D=3D=3D that.xhr ) {=0A=
							delete that.xhr;=0A=
						}=0A=
					}, 1 );=0A=
				});=0A=
		}=0A=
	},=0A=
=0A=
	_ajaxSettings: function( anchor, event, eventData ) {=0A=
		var that =3D this;=0A=
		return {=0A=
			url: anchor.attr( "href" ),=0A=
			beforeSend: function( jqXHR, settings ) {=0A=
				return that._trigger( "beforeLoad", event,=0A=
					$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );=0A=
			}=0A=
		};=0A=
	},=0A=
=0A=
	_getPanelForTab: function( tab ) {=0A=
		var id =3D $( tab ).attr( "aria-controls" );=0A=
		return this.element.find( this._sanitizeSelector( "#" + id ) );=0A=
	}=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Tooltip 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/tooltip/=0A=
 */=0A=
=0A=
=0A=
var tooltip =3D $.widget( "ui.tooltip", {=0A=
	version: "1.11.1",=0A=
	options: {=0A=
		content: function() {=0A=
			// support: IE<9, Opera in jQuery <1.7=0A=
			// .text() can't accept undefined, so coerce to a string=0A=
			var title =3D $( this ).attr( "title" ) || "";=0A=
			// Escape title, since we're going from an attribute to raw HTML=0A=
			return $( "<a>" ).text( title ).html();=0A=
		},=0A=
		hide: true,=0A=
		// Disabled elements have inconsistent behavior across browsers (#8661)=0A=
		items: "[title]:not([disabled])",=0A=
		position: {=0A=
			my: "left top+15",=0A=
			at: "left bottom",=0A=
			collision: "flipfit flip"=0A=
		},=0A=
		show: true,=0A=
		tooltipClass: null,=0A=
		track: false,=0A=
=0A=
		// callbacks=0A=
		close: null,=0A=
		open: null=0A=
	},=0A=
=0A=
	_addDescribedBy: function( elem, id ) {=0A=
		var describedby =3D (elem.attr( "aria-describedby" ) || "").split( =
/\s+/ );=0A=
		describedby.push( id );=0A=
		elem=0A=
			.data( "ui-tooltip-id", id )=0A=
			.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );=0A=
	},=0A=
=0A=
	_removeDescribedBy: function( elem ) {=0A=
		var id =3D elem.data( "ui-tooltip-id" ),=0A=
			describedby =3D (elem.attr( "aria-describedby" ) || "").split( /\s+/ =
),=0A=
			index =3D $.inArray( id, describedby );=0A=
=0A=
		if ( index !=3D=3D -1 ) {=0A=
			describedby.splice( index, 1 );=0A=
		}=0A=
=0A=
		elem.removeData( "ui-tooltip-id" );=0A=
		describedby =3D $.trim( describedby.join( " " ) );=0A=
		if ( describedby ) {=0A=
			elem.attr( "aria-describedby", describedby );=0A=
		} else {=0A=
			elem.removeAttr( "aria-describedby" );=0A=
		}=0A=
	},=0A=
=0A=
	_create: function() {=0A=
		this._on({=0A=
			mouseover: "open",=0A=
			focusin: "open"=0A=
		});=0A=
=0A=
		// IDs of generated tooltips, needed for destroy=0A=
		this.tooltips =3D {};=0A=
		// IDs of parent tooltips where we removed the title attribute=0A=
		this.parents =3D {};=0A=
=0A=
		if ( this.options.disabled ) {=0A=
			this._disable();=0A=
		}=0A=
=0A=
		// Append the aria-live region so tooltips announce correctly=0A=
		this.liveRegion =3D $( "<div>" )=0A=
			.attr({=0A=
				role: "log",=0A=
				"aria-live": "assertive",=0A=
				"aria-relevant": "additions"=0A=
			})=0A=
			.addClass( "ui-helper-hidden-accessible" )=0A=
			.appendTo( this.document[ 0 ].body );=0A=
	},=0A=
=0A=
	_setOption: function( key, value ) {=0A=
		var that =3D this;=0A=
=0A=
		if ( key =3D=3D=3D "disabled" ) {=0A=
			this[ value ? "_disable" : "_enable" ]();=0A=
			this.options[ key ] =3D value;=0A=
			// disable element style changes=0A=
			return;=0A=
		}=0A=
=0A=
		this._super( key, value );=0A=
=0A=
		if ( key =3D=3D=3D "content" ) {=0A=
			$.each( this.tooltips, function( id, element ) {=0A=
				that._updateContent( element );=0A=
			});=0A=
		}=0A=
	},=0A=
=0A=
	_disable: function() {=0A=
		var that =3D this;=0A=
=0A=
		// close open tooltips=0A=
		$.each( this.tooltips, function( id, element ) {=0A=
			var event =3D $.Event( "blur" );=0A=
			event.target =3D event.currentTarget =3D element[0];=0A=
			that.close( event, true );=0A=
		});=0A=
=0A=
		// remove title attributes to prevent native tooltips=0A=
		this.element.find( this.options.items ).addBack().each(function() {=0A=
			var element =3D $( this );=0A=
			if ( element.is( "[title]" ) ) {=0A=
				element=0A=
					.data( "ui-tooltip-title", element.attr( "title" ) )=0A=
					.removeAttr( "title" );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	_enable: function() {=0A=
		// restore title attributes=0A=
		this.element.find( this.options.items ).addBack().each(function() {=0A=
			var element =3D $( this );=0A=
			if ( element.data( "ui-tooltip-title" ) ) {=0A=
				element.attr( "title", element.data( "ui-tooltip-title" ) );=0A=
			}=0A=
		});=0A=
	},=0A=
=0A=
	open: function( event ) {=0A=
		var that =3D this,=0A=
			target =3D $( event ? event.target : this.element )=0A=
				// we need closest here due to mouseover bubbling,=0A=
				// but always pointing at the same event target=0A=
				.closest( this.options.items );=0A=
=0A=
		// No element to show a tooltip for or the tooltip is already open=0A=
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {=0A=
			return;=0A=
		}=0A=
=0A=
		if ( target.attr( "title" ) ) {=0A=
			target.data( "ui-tooltip-title", target.attr( "title" ) );=0A=
		}=0A=
=0A=
		target.data( "ui-tooltip-open", true );=0A=
=0A=
		// kill parent tooltips, custom or native, for hover=0A=
		if ( event && event.type =3D=3D=3D "mouseover" ) {=0A=
			target.parents().each(function() {=0A=
				var parent =3D $( this ),=0A=
					blurEvent;=0A=
				if ( parent.data( "ui-tooltip-open" ) ) {=0A=
					blurEvent =3D $.Event( "blur" );=0A=
					blurEvent.target =3D blurEvent.currentTarget =3D this;=0A=
					that.close( blurEvent, true );=0A=
				}=0A=
				if ( parent.attr( "title" ) ) {=0A=
					parent.uniqueId();=0A=
					that.parents[ this.id ] =3D {=0A=
						element: this,=0A=
						title: parent.attr( "title" )=0A=
					};=0A=
					parent.attr( "title", "" );=0A=
				}=0A=
			});=0A=
		}=0A=
=0A=
		this._updateContent( target, event );=0A=
	},=0A=
=0A=
	_updateContent: function( target, event ) {=0A=
		var content,=0A=
			contentOption =3D this.options.content,=0A=
			that =3D this,=0A=
			eventType =3D event ? event.type : null;=0A=
=0A=
		if ( typeof contentOption =3D=3D=3D "string" ) {=0A=
			return this._open( event, target, contentOption );=0A=
		}=0A=
=0A=
		content =3D contentOption.call( target[0], function( response ) {=0A=
			// ignore async response if tooltip was closed already=0A=
			if ( !target.data( "ui-tooltip-open" ) ) {=0A=
				return;=0A=
			}=0A=
			// IE may instantly serve a cached response for ajax requests=0A=
			// delay this call to _open so the other call to _open runs first=0A=
			that._delay(function() {=0A=
				// jQuery creates a special event for focusin when it doesn't=0A=
				// exist natively. To improve performance, the native event=0A=
				// object is reused and the type is changed. Therefore, we can't=0A=
				// rely on the type being correct after the event finished=0A=
				// bubbling, so we set it back to the previous value. (#8740)=0A=
				if ( event ) {=0A=
					event.type =3D eventType;=0A=
				}=0A=
				this._open( event, target, response );=0A=
			});=0A=
		});=0A=
		if ( content ) {=0A=
			this._open( event, target, content );=0A=
		}=0A=
	},=0A=
=0A=
	_open: function( event, target, content ) {=0A=
		var tooltip, events, delayedShow, a11yContent,=0A=
			positionOption =3D $.extend( {}, this.options.position );=0A=
=0A=
		if ( !content ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Content can be updated multiple times. If the tooltip already=0A=
		// exists, then just update the content and bail.=0A=
		tooltip =3D this._find( target );=0A=
		if ( tooltip.length ) {=0A=
			tooltip.find( ".ui-tooltip-content" ).html( content );=0A=
			return;=0A=
		}=0A=
=0A=
		// if we have a title, clear it to prevent the native tooltip=0A=
		// we have to check first to avoid defining a title if none exists=0A=
		// (we don't want to cause an element to start matching [title])=0A=
		//=0A=
		// We use removeAttr only for key events, to allow IE to export the =
correct=0A=
		// accessible attributes. For mouse events, set to empty string to =
avoid=0A=
		// native tooltip showing up (happens only when removing inside =
mouseover).=0A=
		if ( target.is( "[title]" ) ) {=0A=
			if ( event && event.type =3D=3D=3D "mouseover" ) {=0A=
				target.attr( "title", "" );=0A=
			} else {=0A=
				target.removeAttr( "title" );=0A=
			}=0A=
		}=0A=
=0A=
		tooltip =3D this._tooltip( target );=0A=
		this._addDescribedBy( target, tooltip.attr( "id" ) );=0A=
		tooltip.find( ".ui-tooltip-content" ).html( content );=0A=
=0A=
		// Support: Voiceover on OS X, JAWS on IE <=3D 9=0A=
		// JAWS announces deletions even when aria-relevant=3D"additions"=0A=
		// Voiceover will sometimes re-read the entire log region's contents =
from the beginning=0A=
		this.liveRegion.children().hide();=0A=
		if ( content.clone ) {=0A=
			a11yContent =3D content.clone();=0A=
			a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );=0A=
		} else {=0A=
			a11yContent =3D content;=0A=
		}=0A=
		$( "<div>" ).html( a11yContent ).appendTo( this.liveRegion );=0A=
=0A=
		function position( event ) {=0A=
			positionOption.of =3D event;=0A=
			if ( tooltip.is( ":hidden" ) ) {=0A=
				return;=0A=
			}=0A=
			tooltip.position( positionOption );=0A=
		}=0A=
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {=0A=
			this._on( this.document, {=0A=
				mousemove: position=0A=
			});=0A=
			// trigger once to override element-relative positioning=0A=
			position( event );=0A=
		} else {=0A=
			tooltip.position( $.extend({=0A=
				of: target=0A=
			}, this.options.position ) );=0A=
		}=0A=
=0A=
		this.hiding =3D false;=0A=
		this.closing =3D false;=0A=
		tooltip.hide();=0A=
=0A=
		this._show( tooltip, this.options.show );=0A=
		// Handle tracking tooltips that are shown with a delay (#8644). As =
soon=0A=
		// as the tooltip is visible, position the tooltip using the most =
recent=0A=
		// event.=0A=
		if ( this.options.show && this.options.show.delay ) {=0A=
			delayedShow =3D this.delayedShow =3D setInterval(function() {=0A=
				if ( tooltip.is( ":visible" ) ) {=0A=
					position( positionOption.of );=0A=
					clearInterval( delayedShow );=0A=
				}=0A=
			}, $.fx.interval );=0A=
		}=0A=
=0A=
		this._trigger( "open", event, { tooltip: tooltip } );=0A=
=0A=
		events =3D {=0A=
			keyup: function( event ) {=0A=
				if ( event.keyCode =3D=3D=3D $.ui.keyCode.ESCAPE ) {=0A=
					var fakeEvent =3D $.Event(event);=0A=
					fakeEvent.currentTarget =3D target[0];=0A=
					this.close( fakeEvent, true );=0A=
				}=0A=
			}=0A=
		};=0A=
=0A=
		// Only bind remove handler for delegated targets. Non-delegated=0A=
		// tooltips will handle this in destroy.=0A=
		if ( target[ 0 ] !=3D=3D this.element[ 0 ] ) {=0A=
			events.remove =3D function() {=0A=
				this._removeTooltip( tooltip );=0A=
			};=0A=
		}=0A=
=0A=
		if ( !event || event.type =3D=3D=3D "mouseover" ) {=0A=
			events.mouseleave =3D "close";=0A=
		}=0A=
		if ( !event || event.type =3D=3D=3D "focusin" ) {=0A=
			events.focusout =3D "close";=0A=
		}=0A=
		this._on( true, target, events );=0A=
	},=0A=
=0A=
	close: function( event ) {=0A=
		var that =3D this,=0A=
			target =3D $( event ? event.currentTarget : this.element ),=0A=
			tooltip =3D this._find( target );=0A=
=0A=
		// disabling closes the tooltip, so we need to track when we're closing=0A=
		// to avoid an infinite loop in case the tooltip becomes disabled on =
close=0A=
		if ( this.closing ) {=0A=
			return;=0A=
		}=0A=
=0A=
		// Clear the interval for delayed tracking tooltips=0A=
		clearInterval( this.delayedShow );=0A=
=0A=
		// only set title if we had one before (see comment in _open())=0A=
		// If the title attribute has changed since open(), don't restore=0A=
		if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {=0A=
			target.attr( "title", target.data( "ui-tooltip-title" ) );=0A=
		}=0A=
=0A=
		this._removeDescribedBy( target );=0A=
=0A=
		this.hiding =3D true;=0A=
		tooltip.stop( true );=0A=
		this._hide( tooltip, this.options.hide, function() {=0A=
			that._removeTooltip( $( this ) );=0A=
			this.hiding =3D false;=0A=
			this.closing =3D false;=0A=
		});=0A=
=0A=
		target.removeData( "ui-tooltip-open" );=0A=
		this._off( target, "mouseleave focusout keyup" );=0A=
=0A=
		// Remove 'remove' binding only on delegated targets=0A=
		if ( target[ 0 ] !=3D=3D this.element[ 0 ] ) {=0A=
			this._off( target, "remove" );=0A=
		}=0A=
		this._off( this.document, "mousemove" );=0A=
=0A=
		if ( event && event.type =3D=3D=3D "mouseleave" ) {=0A=
			$.each( this.parents, function( id, parent ) {=0A=
				$( parent.element ).attr( "title", parent.title );=0A=
				delete that.parents[ id ];=0A=
			});=0A=
		}=0A=
=0A=
		this.closing =3D true;=0A=
		this._trigger( "close", event, { tooltip: tooltip } );=0A=
		if ( !this.hiding ) {=0A=
			this.closing =3D false;=0A=
		}=0A=
	},=0A=
=0A=
	_tooltip: function( element ) {=0A=
		var tooltip =3D $( "<div>" )=0A=
				.attr( "role", "tooltip" )=0A=
				.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +=0A=
					( this.options.tooltipClass || "" ) ),=0A=
			id =3D tooltip.uniqueId().attr( "id" );=0A=
=0A=
		$( "<div>" )=0A=
			.addClass( "ui-tooltip-content" )=0A=
			.appendTo( tooltip );=0A=
=0A=
		tooltip.appendTo( this.document[0].body );=0A=
		this.tooltips[ id ] =3D element;=0A=
		return tooltip;=0A=
	},=0A=
=0A=
	_find: function( target ) {=0A=
		var id =3D target.data( "ui-tooltip-id" );=0A=
		return id ? $( "#" + id ) : $();=0A=
	},=0A=
=0A=
	_removeTooltip: function( tooltip ) {=0A=
		tooltip.remove();=0A=
		delete this.tooltips[ tooltip.attr( "id" ) ];=0A=
	},=0A=
=0A=
	_destroy: function() {=0A=
		var that =3D this;=0A=
=0A=
		// close open tooltips=0A=
		$.each( this.tooltips, function( id, element ) {=0A=
			// Delegate to close method to handle common cleanup=0A=
			var event =3D $.Event( "blur" );=0A=
			event.target =3D event.currentTarget =3D element[0];=0A=
			that.close( event, true );=0A=
=0A=
			// Remove immediately; destroying an open tooltip doesn't use the=0A=
			// hide animation=0A=
			$( "#" + id ).remove();=0A=
=0A=
			// Restore the title=0A=
			if ( element.data( "ui-tooltip-title" ) ) {=0A=
				// If the title attribute has changed since open(), don't restore=0A=
				if ( !element.attr( "title" ) ) {=0A=
					element.attr( "title", element.data( "ui-tooltip-title" ) );=0A=
				}=0A=
				element.removeData( "ui-tooltip-title" );=0A=
			}=0A=
		});=0A=
		this.liveRegion.remove();=0A=
	}=0A=
});=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/category/effects-core/=0A=
 */=0A=
=0A=
=0A=
var dataSpace =3D "ui-effects-",=0A=
=0A=
	// Create a local jQuery because jQuery Color relies on it and the=0A=
	// global may not exist with AMD and a custom build (#10199)=0A=
	jQuery =3D $;=0A=
=0A=
$.effects =3D {=0A=
	effect: {}=0A=
};=0A=
=0A=
/*!=0A=
 * jQuery Color Animations v2.1.2=0A=
 * https://github.com/jquery/jquery-color=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * Date: Wed Jan 16 08:47:09 2013 -0600=0A=
 */=0A=
(function( jQuery, undefined ) {=0A=
=0A=
	var stepHooks =3D "backgroundColor borderBottomColor borderLeftColor =
borderRightColor borderTopColor color columnRuleColor outlineColor =
textDecorationColor textEmphasisColor",=0A=
=0A=
	// plusequals test for +=3D 100 -=3D 100=0A=
	rplusequals =3D /^([\-+])=3D\s*(\d+\.?\d*)/,=0A=
	// a set of RE's that can match strings and generate color tuples.=0A=
	stringParsers =3D [ {=0A=
			re: =
/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d=
+)?)\s*)?\)/,=0A=
			parse: function( execResult ) {=0A=
				return [=0A=
					execResult[ 1 ],=0A=
					execResult[ 2 ],=0A=
					execResult[ 3 ],=0A=
					execResult[ 4 ]=0A=
				];=0A=
			}=0A=
		}, {=0A=
			re: =
/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?=
)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,=0A=
			parse: function( execResult ) {=0A=
				return [=0A=
					execResult[ 1 ] * 2.55,=0A=
					execResult[ 2 ] * 2.55,=0A=
					execResult[ 3 ] * 2.55,=0A=
					execResult[ 4 ]=0A=
				];=0A=
			}=0A=
		}, {=0A=
			// this regex ignores A-F because it's compared against an already =
lowercased string=0A=
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,=0A=
			parse: function( execResult ) {=0A=
				return [=0A=
					parseInt( execResult[ 1 ], 16 ),=0A=
					parseInt( execResult[ 2 ], 16 ),=0A=
					parseInt( execResult[ 3 ], 16 )=0A=
				];=0A=
			}=0A=
		}, {=0A=
			// this regex ignores A-F because it's compared against an already =
lowercased string=0A=
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,=0A=
			parse: function( execResult ) {=0A=
				return [=0A=
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),=0A=
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),=0A=
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )=0A=
				];=0A=
			}=0A=
		}, {=0A=
			re: =
/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\=
%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,=0A=
			space: "hsla",=0A=
			parse: function( execResult ) {=0A=
				return [=0A=
					execResult[ 1 ],=0A=
					execResult[ 2 ] / 100,=0A=
					execResult[ 3 ] / 100,=0A=
					execResult[ 4 ]=0A=
				];=0A=
			}=0A=
		} ],=0A=
=0A=
	// jQuery.Color( )=0A=
	color =3D jQuery.Color =3D function( color, green, blue, alpha ) {=0A=
		return new jQuery.Color.fn.parse( color, green, blue, alpha );=0A=
	},=0A=
	spaces =3D {=0A=
		rgba: {=0A=
			props: {=0A=
				red: {=0A=
					idx: 0,=0A=
					type: "byte"=0A=
				},=0A=
				green: {=0A=
					idx: 1,=0A=
					type: "byte"=0A=
				},=0A=
				blue: {=0A=
					idx: 2,=0A=
					type: "byte"=0A=
				}=0A=
			}=0A=
		},=0A=
=0A=
		hsla: {=0A=
			props: {=0A=
				hue: {=0A=
					idx: 0,=0A=
					type: "degrees"=0A=
				},=0A=
				saturation: {=0A=
					idx: 1,=0A=
					type: "percent"=0A=
				},=0A=
				lightness: {=0A=
					idx: 2,=0A=
					type: "percent"=0A=
				}=0A=
			}=0A=
		}=0A=
	},=0A=
	propTypes =3D {=0A=
		"byte": {=0A=
			floor: true,=0A=
			max: 255=0A=
		},=0A=
		"percent": {=0A=
			max: 1=0A=
		},=0A=
		"degrees": {=0A=
			mod: 360,=0A=
			floor: true=0A=
		}=0A=
	},=0A=
	support =3D color.support =3D {},=0A=
=0A=
	// element for support tests=0A=
	supportElem =3D jQuery( "<p>" )[ 0 ],=0A=
=0A=
	// colors =3D jQuery.Color.names=0A=
	colors,=0A=
=0A=
	// local aliases of functions called often=0A=
	each =3D jQuery.each;=0A=
=0A=
// determine rgba support immediately=0A=
supportElem.style.cssText =3D "background-color:rgba(1,1,1,.5)";=0A=
support.rgba =3D supportElem.style.backgroundColor.indexOf( "rgba" ) > =
-1;=0A=
=0A=
// define cache name and alpha properties=0A=
// for rgba and hsla spaces=0A=
each( spaces, function( spaceName, space ) {=0A=
	space.cache =3D "_" + spaceName;=0A=
	space.props.alpha =3D {=0A=
		idx: 3,=0A=
		type: "percent",=0A=
		def: 1=0A=
	};=0A=
});=0A=
=0A=
function clamp( value, prop, allowEmpty ) {=0A=
	var type =3D propTypes[ prop.type ] || {};=0A=
=0A=
	if ( value =3D=3D null ) {=0A=
		return (allowEmpty || !prop.def) ? null : prop.def;=0A=
	}=0A=
=0A=
	// ~~ is an short way of doing floor for positive numbers=0A=
	value =3D type.floor ? ~~value : parseFloat( value );=0A=
=0A=
	// IE will pass in empty strings as value for alpha,=0A=
	// which will hit this case=0A=
	if ( isNaN( value ) ) {=0A=
		return prop.def;=0A=
	}=0A=
=0A=
	if ( type.mod ) {=0A=
		// we add mod before modding to make sure that negatives values=0A=
		// get converted properly: -10 -> 350=0A=
		return (value + type.mod) % type.mod;=0A=
	}=0A=
=0A=
	// for now all property types without mod have min and max=0A=
	return 0 > value ? 0 : type.max < value ? type.max : value;=0A=
}=0A=
=0A=
function stringParse( string ) {=0A=
	var inst =3D color(),=0A=
		rgba =3D inst._rgba =3D [];=0A=
=0A=
	string =3D string.toLowerCase();=0A=
=0A=
	each( stringParsers, function( i, parser ) {=0A=
		var parsed,=0A=
			match =3D parser.re.exec( string ),=0A=
			values =3D match && parser.parse( match ),=0A=
			spaceName =3D parser.space || "rgba";=0A=
=0A=
		if ( values ) {=0A=
			parsed =3D inst[ spaceName ]( values );=0A=
=0A=
			// if this was an rgba parse the assignment might happen twice=0A=
			// oh well....=0A=
			inst[ spaces[ spaceName ].cache ] =3D parsed[ spaces[ spaceName =
].cache ];=0A=
			rgba =3D inst._rgba =3D parsed._rgba;=0A=
=0A=
			// exit each( stringParsers ) here because we matched=0A=
			return false;=0A=
		}=0A=
	});=0A=
=0A=
	// Found a stringParser that handled it=0A=
	if ( rgba.length ) {=0A=
=0A=
		// if this came from a parsed string, force "transparent" when alpha =
is 0=0A=
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)=0A=
		if ( rgba.join() =3D=3D=3D "0,0,0,0" ) {=0A=
			jQuery.extend( rgba, colors.transparent );=0A=
		}=0A=
		return inst;=0A=
	}=0A=
=0A=
	// named colors=0A=
	return colors[ string ];=0A=
}=0A=
=0A=
color.fn =3D jQuery.extend( color.prototype, {=0A=
	parse: function( red, green, blue, alpha ) {=0A=
		if ( red =3D=3D=3D undefined ) {=0A=
			this._rgba =3D [ null, null, null, null ];=0A=
			return this;=0A=
		}=0A=
		if ( red.jquery || red.nodeType ) {=0A=
			red =3D jQuery( red ).css( green );=0A=
			green =3D undefined;=0A=
		}=0A=
=0A=
		var inst =3D this,=0A=
			type =3D jQuery.type( red ),=0A=
			rgba =3D this._rgba =3D [];=0A=
=0A=
		// more than 1 argument specified - assume ( red, green, blue, alpha )=0A=
		if ( green !=3D=3D undefined ) {=0A=
			red =3D [ red, green, blue, alpha ];=0A=
			type =3D "array";=0A=
		}=0A=
=0A=
		if ( type =3D=3D=3D "string" ) {=0A=
			return this.parse( stringParse( red ) || colors._default );=0A=
		}=0A=
=0A=
		if ( type =3D=3D=3D "array" ) {=0A=
			each( spaces.rgba.props, function( key, prop ) {=0A=
				rgba[ prop.idx ] =3D clamp( red[ prop.idx ], prop );=0A=
			});=0A=
			return this;=0A=
		}=0A=
=0A=
		if ( type =3D=3D=3D "object" ) {=0A=
			if ( red instanceof color ) {=0A=
				each( spaces, function( spaceName, space ) {=0A=
					if ( red[ space.cache ] ) {=0A=
						inst[ space.cache ] =3D red[ space.cache ].slice();=0A=
					}=0A=
				});=0A=
			} else {=0A=
				each( spaces, function( spaceName, space ) {=0A=
					var cache =3D space.cache;=0A=
					each( space.props, function( key, prop ) {=0A=
=0A=
						// if the cache doesn't exist, and we know how to convert=0A=
						if ( !inst[ cache ] && space.to ) {=0A=
=0A=
							// if the value was null, we don't need to copy it=0A=
							// if the key was alpha, we don't need to copy it either=0A=
							if ( key =3D=3D=3D "alpha" || red[ key ] =3D=3D null ) {=0A=
								return;=0A=
							}=0A=
							inst[ cache ] =3D space.to( inst._rgba );=0A=
						}=0A=
=0A=
						// this is the only case where we allow nulls for ALL properties.=0A=
						// call clamp with alwaysAllowEmpty=0A=
						inst[ cache ][ prop.idx ] =3D clamp( red[ key ], prop, true );=0A=
					});=0A=
=0A=
					// everything defined but alpha?=0A=
					if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, =
3 ) ) < 0 ) {=0A=
						// use the default of 1=0A=
						inst[ cache ][ 3 ] =3D 1;=0A=
						if ( space.from ) {=0A=
							inst._rgba =3D space.from( inst[ cache ] );=0A=
						}=0A=
					}=0A=
				});=0A=
			}=0A=
			return this;=0A=
		}=0A=
	},=0A=
	is: function( compare ) {=0A=
		var is =3D color( compare ),=0A=
			same =3D true,=0A=
			inst =3D this;=0A=
=0A=
		each( spaces, function( _, space ) {=0A=
			var localCache,=0A=
				isCache =3D is[ space.cache ];=0A=
			if (isCache) {=0A=
				localCache =3D inst[ space.cache ] || space.to && space.to( =
inst._rgba ) || [];=0A=
				each( space.props, function( _, prop ) {=0A=
					if ( isCache[ prop.idx ] !=3D null ) {=0A=
						same =3D ( isCache[ prop.idx ] =3D=3D=3D localCache[ prop.idx ] );=0A=
						return same;=0A=
					}=0A=
				});=0A=
			}=0A=
			return same;=0A=
		});=0A=
		return same;=0A=
	},=0A=
	_space: function() {=0A=
		var used =3D [],=0A=
			inst =3D this;=0A=
		each( spaces, function( spaceName, space ) {=0A=
			if ( inst[ space.cache ] ) {=0A=
				used.push( spaceName );=0A=
			}=0A=
		});=0A=
		return used.pop();=0A=
	},=0A=
	transition: function( other, distance ) {=0A=
		var end =3D color( other ),=0A=
			spaceName =3D end._space(),=0A=
			space =3D spaces[ spaceName ],=0A=
			startColor =3D this.alpha() =3D=3D=3D 0 ? color( "transparent" ) : =
this,=0A=
			start =3D startColor[ space.cache ] || space.to( startColor._rgba ),=0A=
			result =3D start.slice();=0A=
=0A=
		end =3D end[ space.cache ];=0A=
		each( space.props, function( key, prop ) {=0A=
			var index =3D prop.idx,=0A=
				startValue =3D start[ index ],=0A=
				endValue =3D end[ index ],=0A=
				type =3D propTypes[ prop.type ] || {};=0A=
=0A=
			// if null, don't override start value=0A=
			if ( endValue =3D=3D=3D null ) {=0A=
				return;=0A=
			}=0A=
			// if null - use end=0A=
			if ( startValue =3D=3D=3D null ) {=0A=
				result[ index ] =3D endValue;=0A=
			} else {=0A=
				if ( type.mod ) {=0A=
					if ( endValue - startValue > type.mod / 2 ) {=0A=
						startValue +=3D type.mod;=0A=
					} else if ( startValue - endValue > type.mod / 2 ) {=0A=
						startValue -=3D type.mod;=0A=
					}=0A=
				}=0A=
				result[ index ] =3D clamp( ( endValue - startValue ) * distance + =
startValue, prop );=0A=
			}=0A=
		});=0A=
		return this[ spaceName ]( result );=0A=
	},=0A=
	blend: function( opaque ) {=0A=
		// if we are already opaque - return ourself=0A=
		if ( this._rgba[ 3 ] =3D=3D=3D 1 ) {=0A=
			return this;=0A=
		}=0A=
=0A=
		var rgb =3D this._rgba.slice(),=0A=
			a =3D rgb.pop(),=0A=
			blend =3D color( opaque )._rgba;=0A=
=0A=
		return color( jQuery.map( rgb, function( v, i ) {=0A=
			return ( 1 - a ) * blend[ i ] + a * v;=0A=
		}));=0A=
	},=0A=
	toRgbaString: function() {=0A=
		var prefix =3D "rgba(",=0A=
			rgba =3D jQuery.map( this._rgba, function( v, i ) {=0A=
				return v =3D=3D null ? ( i > 2 ? 1 : 0 ) : v;=0A=
			});=0A=
=0A=
		if ( rgba[ 3 ] =3D=3D=3D 1 ) {=0A=
			rgba.pop();=0A=
			prefix =3D "rgb(";=0A=
		}=0A=
=0A=
		return prefix + rgba.join() + ")";=0A=
	},=0A=
	toHslaString: function() {=0A=
		var prefix =3D "hsla(",=0A=
			hsla =3D jQuery.map( this.hsla(), function( v, i ) {=0A=
				if ( v =3D=3D null ) {=0A=
					v =3D i > 2 ? 1 : 0;=0A=
				}=0A=
=0A=
				// catch 1 and 2=0A=
				if ( i && i < 3 ) {=0A=
					v =3D Math.round( v * 100 ) + "%";=0A=
				}=0A=
				return v;=0A=
			});=0A=
=0A=
		if ( hsla[ 3 ] =3D=3D=3D 1 ) {=0A=
			hsla.pop();=0A=
			prefix =3D "hsl(";=0A=
		}=0A=
		return prefix + hsla.join() + ")";=0A=
	},=0A=
	toHexString: function( includeAlpha ) {=0A=
		var rgba =3D this._rgba.slice(),=0A=
			alpha =3D rgba.pop();=0A=
=0A=
		if ( includeAlpha ) {=0A=
			rgba.push( ~~( alpha * 255 ) );=0A=
		}=0A=
=0A=
		return "#" + jQuery.map( rgba, function( v ) {=0A=
=0A=
			// default to 0 when nulls exist=0A=
			v =3D ( v || 0 ).toString( 16 );=0A=
			return v.length =3D=3D=3D 1 ? "0" + v : v;=0A=
		}).join("");=0A=
	},=0A=
	toString: function() {=0A=
		return this._rgba[ 3 ] =3D=3D=3D 0 ? "transparent" : =
this.toRgbaString();=0A=
	}=0A=
});=0A=
color.fn.parse.prototype =3D color.fn;=0A=
=0A=
// hsla conversions adapted from:=0A=
// =
https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk=
/src/graphics/colors/HUE2RGB.as?r=3D5021=0A=
=0A=
function hue2rgb( p, q, h ) {=0A=
	h =3D ( h + 1 ) % 1;=0A=
	if ( h * 6 < 1 ) {=0A=
		return p + ( q - p ) * h * 6;=0A=
	}=0A=
	if ( h * 2 < 1) {=0A=
		return q;=0A=
	}=0A=
	if ( h * 3 < 2 ) {=0A=
		return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;=0A=
	}=0A=
	return p;=0A=
}=0A=
=0A=
spaces.hsla.to =3D function( rgba ) {=0A=
	if ( rgba[ 0 ] =3D=3D null || rgba[ 1 ] =3D=3D null || rgba[ 2 ] =3D=3D =
null ) {=0A=
		return [ null, null, null, rgba[ 3 ] ];=0A=
	}=0A=
	var r =3D rgba[ 0 ] / 255,=0A=
		g =3D rgba[ 1 ] / 255,=0A=
		b =3D rgba[ 2 ] / 255,=0A=
		a =3D rgba[ 3 ],=0A=
		max =3D Math.max( r, g, b ),=0A=
		min =3D Math.min( r, g, b ),=0A=
		diff =3D max - min,=0A=
		add =3D max + min,=0A=
		l =3D add * 0.5,=0A=
		h, s;=0A=
=0A=
	if ( min =3D=3D=3D max ) {=0A=
		h =3D 0;=0A=
	} else if ( r =3D=3D=3D max ) {=0A=
		h =3D ( 60 * ( g - b ) / diff ) + 360;=0A=
	} else if ( g =3D=3D=3D max ) {=0A=
		h =3D ( 60 * ( b - r ) / diff ) + 120;=0A=
	} else {=0A=
		h =3D ( 60 * ( r - g ) / diff ) + 240;=0A=
	}=0A=
=0A=
	// chroma (diff) =3D=3D 0 means greyscale which, by definition, =
saturation =3D 0%=0A=
	// otherwise, saturation is based on the ratio of chroma (diff) to =
lightness (add)=0A=
	if ( diff =3D=3D=3D 0 ) {=0A=
		s =3D 0;=0A=
	} else if ( l <=3D 0.5 ) {=0A=
		s =3D diff / add;=0A=
	} else {=0A=
		s =3D diff / ( 2 - add );=0A=
	}=0A=
	return [ Math.round(h) % 360, s, l, a =3D=3D null ? 1 : a ];=0A=
};=0A=
=0A=
spaces.hsla.from =3D function( hsla ) {=0A=
	if ( hsla[ 0 ] =3D=3D null || hsla[ 1 ] =3D=3D null || hsla[ 2 ] =3D=3D =
null ) {=0A=
		return [ null, null, null, hsla[ 3 ] ];=0A=
	}=0A=
	var h =3D hsla[ 0 ] / 360,=0A=
		s =3D hsla[ 1 ],=0A=
		l =3D hsla[ 2 ],=0A=
		a =3D hsla[ 3 ],=0A=
		q =3D l <=3D 0.5 ? l * ( 1 + s ) : l + s - l * s,=0A=
		p =3D 2 * l - q;=0A=
=0A=
	return [=0A=
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),=0A=
		Math.round( hue2rgb( p, q, h ) * 255 ),=0A=
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),=0A=
		a=0A=
	];=0A=
};=0A=
=0A=
each( spaces, function( spaceName, space ) {=0A=
	var props =3D space.props,=0A=
		cache =3D space.cache,=0A=
		to =3D space.to,=0A=
		from =3D space.from;=0A=
=0A=
	// makes rgba() and hsla()=0A=
	color.fn[ spaceName ] =3D function( value ) {=0A=
=0A=
		// generate a cache for this space if it doesn't exist=0A=
		if ( to && !this[ cache ] ) {=0A=
			this[ cache ] =3D to( this._rgba );=0A=
		}=0A=
		if ( value =3D=3D=3D undefined ) {=0A=
			return this[ cache ].slice();=0A=
		}=0A=
=0A=
		var ret,=0A=
			type =3D jQuery.type( value ),=0A=
			arr =3D ( type =3D=3D=3D "array" || type =3D=3D=3D "object" ) ? value =
: arguments,=0A=
			local =3D this[ cache ].slice();=0A=
=0A=
		each( props, function( key, prop ) {=0A=
			var val =3D arr[ type =3D=3D=3D "object" ? key : prop.idx ];=0A=
			if ( val =3D=3D null ) {=0A=
				val =3D local[ prop.idx ];=0A=
			}=0A=
			local[ prop.idx ] =3D clamp( val, prop );=0A=
		});=0A=
=0A=
		if ( from ) {=0A=
			ret =3D color( from( local ) );=0A=
			ret[ cache ] =3D local;=0A=
			return ret;=0A=
		} else {=0A=
			return color( local );=0A=
		}=0A=
	};=0A=
=0A=
	// makes red() green() blue() alpha() hue() saturation() lightness()=0A=
	each( props, function( key, prop ) {=0A=
		// alpha is included in more than one space=0A=
		if ( color.fn[ key ] ) {=0A=
			return;=0A=
		}=0A=
		color.fn[ key ] =3D function( value ) {=0A=
			var vtype =3D jQuery.type( value ),=0A=
				fn =3D ( key =3D=3D=3D "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : =
spaceName ),=0A=
				local =3D this[ fn ](),=0A=
				cur =3D local[ prop.idx ],=0A=
				match;=0A=
=0A=
			if ( vtype =3D=3D=3D "undefined" ) {=0A=
				return cur;=0A=
			}=0A=
=0A=
			if ( vtype =3D=3D=3D "function" ) {=0A=
				value =3D value.call( this, cur );=0A=
				vtype =3D jQuery.type( value );=0A=
			}=0A=
			if ( value =3D=3D null && prop.empty ) {=0A=
				return this;=0A=
			}=0A=
			if ( vtype =3D=3D=3D "string" ) {=0A=
				match =3D rplusequals.exec( value );=0A=
				if ( match ) {=0A=
					value =3D cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] =3D=3D=3D =
"+" ? 1 : -1 );=0A=
				}=0A=
			}=0A=
			local[ prop.idx ] =3D value;=0A=
			return this[ fn ]( local );=0A=
		};=0A=
	});=0A=
});=0A=
=0A=
// add cssHook and .fx.step function for each named hook.=0A=
// accept a space separated string of properties=0A=
color.hook =3D function( hook ) {=0A=
	var hooks =3D hook.split( " " );=0A=
	each( hooks, function( i, hook ) {=0A=
		jQuery.cssHooks[ hook ] =3D {=0A=
			set: function( elem, value ) {=0A=
				var parsed, curElem,=0A=
					backgroundColor =3D "";=0A=
=0A=
				if ( value !=3D=3D "transparent" && ( jQuery.type( value ) !=3D=3D =
"string" || ( parsed =3D stringParse( value ) ) ) ) {=0A=
					value =3D color( parsed || value );=0A=
					if ( !support.rgba && value._rgba[ 3 ] !=3D=3D 1 ) {=0A=
						curElem =3D hook =3D=3D=3D "backgroundColor" ? elem.parentNode : =
elem;=0A=
						while (=0A=
							(backgroundColor =3D=3D=3D "" || backgroundColor =3D=3D=3D =
"transparent") &&=0A=
							curElem && curElem.style=0A=
						) {=0A=
							try {=0A=
								backgroundColor =3D jQuery.css( curElem, "backgroundColor" );=0A=
								curElem =3D curElem.parentNode;=0A=
							} catch ( e ) {=0A=
							}=0A=
						}=0A=
=0A=
						value =3D value.blend( backgroundColor && backgroundColor !=3D=3D =
"transparent" ?=0A=
							backgroundColor :=0A=
							"_default" );=0A=
					}=0A=
=0A=
					value =3D value.toRgbaString();=0A=
				}=0A=
				try {=0A=
					elem.style[ hook ] =3D value;=0A=
				} catch( e ) {=0A=
					// wrapped to prevent IE from throwing errors on "invalid" values =
like 'auto' or 'inherit'=0A=
				}=0A=
			}=0A=
		};=0A=
		jQuery.fx.step[ hook ] =3D function( fx ) {=0A=
			if ( !fx.colorInit ) {=0A=
				fx.start =3D color( fx.elem, hook );=0A=
				fx.end =3D color( fx.end );=0A=
				fx.colorInit =3D true;=0A=
			}=0A=
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, =
fx.pos ) );=0A=
		};=0A=
	});=0A=
=0A=
};=0A=
=0A=
color.hook( stepHooks );=0A=
=0A=
jQuery.cssHooks.borderColor =3D {=0A=
	expand: function( value ) {=0A=
		var expanded =3D {};=0A=
=0A=
		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {=0A=
			expanded[ "border" + part + "Color" ] =3D value;=0A=
		});=0A=
		return expanded;=0A=
	}=0A=
};=0A=
=0A=
// Basic color names only.=0A=
// Usage of any of the other color names requires adding yourself or =
including=0A=
// jquery.color.svg-names.js.=0A=
colors =3D jQuery.Color.names =3D {=0A=
	// 4.1. Basic color keywords=0A=
	aqua: "#00ffff",=0A=
	black: "#000000",=0A=
	blue: "#0000ff",=0A=
	fuchsia: "#ff00ff",=0A=
	gray: "#808080",=0A=
	green: "#008000",=0A=
	lime: "#00ff00",=0A=
	maroon: "#800000",=0A=
	navy: "#000080",=0A=
	olive: "#808000",=0A=
	purple: "#800080",=0A=
	red: "#ff0000",=0A=
	silver: "#c0c0c0",=0A=
	teal: "#008080",=0A=
	white: "#ffffff",=0A=
	yellow: "#ffff00",=0A=
=0A=
	// 4.2.3. "transparent" color keyword=0A=
	transparent: [ null, null, null, 0 ],=0A=
=0A=
	_default: "#ffffff"=0A=
};=0A=
=0A=
})( jQuery );=0A=
=0A=
/************************************************************************=
******/=0A=
/****************************** CLASS ANIMATIONS =
******************************/=0A=
/************************************************************************=
******/=0A=
(function() {=0A=
=0A=
var classAnimationActions =3D [ "add", "remove", "toggle" ],=0A=
	shorthandStyles =3D {=0A=
		border: 1,=0A=
		borderBottom: 1,=0A=
		borderColor: 1,=0A=
		borderLeft: 1,=0A=
		borderRight: 1,=0A=
		borderTop: 1,=0A=
		borderWidth: 1,=0A=
		margin: 1,=0A=
		padding: 1=0A=
	};=0A=
=0A=
$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", =
"borderTopStyle" ], function( _, prop ) {=0A=
	$.fx.step[ prop ] =3D function( fx ) {=0A=
		if ( fx.end !=3D=3D "none" && !fx.setAttr || fx.pos =3D=3D=3D 1 && =
!fx.setAttr ) {=0A=
			jQuery.style( fx.elem, prop, fx.end );=0A=
			fx.setAttr =3D true;=0A=
		}=0A=
	};=0A=
});=0A=
=0A=
function getElementStyles( elem ) {=0A=
	var key, len,=0A=
		style =3D elem.ownerDocument.defaultView ?=0A=
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :=0A=
			elem.currentStyle,=0A=
		styles =3D {};=0A=
=0A=
	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {=0A=
		len =3D style.length;=0A=
		while ( len-- ) {=0A=
			key =3D style[ len ];=0A=
			if ( typeof style[ key ] =3D=3D=3D "string" ) {=0A=
				styles[ $.camelCase( key ) ] =3D style[ key ];=0A=
			}=0A=
		}=0A=
	// support: Opera, IE <9=0A=
	} else {=0A=
		for ( key in style ) {=0A=
			if ( typeof style[ key ] =3D=3D=3D "string" ) {=0A=
				styles[ key ] =3D style[ key ];=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	return styles;=0A=
}=0A=
=0A=
function styleDifference( oldStyle, newStyle ) {=0A=
	var diff =3D {},=0A=
		name, value;=0A=
=0A=
	for ( name in newStyle ) {=0A=
		value =3D newStyle[ name ];=0A=
		if ( oldStyle[ name ] !=3D=3D value ) {=0A=
			if ( !shorthandStyles[ name ] ) {=0A=
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {=0A=
					diff[ name ] =3D value;=0A=
				}=0A=
			}=0A=
		}=0A=
	}=0A=
=0A=
	return diff;=0A=
}=0A=
=0A=
// support: jQuery <1.8=0A=
if ( !$.fn.addBack ) {=0A=
	$.fn.addBack =3D function( selector ) {=0A=
		return this.add( selector =3D=3D null ?=0A=
			this.prevObject : this.prevObject.filter( selector )=0A=
		);=0A=
	};=0A=
}=0A=
=0A=
$.effects.animateClass =3D function( value, duration, easing, callback ) =
{=0A=
	var o =3D $.speed( duration, easing, callback );=0A=
=0A=
	return this.queue( function() {=0A=
		var animated =3D $( this ),=0A=
			baseClass =3D animated.attr( "class" ) || "",=0A=
			applyClassChange,=0A=
			allAnimations =3D o.children ? animated.find( "*" ).addBack() : =
animated;=0A=
=0A=
		// map the animated objects to store the original styles.=0A=
		allAnimations =3D allAnimations.map(function() {=0A=
			var el =3D $( this );=0A=
			return {=0A=
				el: el,=0A=
				start: getElementStyles( this )=0A=
			};=0A=
		});=0A=
=0A=
		// apply class change=0A=
		applyClassChange =3D function() {=0A=
			$.each( classAnimationActions, function(i, action) {=0A=
				if ( value[ action ] ) {=0A=
					animated[ action + "Class" ]( value[ action ] );=0A=
				}=0A=
			});=0A=
		};=0A=
		applyClassChange();=0A=
=0A=
		// map all animated objects again - calculate new styles and diff=0A=
		allAnimations =3D allAnimations.map(function() {=0A=
			this.end =3D getElementStyles( this.el[ 0 ] );=0A=
			this.diff =3D styleDifference( this.start, this.end );=0A=
			return this;=0A=
		});=0A=
=0A=
		// apply original class=0A=
		animated.attr( "class", baseClass );=0A=
=0A=
		// map all animated objects again - this time collecting a promise=0A=
		allAnimations =3D allAnimations.map(function() {=0A=
			var styleInfo =3D this,=0A=
				dfd =3D $.Deferred(),=0A=
				opts =3D $.extend({}, o, {=0A=
					queue: false,=0A=
					complete: function() {=0A=
						dfd.resolve( styleInfo );=0A=
					}=0A=
				});=0A=
=0A=
			this.el.animate( this.diff, opts );=0A=
			return dfd.promise();=0A=
		});=0A=
=0A=
		// once all animations have completed:=0A=
		$.when.apply( $, allAnimations.get() ).done(function() {=0A=
=0A=
			// set the final class=0A=
			applyClassChange();=0A=
=0A=
			// for each animated element,=0A=
			// clear all css properties that were animated=0A=
			$.each( arguments, function() {=0A=
				var el =3D this.el;=0A=
				$.each( this.diff, function(key) {=0A=
					el.css( key, "" );=0A=
				});=0A=
			});=0A=
=0A=
			// this is guarnteed to be there if you use jQuery.speed()=0A=
			// it also handles dequeuing the next anim...=0A=
			o.complete.call( animated[ 0 ] );=0A=
		});=0A=
	});=0A=
};=0A=
=0A=
$.fn.extend({=0A=
	addClass: (function( orig ) {=0A=
		return function( classNames, speed, easing, callback ) {=0A=
			return speed ?=0A=
				$.effects.animateClass.call( this,=0A=
					{ add: classNames }, speed, easing, callback ) :=0A=
				orig.apply( this, arguments );=0A=
		};=0A=
	})( $.fn.addClass ),=0A=
=0A=
	removeClass: (function( orig ) {=0A=
		return function( classNames, speed, easing, callback ) {=0A=
			return arguments.length > 1 ?=0A=
				$.effects.animateClass.call( this,=0A=
					{ remove: classNames }, speed, easing, callback ) :=0A=
				orig.apply( this, arguments );=0A=
		};=0A=
	})( $.fn.removeClass ),=0A=
=0A=
	toggleClass: (function( orig ) {=0A=
		return function( classNames, force, speed, easing, callback ) {=0A=
			if ( typeof force =3D=3D=3D "boolean" || force =3D=3D=3D undefined ) {=0A=
				if ( !speed ) {=0A=
					// without speed parameter=0A=
					return orig.apply( this, arguments );=0A=
				} else {=0A=
					return $.effects.animateClass.call( this,=0A=
						(force ? { add: classNames } : { remove: classNames }),=0A=
						speed, easing, callback );=0A=
				}=0A=
			} else {=0A=
				// without force parameter=0A=
				return $.effects.animateClass.call( this,=0A=
					{ toggle: classNames }, force, speed, easing );=0A=
			}=0A=
		};=0A=
	})( $.fn.toggleClass ),=0A=
=0A=
	switchClass: function( remove, add, speed, easing, callback) {=0A=
		return $.effects.animateClass.call( this, {=0A=
			add: add,=0A=
			remove: remove=0A=
		}, speed, easing, callback );=0A=
	}=0A=
});=0A=
=0A=
})();=0A=
=0A=
/************************************************************************=
******/=0A=
/*********************************** EFFECTS =
**********************************/=0A=
/************************************************************************=
******/=0A=
=0A=
(function() {=0A=
=0A=
$.extend( $.effects, {=0A=
	version: "1.11.1",=0A=
=0A=
	// Saves a set of properties in a data storage=0A=
	save: function( element, set ) {=0A=
		for ( var i =3D 0; i < set.length; i++ ) {=0A=
			if ( set[ i ] !=3D=3D null ) {=0A=
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	// Restores a set of previously saved properties from a data storage=0A=
	restore: function( element, set ) {=0A=
		var val, i;=0A=
		for ( i =3D 0; i < set.length; i++ ) {=0A=
			if ( set[ i ] !=3D=3D null ) {=0A=
				val =3D element.data( dataSpace + set[ i ] );=0A=
				// support: jQuery 1.6.2=0A=
				// http://bugs.jquery.com/ticket/9917=0A=
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.=0A=
				// We can't differentiate between "" and 0 here, so we just assume=0A=
				// empty string since it's likely to be a more common value...=0A=
				if ( val =3D=3D=3D undefined ) {=0A=
					val =3D "";=0A=
				}=0A=
				element.css( set[ i ], val );=0A=
			}=0A=
		}=0A=
	},=0A=
=0A=
	setMode: function( el, mode ) {=0A=
		if (mode =3D=3D=3D "toggle") {=0A=
			mode =3D el.is( ":hidden" ) ? "show" : "hide";=0A=
		}=0A=
		return mode;=0A=
	},=0A=
=0A=
	// Translates a [top,left] array into a baseline value=0A=
	// this should be a little more flexible in the future to handle a =
string & hash=0A=
	getBaseline: function( origin, original ) {=0A=
		var y, x;=0A=
		switch ( origin[ 0 ] ) {=0A=
			case "top": y =3D 0; break;=0A=
			case "middle": y =3D 0.5; break;=0A=
			case "bottom": y =3D 1; break;=0A=
			default: y =3D origin[ 0 ] / original.height;=0A=
		}=0A=
		switch ( origin[ 1 ] ) {=0A=
			case "left": x =3D 0; break;=0A=
			case "center": x =3D 0.5; break;=0A=
			case "right": x =3D 1; break;=0A=
			default: x =3D origin[ 1 ] / original.width;=0A=
		}=0A=
		return {=0A=
			x: x,=0A=
			y: y=0A=
		};=0A=
	},=0A=
=0A=
	// Wraps the element around a wrapper that copies position properties=0A=
	createWrapper: function( element ) {=0A=
=0A=
		// if the element is already wrapped, return it=0A=
		if ( element.parent().is( ".ui-effects-wrapper" )) {=0A=
			return element.parent();=0A=
		}=0A=
=0A=
		// wrap the element=0A=
		var props =3D {=0A=
				width: element.outerWidth(true),=0A=
				height: element.outerHeight(true),=0A=
				"float": element.css( "float" )=0A=
			},=0A=
			wrapper =3D $( "<div></div>" )=0A=
				.addClass( "ui-effects-wrapper" )=0A=
				.css({=0A=
					fontSize: "100%",=0A=
					background: "transparent",=0A=
					border: "none",=0A=
					margin: 0,=0A=
					padding: 0=0A=
				}),=0A=
			// Store the size in case width/height are defined in % - Fixes #5245=0A=
			size =3D {=0A=
				width: element.width(),=0A=
				height: element.height()=0A=
			},=0A=
			active =3D document.activeElement;=0A=
=0A=
		// support: Firefox=0A=
		// Firefox incorrectly exposes anonymous content=0A=
		// https://bugzilla.mozilla.org/show_bug.cgi?id=3D561664=0A=
		try {=0A=
			active.id;=0A=
		} catch( e ) {=0A=
			active =3D document.body;=0A=
		}=0A=
=0A=
		element.wrap( wrapper );=0A=
=0A=
		// Fixes #7595 - Elements lose focus when wrapped.=0A=
		if ( element[ 0 ] =3D=3D=3D active || $.contains( element[ 0 ], active =
) ) {=0A=
			$( active ).focus();=0A=
		}=0A=
=0A=
		wrapper =3D element.parent(); //Hotfix for jQuery 1.4 since some =
change in wrap() seems to actually lose the reference to the wrapped =
element=0A=
=0A=
		// transfer positioning properties to the wrapper=0A=
		if ( element.css( "position" ) =3D=3D=3D "static" ) {=0A=
			wrapper.css({ position: "relative" });=0A=
			element.css({ position: "relative" });=0A=
		} else {=0A=
			$.extend( props, {=0A=
				position: element.css( "position" ),=0A=
				zIndex: element.css( "z-index" )=0A=
			});=0A=
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {=0A=
				props[ pos ] =3D element.css( pos );=0A=
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {=0A=
					props[ pos ] =3D "auto";=0A=
				}=0A=
			});=0A=
			element.css({=0A=
				position: "relative",=0A=
				top: 0,=0A=
				left: 0,=0A=
				right: "auto",=0A=
				bottom: "auto"=0A=
			});=0A=
		}=0A=
		element.css(size);=0A=
=0A=
		return wrapper.css( props ).show();=0A=
	},=0A=
=0A=
	removeWrapper: function( element ) {=0A=
		var active =3D document.activeElement;=0A=
=0A=
		if ( element.parent().is( ".ui-effects-wrapper" ) ) {=0A=
			element.parent().replaceWith( element );=0A=
=0A=
			// Fixes #7595 - Elements lose focus when wrapped.=0A=
			if ( element[ 0 ] =3D=3D=3D active || $.contains( element[ 0 ], =
active ) ) {=0A=
				$( active ).focus();=0A=
			}=0A=
		}=0A=
=0A=
		return element;=0A=
	},=0A=
=0A=
	setTransition: function( element, list, factor, value ) {=0A=
		value =3D value || {};=0A=
		$.each( list, function( i, x ) {=0A=
			var unit =3D element.cssUnit( x );=0A=
			if ( unit[ 0 ] > 0 ) {=0A=
				value[ x ] =3D unit[ 0 ] * factor + unit[ 1 ];=0A=
			}=0A=
		});=0A=
		return value;=0A=
	}=0A=
});=0A=
=0A=
// return an effect options object for the given parameters:=0A=
function _normalizeArguments( effect, options, speed, callback ) {=0A=
=0A=
	// allow passing all options as the first parameter=0A=
	if ( $.isPlainObject( effect ) ) {=0A=
		options =3D effect;=0A=
		effect =3D effect.effect;=0A=
	}=0A=
=0A=
	// convert to an object=0A=
	effect =3D { effect: effect };=0A=
=0A=
	// catch (effect, null, ...)=0A=
	if ( options =3D=3D null ) {=0A=
		options =3D {};=0A=
	}=0A=
=0A=
	// catch (effect, callback)=0A=
	if ( $.isFunction( options ) ) {=0A=
		callback =3D options;=0A=
		speed =3D null;=0A=
		options =3D {};=0A=
	}=0A=
=0A=
	// catch (effect, speed, ?)=0A=
	if ( typeof options =3D=3D=3D "number" || $.fx.speeds[ options ] ) {=0A=
		callback =3D speed;=0A=
		speed =3D options;=0A=
		options =3D {};=0A=
	}=0A=
=0A=
	// catch (effect, options, callback)=0A=
	if ( $.isFunction( speed ) ) {=0A=
		callback =3D speed;=0A=
		speed =3D null;=0A=
	}=0A=
=0A=
	// add options to effect=0A=
	if ( options ) {=0A=
		$.extend( effect, options );=0A=
	}=0A=
=0A=
	speed =3D speed || options.duration;=0A=
	effect.duration =3D $.fx.off ? 0 :=0A=
		typeof speed =3D=3D=3D "number" ? speed :=0A=
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :=0A=
		$.fx.speeds._default;=0A=
=0A=
	effect.complete =3D callback || options.complete;=0A=
=0A=
	return effect;=0A=
}=0A=
=0A=
function standardAnimationOption( option ) {=0A=
	// Valid standard speeds (nothing, number, named speed)=0A=
	if ( !option || typeof option =3D=3D=3D "number" || $.fx.speeds[ option =
] ) {=0A=
		return true;=0A=
	}=0A=
=0A=
	// Invalid strings - treat as "normal" speed=0A=
	if ( typeof option =3D=3D=3D "string" && !$.effects.effect[ option ] ) {=0A=
		return true;=0A=
	}=0A=
=0A=
	// Complete callback=0A=
	if ( $.isFunction( option ) ) {=0A=
		return true;=0A=
	}=0A=
=0A=
	// Options hash (but not naming an effect)=0A=
	if ( typeof option =3D=3D=3D "object" && !option.effect ) {=0A=
		return true;=0A=
	}=0A=
=0A=
	// Didn't match any standard API=0A=
	return false;=0A=
}=0A=
=0A=
$.fn.extend({=0A=
	effect: function( /* effect, options, speed, callback */ ) {=0A=
		var args =3D _normalizeArguments.apply( this, arguments ),=0A=
			mode =3D args.mode,=0A=
			queue =3D args.queue,=0A=
			effectMethod =3D $.effects.effect[ args.effect ];=0A=
=0A=
		if ( $.fx.off || !effectMethod ) {=0A=
			// delegate to the original method (e.g., .show()) if possible=0A=
			if ( mode ) {=0A=
				return this[ mode ]( args.duration, args.complete );=0A=
			} else {=0A=
				return this.each( function() {=0A=
					if ( args.complete ) {=0A=
						args.complete.call( this );=0A=
					}=0A=
				});=0A=
			}=0A=
		}=0A=
=0A=
		function run( next ) {=0A=
			var elem =3D $( this ),=0A=
				complete =3D args.complete,=0A=
				mode =3D args.mode;=0A=
=0A=
			function done() {=0A=
				if ( $.isFunction( complete ) ) {=0A=
					complete.call( elem[0] );=0A=
				}=0A=
				if ( $.isFunction( next ) ) {=0A=
					next();=0A=
				}=0A=
			}=0A=
=0A=
			// If the element already has the correct final state, delegate to=0A=
			// the core methods so the internal tracking of "olddisplay" works.=0A=
			if ( elem.is( ":hidden" ) ? mode =3D=3D=3D "hide" : mode =3D=3D=3D =
"show" ) {=0A=
				elem[ mode ]();=0A=
				done();=0A=
			} else {=0A=
				effectMethod.call( elem[0], args, done );=0A=
			}=0A=
		}=0A=
=0A=
		return queue =3D=3D=3D false ? this.each( run ) : this.queue( queue || =
"fx", run );=0A=
	},=0A=
=0A=
	show: (function( orig ) {=0A=
		return function( option ) {=0A=
			if ( standardAnimationOption( option ) ) {=0A=
				return orig.apply( this, arguments );=0A=
			} else {=0A=
				var args =3D _normalizeArguments.apply( this, arguments );=0A=
				args.mode =3D "show";=0A=
				return this.effect.call( this, args );=0A=
			}=0A=
		};=0A=
	})( $.fn.show ),=0A=
=0A=
	hide: (function( orig ) {=0A=
		return function( option ) {=0A=
			if ( standardAnimationOption( option ) ) {=0A=
				return orig.apply( this, arguments );=0A=
			} else {=0A=
				var args =3D _normalizeArguments.apply( this, arguments );=0A=
				args.mode =3D "hide";=0A=
				return this.effect.call( this, args );=0A=
			}=0A=
		};=0A=
	})( $.fn.hide ),=0A=
=0A=
	toggle: (function( orig ) {=0A=
		return function( option ) {=0A=
			if ( standardAnimationOption( option ) || typeof option =3D=3D=3D =
"boolean" ) {=0A=
				return orig.apply( this, arguments );=0A=
			} else {=0A=
				var args =3D _normalizeArguments.apply( this, arguments );=0A=
				args.mode =3D "toggle";=0A=
				return this.effect.call( this, args );=0A=
			}=0A=
		};=0A=
	})( $.fn.toggle ),=0A=
=0A=
	// helper functions=0A=
	cssUnit: function(key) {=0A=
		var style =3D this.css( key ),=0A=
			val =3D [];=0A=
=0A=
		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {=0A=
			if ( style.indexOf( unit ) > 0 ) {=0A=
				val =3D [ parseFloat( style ), unit ];=0A=
			}=0A=
		});=0A=
		return val;=0A=
	}=0A=
});=0A=
=0A=
})();=0A=
=0A=
/************************************************************************=
******/=0A=
/*********************************** EASING =
***********************************/=0A=
/************************************************************************=
******/=0A=
=0A=
(function() {=0A=
=0A=
// based on easing equations from Robert Penner =
(http://www.robertpenner.com/easing)=0A=
=0A=
var baseEasings =3D {};=0A=
=0A=
$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name =
) {=0A=
	baseEasings[ name ] =3D function( p ) {=0A=
		return Math.pow( p, i + 2 );=0A=
	};=0A=
});=0A=
=0A=
$.extend( baseEasings, {=0A=
	Sine: function( p ) {=0A=
		return 1 - Math.cos( p * Math.PI / 2 );=0A=
	},=0A=
	Circ: function( p ) {=0A=
		return 1 - Math.sqrt( 1 - p * p );=0A=
	},=0A=
	Elastic: function( p ) {=0A=
		return p =3D=3D=3D 0 || p =3D=3D=3D 1 ? p :=0A=
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * =
Math.PI / 15 );=0A=
	},=0A=
	Back: function( p ) {=0A=
		return p * p * ( 3 * p - 2 );=0A=
	},=0A=
	Bounce: function( p ) {=0A=
		var pow2,=0A=
			bounce =3D 4;=0A=
=0A=
		while ( p < ( ( pow2 =3D Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}=0A=
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - =
2 ) / 22 - p, 2 );=0A=
	}=0A=
});=0A=
=0A=
$.each( baseEasings, function( name, easeIn ) {=0A=
	$.easing[ "easeIn" + name ] =3D easeIn;=0A=
	$.easing[ "easeOut" + name ] =3D function( p ) {=0A=
		return 1 - easeIn( 1 - p );=0A=
	};=0A=
	$.easing[ "easeInOut" + name ] =3D function( p ) {=0A=
		return p < 0.5 ?=0A=
			easeIn( p * 2 ) / 2 :=0A=
			1 - easeIn( p * -2 + 2 ) / 2;=0A=
	};=0A=
});=0A=
=0A=
})();=0A=
=0A=
var effect =3D $.effects;=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Blind 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/blind-effect/=0A=
 */=0A=
=0A=
=0A=
var effectBlind =3D $.effects.effect.blind =3D function( o, done ) {=0A=
	// Create element=0A=
	var el =3D $( this ),=0A=
		rvertical =3D /up|down|vertical/,=0A=
		rpositivemotion =3D /up|left|vertical|horizontal/,=0A=
		props =3D [ "position", "top", "bottom", "left", "right", "height", =
"width" ],=0A=
		mode =3D $.effects.setMode( el, o.mode || "hide" ),=0A=
		direction =3D o.direction || "up",=0A=
		vertical =3D rvertical.test( direction ),=0A=
		ref =3D vertical ? "height" : "width",=0A=
		ref2 =3D vertical ? "top" : "left",=0A=
		motion =3D rpositivemotion.test( direction ),=0A=
		animation =3D {},=0A=
		show =3D mode =3D=3D=3D "show",=0A=
		wrapper, distance, margin;=0A=
=0A=
	// if already wrapped, the wrapper's properties are my property. #6245=0A=
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {=0A=
		$.effects.save( el.parent(), props );=0A=
	} else {=0A=
		$.effects.save( el, props );=0A=
	}=0A=
	el.show();=0A=
	wrapper =3D $.effects.createWrapper( el ).css({=0A=
		overflow: "hidden"=0A=
	});=0A=
=0A=
	distance =3D wrapper[ ref ]();=0A=
	margin =3D parseFloat( wrapper.css( ref2 ) ) || 0;=0A=
=0A=
	animation[ ref ] =3D show ? distance : 0;=0A=
	if ( !motion ) {=0A=
		el=0A=
			.css( vertical ? "bottom" : "right", 0 )=0A=
			.css( vertical ? "top" : "left", "auto" )=0A=
			.css({ position: "absolute" });=0A=
=0A=
		animation[ ref2 ] =3D show ? margin : distance + margin;=0A=
	}=0A=
=0A=
	// start at 0 if we are showing=0A=
	if ( show ) {=0A=
		wrapper.css( ref, 0 );=0A=
		if ( !motion ) {=0A=
			wrapper.css( ref2, margin + distance );=0A=
		}=0A=
	}=0A=
=0A=
	// Animate=0A=
	wrapper.animate( animation, {=0A=
		duration: o.duration,=0A=
		easing: o.easing,=0A=
		queue: false,=0A=
		complete: function() {=0A=
			if ( mode =3D=3D=3D "hide" ) {=0A=
				el.hide();=0A=
			}=0A=
			$.effects.restore( el, props );=0A=
			$.effects.removeWrapper( el );=0A=
			done();=0A=
		}=0A=
	});=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Bounce 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/bounce-effect/=0A=
 */=0A=
=0A=
=0A=
var effectBounce =3D $.effects.effect.bounce =3D function( o, done ) {=0A=
	var el =3D $( this ),=0A=
		props =3D [ "position", "top", "bottom", "left", "right", "height", =
"width" ],=0A=
=0A=
		// defaults:=0A=
		mode =3D $.effects.setMode( el, o.mode || "effect" ),=0A=
		hide =3D mode =3D=3D=3D "hide",=0A=
		show =3D mode =3D=3D=3D "show",=0A=
		direction =3D o.direction || "up",=0A=
		distance =3D o.distance,=0A=
		times =3D o.times || 5,=0A=
=0A=
		// number of internal animations=0A=
		anims =3D times * 2 + ( show || hide ? 1 : 0 ),=0A=
		speed =3D o.duration / anims,=0A=
		easing =3D o.easing,=0A=
=0A=
		// utility:=0A=
		ref =3D ( direction =3D=3D=3D "up" || direction =3D=3D=3D "down" ) ? =
"top" : "left",=0A=
		motion =3D ( direction =3D=3D=3D "up" || direction =3D=3D=3D "left" ),=0A=
		i,=0A=
		upAnim,=0A=
		downAnim,=0A=
=0A=
		// we will need to re-assemble the queue to stack our animations in =
place=0A=
		queue =3D el.queue(),=0A=
		queuelen =3D queue.length;=0A=
=0A=
	// Avoid touching opacity to prevent clearType and PNG issues in IE=0A=
	if ( show || hide ) {=0A=
		props.push( "opacity" );=0A=
	}=0A=
=0A=
	$.effects.save( el, props );=0A=
	el.show();=0A=
	$.effects.createWrapper( el ); // Create Wrapper=0A=
=0A=
	// default distance for the BIGGEST bounce is the outer Distance / 3=0A=
	if ( !distance ) {=0A=
		distance =3D el[ ref =3D=3D=3D "top" ? "outerHeight" : "outerWidth" =
]() / 3;=0A=
	}=0A=
=0A=
	if ( show ) {=0A=
		downAnim =3D { opacity: 1 };=0A=
		downAnim[ ref ] =3D 0;=0A=
=0A=
		// if we are showing, force opacity 0 and set the initial position=0A=
		// then do the "first" animation=0A=
		el.css( "opacity", 0 )=0A=
			.css( ref, motion ? -distance * 2 : distance * 2 )=0A=
			.animate( downAnim, speed, easing );=0A=
	}=0A=
=0A=
	// start at the smallest distance if we are hiding=0A=
	if ( hide ) {=0A=
		distance =3D distance / Math.pow( 2, times - 1 );=0A=
	}=0A=
=0A=
	downAnim =3D {};=0A=
	downAnim[ ref ] =3D 0;=0A=
	// Bounces up/down/left/right then back to 0 -- times * 2 animations =
happen here=0A=
	for ( i =3D 0; i < times; i++ ) {=0A=
		upAnim =3D {};=0A=
		upAnim[ ref ] =3D ( motion ? "-=3D" : "+=3D" ) + distance;=0A=
=0A=
		el.animate( upAnim, speed, easing )=0A=
			.animate( downAnim, speed, easing );=0A=
=0A=
		distance =3D hide ? distance * 2 : distance / 2;=0A=
	}=0A=
=0A=
	// Last Bounce when Hiding=0A=
	if ( hide ) {=0A=
		upAnim =3D { opacity: 0 };=0A=
		upAnim[ ref ] =3D ( motion ? "-=3D" : "+=3D" ) + distance;=0A=
=0A=
		el.animate( upAnim, speed, easing );=0A=
	}=0A=
=0A=
	el.queue(function() {=0A=
		if ( hide ) {=0A=
			el.hide();=0A=
		}=0A=
		$.effects.restore( el, props );=0A=
		$.effects.removeWrapper( el );=0A=
		done();=0A=
	});=0A=
=0A=
	// inject all the animations we just queued to be first in line (after =
"inprogress")=0A=
	if ( queuelen > 1) {=0A=
		queue.splice.apply( queue,=0A=
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );=0A=
	}=0A=
	el.dequeue();=0A=
=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Clip 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/clip-effect/=0A=
 */=0A=
=0A=
=0A=
var effectClip =3D $.effects.effect.clip =3D function( o, done ) {=0A=
	// Create element=0A=
	var el =3D $( this ),=0A=
		props =3D [ "position", "top", "bottom", "left", "right", "height", =
"width" ],=0A=
		mode =3D $.effects.setMode( el, o.mode || "hide" ),=0A=
		show =3D mode =3D=3D=3D "show",=0A=
		direction =3D o.direction || "vertical",=0A=
		vert =3D direction =3D=3D=3D "vertical",=0A=
		size =3D vert ? "height" : "width",=0A=
		position =3D vert ? "top" : "left",=0A=
		animation =3D {},=0A=
		wrapper, animate, distance;=0A=
=0A=
	// Save & Show=0A=
	$.effects.save( el, props );=0A=
	el.show();=0A=
=0A=
	// Create Wrapper=0A=
	wrapper =3D $.effects.createWrapper( el ).css({=0A=
		overflow: "hidden"=0A=
	});=0A=
	animate =3D ( el[0].tagName =3D=3D=3D "IMG" ) ? wrapper : el;=0A=
	distance =3D animate[ size ]();=0A=
=0A=
	// Shift=0A=
	if ( show ) {=0A=
		animate.css( size, 0 );=0A=
		animate.css( position, distance / 2 );=0A=
	}=0A=
=0A=
	// Create Animation Object:=0A=
	animation[ size ] =3D show ? distance : 0;=0A=
	animation[ position ] =3D show ? 0 : distance / 2;=0A=
=0A=
	// Animate=0A=
	animate.animate( animation, {=0A=
		queue: false,=0A=
		duration: o.duration,=0A=
		easing: o.easing,=0A=
		complete: function() {=0A=
			if ( !show ) {=0A=
				el.hide();=0A=
			}=0A=
			$.effects.restore( el, props );=0A=
			$.effects.removeWrapper( el );=0A=
			done();=0A=
		}=0A=
	});=0A=
=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Drop 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/drop-effect/=0A=
 */=0A=
=0A=
=0A=
var effectDrop =3D $.effects.effect.drop =3D function( o, done ) {=0A=
=0A=
	var el =3D $( this ),=0A=
		props =3D [ "position", "top", "bottom", "left", "right", "opacity", =
"height", "width" ],=0A=
		mode =3D $.effects.setMode( el, o.mode || "hide" ),=0A=
		show =3D mode =3D=3D=3D "show",=0A=
		direction =3D o.direction || "left",=0A=
		ref =3D ( direction =3D=3D=3D "up" || direction =3D=3D=3D "down" ) ? =
"top" : "left",=0A=
		motion =3D ( direction =3D=3D=3D "up" || direction =3D=3D=3D "left" ) =
? "pos" : "neg",=0A=
		animation =3D {=0A=
			opacity: show ? 1 : 0=0A=
		},=0A=
		distance;=0A=
=0A=
	// Adjust=0A=
	$.effects.save( el, props );=0A=
	el.show();=0A=
	$.effects.createWrapper( el );=0A=
=0A=
	distance =3D o.distance || el[ ref =3D=3D=3D "top" ? "outerHeight": =
"outerWidth" ]( true ) / 2;=0A=
=0A=
	if ( show ) {=0A=
		el=0A=
			.css( "opacity", 0 )=0A=
			.css( ref, motion =3D=3D=3D "pos" ? -distance : distance );=0A=
	}=0A=
=0A=
	// Animation=0A=
	animation[ ref ] =3D ( show ?=0A=
		( motion =3D=3D=3D "pos" ? "+=3D" : "-=3D" ) :=0A=
		( motion =3D=3D=3D "pos" ? "-=3D" : "+=3D" ) ) +=0A=
		distance;=0A=
=0A=
	// Animate=0A=
	el.animate( animation, {=0A=
		queue: false,=0A=
		duration: o.duration,=0A=
		easing: o.easing,=0A=
		complete: function() {=0A=
			if ( mode =3D=3D=3D "hide" ) {=0A=
				el.hide();=0A=
			}=0A=
			$.effects.restore( el, props );=0A=
			$.effects.removeWrapper( el );=0A=
			done();=0A=
		}=0A=
	});=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Explode 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/explode-effect/=0A=
 */=0A=
=0A=
=0A=
var effectExplode =3D $.effects.effect.explode =3D function( o, done ) {=0A=
=0A=
	var rows =3D o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,=0A=
		cells =3D rows,=0A=
		el =3D $( this ),=0A=
		mode =3D $.effects.setMode( el, o.mode || "hide" ),=0A=
		show =3D mode =3D=3D=3D "show",=0A=
=0A=
		// show and then visibility:hidden the element before calculating =
offset=0A=
		offset =3D el.show().css( "visibility", "hidden" ).offset(),=0A=
=0A=
		// width and height of a piece=0A=
		width =3D Math.ceil( el.outerWidth() / cells ),=0A=
		height =3D Math.ceil( el.outerHeight() / rows ),=0A=
		pieces =3D [],=0A=
=0A=
		// loop=0A=
		i, j, left, top, mx, my;=0A=
=0A=
	// children animate complete:=0A=
	function childComplete() {=0A=
		pieces.push( this );=0A=
		if ( pieces.length =3D=3D=3D rows * cells ) {=0A=
			animComplete();=0A=
		}=0A=
	}=0A=
=0A=
	// clone the element for each row and cell.=0A=
	for ( i =3D 0; i < rows ; i++ ) { // =3D=3D=3D>=0A=
		top =3D offset.top + i * height;=0A=
		my =3D i - ( rows - 1 ) / 2 ;=0A=
=0A=
		for ( j =3D 0; j < cells ; j++ ) { // |||=0A=
			left =3D offset.left + j * width;=0A=
			mx =3D j - ( cells - 1 ) / 2 ;=0A=
=0A=
			// Create a clone of the now hidden main element that will be =
absolute positioned=0A=
			// within a wrapper div off the -left and -top equal to size of our =
pieces=0A=
			el=0A=
				.clone()=0A=
				.appendTo( "body" )=0A=
				.wrap( "<div></div>" )=0A=
				.css({=0A=
					position: "absolute",=0A=
					visibility: "visible",=0A=
					left: -j * width,=0A=
					top: -i * height=0A=
				})=0A=
=0A=
			// select the wrapper - make it overflow: hidden and absolute =
positioned based on=0A=
			// where the original was located +left and +top equal to the size of =
pieces=0A=
				.parent()=0A=
				.addClass( "ui-effects-explode" )=0A=
				.css({=0A=
					position: "absolute",=0A=
					overflow: "hidden",=0A=
					width: width,=0A=
					height: height,=0A=
					left: left + ( show ? mx * width : 0 ),=0A=
					top: top + ( show ? my * height : 0 ),=0A=
					opacity: show ? 0 : 1=0A=
				}).animate({=0A=
					left: left + ( show ? 0 : mx * width ),=0A=
					top: top + ( show ? 0 : my * height ),=0A=
					opacity: show ? 1 : 0=0A=
				}, o.duration || 500, o.easing, childComplete );=0A=
		}=0A=
	}=0A=
=0A=
	function animComplete() {=0A=
		el.css({=0A=
			visibility: "visible"=0A=
		});=0A=
		$( pieces ).remove();=0A=
		if ( !show ) {=0A=
			el.hide();=0A=
		}=0A=
		done();=0A=
	}=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Fade 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/fade-effect/=0A=
 */=0A=
=0A=
=0A=
var effectFade =3D $.effects.effect.fade =3D function( o, done ) {=0A=
	var el =3D $( this ),=0A=
		mode =3D $.effects.setMode( el, o.mode || "toggle" );=0A=
=0A=
	el.animate({=0A=
		opacity: mode=0A=
	}, {=0A=
		queue: false,=0A=
		duration: o.duration,=0A=
		easing: o.easing,=0A=
		complete: done=0A=
	});=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Fold 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/fold-effect/=0A=
 */=0A=
=0A=
=0A=
var effectFold =3D $.effects.effect.fold =3D function( o, done ) {=0A=
=0A=
	// Create element=0A=
	var el =3D $( this ),=0A=
		props =3D [ "position", "top", "bottom", "left", "right", "height", =
"width" ],=0A=
		mode =3D $.effects.setMode( el, o.mode || "hide" ),=0A=
		show =3D mode =3D=3D=3D "show",=0A=
		hide =3D mode =3D=3D=3D "hide",=0A=
		size =3D o.size || 15,=0A=
		percent =3D /([0-9]+)%/.exec( size ),=0A=
		horizFirst =3D !!o.horizFirst,=0A=
		widthFirst =3D show !=3D=3D horizFirst,=0A=
		ref =3D widthFirst ? [ "width", "height" ] : [ "height", "width" ],=0A=
		duration =3D o.duration / 2,=0A=
		wrapper, distance,=0A=
		animation1 =3D {},=0A=
		animation2 =3D {};=0A=
=0A=
	$.effects.save( el, props );=0A=
	el.show();=0A=
=0A=
	// Create Wrapper=0A=
	wrapper =3D $.effects.createWrapper( el ).css({=0A=
		overflow: "hidden"=0A=
	});=0A=
	distance =3D widthFirst ?=0A=
		[ wrapper.width(), wrapper.height() ] :=0A=
		[ wrapper.height(), wrapper.width() ];=0A=
=0A=
	if ( percent ) {=0A=
		size =3D parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];=0A=
	}=0A=
	if ( show ) {=0A=
		wrapper.css( horizFirst ? {=0A=
			height: 0,=0A=
			width: size=0A=
		} : {=0A=
			height: size,=0A=
			width: 0=0A=
		});=0A=
	}=0A=
=0A=
	// Animation=0A=
	animation1[ ref[ 0 ] ] =3D show ? distance[ 0 ] : size;=0A=
	animation2[ ref[ 1 ] ] =3D show ? distance[ 1 ] : 0;=0A=
=0A=
	// Animate=0A=
	wrapper=0A=
		.animate( animation1, duration, o.easing )=0A=
		.animate( animation2, duration, o.easing, function() {=0A=
			if ( hide ) {=0A=
				el.hide();=0A=
			}=0A=
			$.effects.restore( el, props );=0A=
			$.effects.removeWrapper( el );=0A=
			done();=0A=
		});=0A=
=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Highlight 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/highlight-effect/=0A=
 */=0A=
=0A=
=0A=
var effectHighlight =3D $.effects.effect.highlight =3D function( o, done =
) {=0A=
	var elem =3D $( this ),=0A=
		props =3D [ "backgroundImage", "backgroundColor", "opacity" ],=0A=
		mode =3D $.effects.setMode( elem, o.mode || "show" ),=0A=
		animation =3D {=0A=
			backgroundColor: elem.css( "backgroundColor" )=0A=
		};=0A=
=0A=
	if (mode =3D=3D=3D "hide") {=0A=
		animation.opacity =3D 0;=0A=
	}=0A=
=0A=
	$.effects.save( elem, props );=0A=
=0A=
	elem=0A=
		.show()=0A=
		.css({=0A=
			backgroundImage: "none",=0A=
			backgroundColor: o.color || "#ffff99"=0A=
		})=0A=
		.animate( animation, {=0A=
			queue: false,=0A=
			duration: o.duration,=0A=
			easing: o.easing,=0A=
			complete: function() {=0A=
				if ( mode =3D=3D=3D "hide" ) {=0A=
					elem.hide();=0A=
				}=0A=
				$.effects.restore( elem, props );=0A=
				done();=0A=
			}=0A=
		});=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Size 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/size-effect/=0A=
 */=0A=
=0A=
=0A=
var effectSize =3D $.effects.effect.size =3D function( o, done ) {=0A=
=0A=
	// Create element=0A=
	var original, baseline, factor,=0A=
		el =3D $( this ),=0A=
		props0 =3D [ "position", "top", "bottom", "left", "right", "width", =
"height", "overflow", "opacity" ],=0A=
=0A=
		// Always restore=0A=
		props1 =3D [ "position", "top", "bottom", "left", "right", "overflow", =
"opacity" ],=0A=
=0A=
		// Copy for children=0A=
		props2 =3D [ "width", "height", "overflow" ],=0A=
		cProps =3D [ "fontSize" ],=0A=
		vProps =3D [ "borderTopWidth", "borderBottomWidth", "paddingTop", =
"paddingBottom" ],=0A=
		hProps =3D [ "borderLeftWidth", "borderRightWidth", "paddingLeft", =
"paddingRight" ],=0A=
=0A=
		// Set options=0A=
		mode =3D $.effects.setMode( el, o.mode || "effect" ),=0A=
		restore =3D o.restore || mode !=3D=3D "effect",=0A=
		scale =3D o.scale || "both",=0A=
		origin =3D o.origin || [ "middle", "center" ],=0A=
		position =3D el.css( "position" ),=0A=
		props =3D restore ? props0 : props1,=0A=
		zero =3D {=0A=
			height: 0,=0A=
			width: 0,=0A=
			outerHeight: 0,=0A=
			outerWidth: 0=0A=
		};=0A=
=0A=
	if ( mode =3D=3D=3D "show" ) {=0A=
		el.show();=0A=
	}=0A=
	original =3D {=0A=
		height: el.height(),=0A=
		width: el.width(),=0A=
		outerHeight: el.outerHeight(),=0A=
		outerWidth: el.outerWidth()=0A=
	};=0A=
=0A=
	if ( o.mode =3D=3D=3D "toggle" && mode =3D=3D=3D "show" ) {=0A=
		el.from =3D o.to || zero;=0A=
		el.to =3D o.from || original;=0A=
	} else {=0A=
		el.from =3D o.from || ( mode =3D=3D=3D "show" ? zero : original );=0A=
		el.to =3D o.to || ( mode =3D=3D=3D "hide" ? zero : original );=0A=
	}=0A=
=0A=
	// Set scaling factor=0A=
	factor =3D {=0A=
		from: {=0A=
			y: el.from.height / original.height,=0A=
			x: el.from.width / original.width=0A=
		},=0A=
		to: {=0A=
			y: el.to.height / original.height,=0A=
			x: el.to.width / original.width=0A=
		}=0A=
	};=0A=
=0A=
	// Scale the css box=0A=
	if ( scale =3D=3D=3D "box" || scale =3D=3D=3D "both" ) {=0A=
=0A=
		// Vertical props scaling=0A=
		if ( factor.from.y !=3D=3D factor.to.y ) {=0A=
			props =3D props.concat( vProps );=0A=
			el.from =3D $.effects.setTransition( el, vProps, factor.from.y, =
el.from );=0A=
			el.to =3D $.effects.setTransition( el, vProps, factor.to.y, el.to );=0A=
		}=0A=
=0A=
		// Horizontal props scaling=0A=
		if ( factor.from.x !=3D=3D factor.to.x ) {=0A=
			props =3D props.concat( hProps );=0A=
			el.from =3D $.effects.setTransition( el, hProps, factor.from.x, =
el.from );=0A=
			el.to =3D $.effects.setTransition( el, hProps, factor.to.x, el.to );=0A=
		}=0A=
	}=0A=
=0A=
	// Scale the content=0A=
	if ( scale =3D=3D=3D "content" || scale =3D=3D=3D "both" ) {=0A=
=0A=
		// Vertical props scaling=0A=
		if ( factor.from.y !=3D=3D factor.to.y ) {=0A=
			props =3D props.concat( cProps ).concat( props2 );=0A=
			el.from =3D $.effects.setTransition( el, cProps, factor.from.y, =
el.from );=0A=
			el.to =3D $.effects.setTransition( el, cProps, factor.to.y, el.to );=0A=
		}=0A=
	}=0A=
=0A=
	$.effects.save( el, props );=0A=
	el.show();=0A=
	$.effects.createWrapper( el );=0A=
	el.css( "overflow", "hidden" ).css( el.from );=0A=
=0A=
	// Adjust=0A=
	if (origin) { // Calculate baseline shifts=0A=
		baseline =3D $.effects.getBaseline( origin, original );=0A=
		el.from.top =3D ( original.outerHeight - el.outerHeight() ) * =
baseline.y;=0A=
		el.from.left =3D ( original.outerWidth - el.outerWidth() ) * =
baseline.x;=0A=
		el.to.top =3D ( original.outerHeight - el.to.outerHeight ) * =
baseline.y;=0A=
		el.to.left =3D ( original.outerWidth - el.to.outerWidth ) * baseline.x;=0A=
	}=0A=
	el.css( el.from ); // set top & left=0A=
=0A=
	// Animate=0A=
	if ( scale =3D=3D=3D "content" || scale =3D=3D=3D "both" ) { // Scale =
the children=0A=
=0A=
		// Add margins/font-size=0A=
		vProps =3D vProps.concat([ "marginTop", "marginBottom" =
]).concat(cProps);=0A=
		hProps =3D hProps.concat([ "marginLeft", "marginRight" ]);=0A=
		props2 =3D props0.concat(vProps).concat(hProps);=0A=
=0A=
		el.find( "*[width]" ).each( function() {=0A=
			var child =3D $( this ),=0A=
				c_original =3D {=0A=
					height: child.height(),=0A=
					width: child.width(),=0A=
					outerHeight: child.outerHeight(),=0A=
					outerWidth: child.outerWidth()=0A=
				};=0A=
			if (restore) {=0A=
				$.effects.save(child, props2);=0A=
			}=0A=
=0A=
			child.from =3D {=0A=
				height: c_original.height * factor.from.y,=0A=
				width: c_original.width * factor.from.x,=0A=
				outerHeight: c_original.outerHeight * factor.from.y,=0A=
				outerWidth: c_original.outerWidth * factor.from.x=0A=
			};=0A=
			child.to =3D {=0A=
				height: c_original.height * factor.to.y,=0A=
				width: c_original.width * factor.to.x,=0A=
				outerHeight: c_original.height * factor.to.y,=0A=
				outerWidth: c_original.width * factor.to.x=0A=
			};=0A=
=0A=
			// Vertical props scaling=0A=
			if ( factor.from.y !=3D=3D factor.to.y ) {=0A=
				child.from =3D $.effects.setTransition( child, vProps, =
factor.from.y, child.from );=0A=
				child.to =3D $.effects.setTransition( child, vProps, factor.to.y, =
child.to );=0A=
			}=0A=
=0A=
			// Horizontal props scaling=0A=
			if ( factor.from.x !=3D=3D factor.to.x ) {=0A=
				child.from =3D $.effects.setTransition( child, hProps, =
factor.from.x, child.from );=0A=
				child.to =3D $.effects.setTransition( child, hProps, factor.to.x, =
child.to );=0A=
			}=0A=
=0A=
			// Animate children=0A=
			child.css( child.from );=0A=
			child.animate( child.to, o.duration, o.easing, function() {=0A=
=0A=
				// Restore children=0A=
				if ( restore ) {=0A=
					$.effects.restore( child, props2 );=0A=
				}=0A=
			});=0A=
		});=0A=
	}=0A=
=0A=
	// Animate=0A=
	el.animate( el.to, {=0A=
		queue: false,=0A=
		duration: o.duration,=0A=
		easing: o.easing,=0A=
		complete: function() {=0A=
			if ( el.to.opacity =3D=3D=3D 0 ) {=0A=
				el.css( "opacity", el.from.opacity );=0A=
			}=0A=
			if ( mode =3D=3D=3D "hide" ) {=0A=
				el.hide();=0A=
			}=0A=
			$.effects.restore( el, props );=0A=
			if ( !restore ) {=0A=
=0A=
				// we need to calculate our new positioning based on the scaling=0A=
				if ( position =3D=3D=3D "static" ) {=0A=
					el.css({=0A=
						position: "relative",=0A=
						top: el.to.top,=0A=
						left: el.to.left=0A=
					});=0A=
				} else {=0A=
					$.each([ "top", "left" ], function( idx, pos ) {=0A=
						el.css( pos, function( _, str ) {=0A=
							var val =3D parseInt( str, 10 ),=0A=
								toRef =3D idx ? el.to.left : el.to.top;=0A=
=0A=
							// if original was "auto", recalculate the new value from wrapper=0A=
							if ( str =3D=3D=3D "auto" ) {=0A=
								return toRef + "px";=0A=
							}=0A=
=0A=
							return val + toRef + "px";=0A=
						});=0A=
					});=0A=
				}=0A=
			}=0A=
=0A=
			$.effects.removeWrapper( el );=0A=
			done();=0A=
		}=0A=
	});=0A=
=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Scale 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/scale-effect/=0A=
 */=0A=
=0A=
=0A=
var effectScale =3D $.effects.effect.scale =3D function( o, done ) {=0A=
=0A=
	// Create element=0A=
	var el =3D $( this ),=0A=
		options =3D $.extend( true, {}, o ),=0A=
		mode =3D $.effects.setMode( el, o.mode || "effect" ),=0A=
		percent =3D parseInt( o.percent, 10 ) ||=0A=
			( parseInt( o.percent, 10 ) =3D=3D=3D 0 ? 0 : ( mode =3D=3D=3D "hide" =
? 0 : 100 ) ),=0A=
		direction =3D o.direction || "both",=0A=
		origin =3D o.origin,=0A=
		original =3D {=0A=
			height: el.height(),=0A=
			width: el.width(),=0A=
			outerHeight: el.outerHeight(),=0A=
			outerWidth: el.outerWidth()=0A=
		},=0A=
		factor =3D {=0A=
			y: direction !=3D=3D "horizontal" ? (percent / 100) : 1,=0A=
			x: direction !=3D=3D "vertical" ? (percent / 100) : 1=0A=
		};=0A=
=0A=
	// We are going to pass this effect to the size effect:=0A=
	options.effect =3D "size";=0A=
	options.queue =3D false;=0A=
	options.complete =3D done;=0A=
=0A=
	// Set default origin and restore for show/hide=0A=
	if ( mode !=3D=3D "effect" ) {=0A=
		options.origin =3D origin || [ "middle", "center" ];=0A=
		options.restore =3D true;=0A=
	}=0A=
=0A=
	options.from =3D o.from || ( mode =3D=3D=3D "show" ? {=0A=
		height: 0,=0A=
		width: 0,=0A=
		outerHeight: 0,=0A=
		outerWidth: 0=0A=
	} : original );=0A=
	options.to =3D {=0A=
		height: original.height * factor.y,=0A=
		width: original.width * factor.x,=0A=
		outerHeight: original.outerHeight * factor.y,=0A=
		outerWidth: original.outerWidth * factor.x=0A=
	};=0A=
=0A=
	// Fade option to support puff=0A=
	if ( options.fade ) {=0A=
		if ( mode =3D=3D=3D "show" ) {=0A=
			options.from.opacity =3D 0;=0A=
			options.to.opacity =3D 1;=0A=
		}=0A=
		if ( mode =3D=3D=3D "hide" ) {=0A=
			options.from.opacity =3D 1;=0A=
			options.to.opacity =3D 0;=0A=
		}=0A=
	}=0A=
=0A=
	// Animate=0A=
	el.effect( options );=0A=
=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Puff 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/puff-effect/=0A=
 */=0A=
=0A=
=0A=
var effectPuff =3D $.effects.effect.puff =3D function( o, done ) {=0A=
	var elem =3D $( this ),=0A=
		mode =3D $.effects.setMode( elem, o.mode || "hide" ),=0A=
		hide =3D mode =3D=3D=3D "hide",=0A=
		percent =3D parseInt( o.percent, 10 ) || 150,=0A=
		factor =3D percent / 100,=0A=
		original =3D {=0A=
			height: elem.height(),=0A=
			width: elem.width(),=0A=
			outerHeight: elem.outerHeight(),=0A=
			outerWidth: elem.outerWidth()=0A=
		};=0A=
=0A=
	$.extend( o, {=0A=
		effect: "scale",=0A=
		queue: false,=0A=
		fade: true,=0A=
		mode: mode,=0A=
		complete: done,=0A=
		percent: hide ? percent : 100,=0A=
		from: hide ?=0A=
			original :=0A=
			{=0A=
				height: original.height * factor,=0A=
				width: original.width * factor,=0A=
				outerHeight: original.outerHeight * factor,=0A=
				outerWidth: original.outerWidth * factor=0A=
			}=0A=
	});=0A=
=0A=
	elem.effect( o );=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Pulsate 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/pulsate-effect/=0A=
 */=0A=
=0A=
=0A=
var effectPulsate =3D $.effects.effect.pulsate =3D function( o, done ) {=0A=
	var elem =3D $( this ),=0A=
		mode =3D $.effects.setMode( elem, o.mode || "show" ),=0A=
		show =3D mode =3D=3D=3D "show",=0A=
		hide =3D mode =3D=3D=3D "hide",=0A=
		showhide =3D ( show || mode =3D=3D=3D "hide" ),=0A=
=0A=
		// showing or hiding leaves of the "last" animation=0A=
		anims =3D ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),=0A=
		duration =3D o.duration / anims,=0A=
		animateTo =3D 0,=0A=
		queue =3D elem.queue(),=0A=
		queuelen =3D queue.length,=0A=
		i;=0A=
=0A=
	if ( show || !elem.is(":visible")) {=0A=
		elem.css( "opacity", 0 ).show();=0A=
		animateTo =3D 1;=0A=
	}=0A=
=0A=
	// anims - 1 opacity "toggles"=0A=
	for ( i =3D 1; i < anims; i++ ) {=0A=
		elem.animate({=0A=
			opacity: animateTo=0A=
		}, duration, o.easing );=0A=
		animateTo =3D 1 - animateTo;=0A=
	}=0A=
=0A=
	elem.animate({=0A=
		opacity: animateTo=0A=
	}, duration, o.easing);=0A=
=0A=
	elem.queue(function() {=0A=
		if ( hide ) {=0A=
			elem.hide();=0A=
		}=0A=
		done();=0A=
	});=0A=
=0A=
	// We just queued up "anims" animations, we need to put them next in =
the queue=0A=
	if ( queuelen > 1 ) {=0A=
		queue.splice.apply( queue,=0A=
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );=0A=
	}=0A=
	elem.dequeue();=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Shake 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/shake-effect/=0A=
 */=0A=
=0A=
=0A=
var effectShake =3D $.effects.effect.shake =3D function( o, done ) {=0A=
=0A=
	var el =3D $( this ),=0A=
		props =3D [ "position", "top", "bottom", "left", "right", "height", =
"width" ],=0A=
		mode =3D $.effects.setMode( el, o.mode || "effect" ),=0A=
		direction =3D o.direction || "left",=0A=
		distance =3D o.distance || 20,=0A=
		times =3D o.times || 3,=0A=
		anims =3D times * 2 + 1,=0A=
		speed =3D Math.round( o.duration / anims ),=0A=
		ref =3D (direction =3D=3D=3D "up" || direction =3D=3D=3D "down") ? =
"top" : "left",=0A=
		positiveMotion =3D (direction =3D=3D=3D "up" || direction =3D=3D=3D =
"left"),=0A=
		animation =3D {},=0A=
		animation1 =3D {},=0A=
		animation2 =3D {},=0A=
		i,=0A=
=0A=
		// we will need to re-assemble the queue to stack our animations in =
place=0A=
		queue =3D el.queue(),=0A=
		queuelen =3D queue.length;=0A=
=0A=
	$.effects.save( el, props );=0A=
	el.show();=0A=
	$.effects.createWrapper( el );=0A=
=0A=
	// Animation=0A=
	animation[ ref ] =3D ( positiveMotion ? "-=3D" : "+=3D" ) + distance;=0A=
	animation1[ ref ] =3D ( positiveMotion ? "+=3D" : "-=3D" ) + distance * =
2;=0A=
	animation2[ ref ] =3D ( positiveMotion ? "-=3D" : "+=3D" ) + distance * =
2;=0A=
=0A=
	// Animate=0A=
	el.animate( animation, speed, o.easing );=0A=
=0A=
	// Shakes=0A=
	for ( i =3D 1; i < times; i++ ) {=0A=
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, =
o.easing );=0A=
	}=0A=
	el=0A=
		.animate( animation1, speed, o.easing )=0A=
		.animate( animation, speed / 2, o.easing )=0A=
		.queue(function() {=0A=
			if ( mode =3D=3D=3D "hide" ) {=0A=
				el.hide();=0A=
			}=0A=
			$.effects.restore( el, props );=0A=
			$.effects.removeWrapper( el );=0A=
			done();=0A=
		});=0A=
=0A=
	// inject all the animations we just queued to be first in line (after =
"inprogress")=0A=
	if ( queuelen > 1) {=0A=
		queue.splice.apply( queue,=0A=
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );=0A=
	}=0A=
	el.dequeue();=0A=
=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Slide 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/slide-effect/=0A=
 */=0A=
=0A=
=0A=
var effectSlide =3D $.effects.effect.slide =3D function( o, done ) {=0A=
=0A=
	// Create element=0A=
	var el =3D $( this ),=0A=
		props =3D [ "position", "top", "bottom", "left", "right", "width", =
"height" ],=0A=
		mode =3D $.effects.setMode( el, o.mode || "show" ),=0A=
		show =3D mode =3D=3D=3D "show",=0A=
		direction =3D o.direction || "left",=0A=
		ref =3D (direction =3D=3D=3D "up" || direction =3D=3D=3D "down") ? =
"top" : "left",=0A=
		positiveMotion =3D (direction =3D=3D=3D "up" || direction =3D=3D=3D =
"left"),=0A=
		distance,=0A=
		animation =3D {};=0A=
=0A=
	// Adjust=0A=
	$.effects.save( el, props );=0A=
	el.show();=0A=
	distance =3D o.distance || el[ ref =3D=3D=3D "top" ? "outerHeight" : =
"outerWidth" ]( true );=0A=
=0A=
	$.effects.createWrapper( el ).css({=0A=
		overflow: "hidden"=0A=
	});=0A=
=0A=
	if ( show ) {=0A=
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : =
-distance) : distance );=0A=
	}=0A=
=0A=
	// Animation=0A=
	animation[ ref ] =3D ( show ?=0A=
		( positiveMotion ? "+=3D" : "-=3D") :=0A=
		( positiveMotion ? "-=3D" : "+=3D")) +=0A=
		distance;=0A=
=0A=
	// Animate=0A=
	el.animate( animation, {=0A=
		queue: false,=0A=
		duration: o.duration,=0A=
		easing: o.easing,=0A=
		complete: function() {=0A=
			if ( mode =3D=3D=3D "hide" ) {=0A=
				el.hide();=0A=
			}=0A=
			$.effects.restore( el, props );=0A=
			$.effects.removeWrapper( el );=0A=
			done();=0A=
		}=0A=
	});=0A=
};=0A=
=0A=
=0A=
/*!=0A=
 * jQuery UI Effects Transfer 1.11.1=0A=
 * http://jqueryui.com=0A=
 *=0A=
 * Copyright 2014 jQuery Foundation and other contributors=0A=
 * Released under the MIT license.=0A=
 * http://jquery.org/license=0A=
 *=0A=
 * http://api.jqueryui.com/transfer-effect/=0A=
 */=0A=
=0A=
=0A=
var effectTransfer =3D $.effects.effect.transfer =3D function( o, done ) =
{=0A=
	var elem =3D $( this ),=0A=
		target =3D $( o.to ),=0A=
		targetFixed =3D target.css( "position" ) =3D=3D=3D "fixed",=0A=
		body =3D $("body"),=0A=
		fixTop =3D targetFixed ? body.scrollTop() : 0,=0A=
		fixLeft =3D targetFixed ? body.scrollLeft() : 0,=0A=
		endPosition =3D target.offset(),=0A=
		animation =3D {=0A=
			top: endPosition.top - fixTop,=0A=
			left: endPosition.left - fixLeft,=0A=
			height: target.innerHeight(),=0A=
			width: target.innerWidth()=0A=
		},=0A=
		startPosition =3D elem.offset(),=0A=
		transfer =3D $( "<div class=3D'ui-effects-transfer'></div>" )=0A=
			.appendTo( document.body )=0A=
			.addClass( o.className )=0A=
			.css({=0A=
				top: startPosition.top - fixTop,=0A=
				left: startPosition.left - fixLeft,=0A=
				height: elem.innerHeight(),=0A=
				width: elem.innerWidth(),=0A=
				position: targetFixed ? "fixed" : "absolute"=0A=
			})=0A=
			.animate( animation, o.duration, o.easing, function() {=0A=
				transfer.remove();=0A=
				done();=0A=
			});=0A=
};=0A=
=0A=
=0A=
=0A=
}));
------=_NextPart_000_0000_01D14A12.98FB2E40--
